<!DOCTYPE html><html lang="en_US"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> · zbvae's blog</title><meta name="description" content=" - Bin Zhang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/style.css"><!-- fonts--><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" href="http://fonts.lug.ustc.edu.cn/css?family=Source+Sans+Pro:400,600" type="text/css"><!-- baidu analytics--><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?9e0cbea7d3319c6c94c71dfb93c151b8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><!-- google analytics--><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-74273646-1', 'auto');
ga('send', 'pageview');</script></head><body><input type="checkbox" id="sidebar-toggle"><aside><div class="author"><a href="/."><img src="/img/author.png" class="author-img"></a><h2 class="author-name">Bin Zhang</h2></div><div class="post-toc"><span class="toc-title">Directory</span><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#IO_基本知识"><span class="toc-text">IO 基本知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#程序代码示例"><span class="toc-text">程序代码示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#文件拷贝"><span class="toc-text">文件拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内存流的使用"><span class="toc-text">内存流的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#管道流的使用"><span class="toc-text">管道流的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Scanner_接收用户输入"><span class="toc-text">Scanner 接收用户输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#文件压缩流"><span class="toc-text">文件压缩流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#文件解压缩流"><span class="toc-text">文件解压缩流</span></a></li></ol></li></ol></div></aside><div class="main"><header><div id="top"><a href="/." class="logo-link">zbvae's blog</a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">标签</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于</a></li></ul></div></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title"></h1><div class="post-time">Apr 10, 2016</div><div class="post-content"><p>title: Java IO 学习<br>date: 2015-07-11 09:53:28<br>tags: [Java学习,技术]</p>
<hr>
<p><strong>摘要</strong>：IO无疑是学习每一门语言都要求掌握的编程知识点，一些大型项目都离不开IO的支持，因此掌握IO相关操作，对以后的学习和工作都是很有必要的。IO知识说难不难，但是每到用的时候，我们都需要查阅，本文从Java语言面向对象的特点出发，讲述Java IO的一些知识，仅供参考。<a id="more"></a></p>
<h3 id="IO_基本知识">IO 基本知识</h3><p>IO是以流的方式来组织和传播，与流水非常相似。从源头输出不断流淌输入到目的地，中间为了方便，可能还会加上水管来辅助输出，水量小的时候，一滴滴或者涓涓细流，这时候我们可以建筑水坝库存到一定量才释放，有的水流汇入江海，而有的则直接流入千家百户。</p>
<p>在Java IO体系中，</p>
<ol>
<li>根据流的成分不同，可以分为<strong>字符流</strong>和<strong>字节流</strong>两种；</li>
<li>根据流向不同，可以分为<strong>输入流</strong>和<strong>输出流</strong>；</li>
<li>根据源头不同，可以分为<strong>文件流和内存流</strong>；</li>
<li>为了便于输出和通信，Java也提供了<strong>管道流</strong>和<strong>缓存流</strong>；</li>
<li>根据输出目的地不同，可以通过<strong>打印流</strong>来控制是输出到文件还是其他地方；</li>
<li>为了支持序列化，Java还提供了<strong>对象流</strong>；</li>
<li>为了支持数据的访问和保存，Java提供了<strong>数据流</strong>；</li>
<li>为了支持文件的压缩与解压缩，Java提供了<strong>文件压缩与解压缩流</strong>。</li>
</ol>
<p>以下关于各个流的几个注意点：</p>
<ol>
<li>以内存为参照：流入内存为输入流，流出内存，汇入外地，为输出流。</li>
<li>字符流是以字符为单位，主要处理文本文件；字节流以字节为传输单位，可以处理文本，语音和图像等任何信息，字节流的应用范围更广。Java提供了InputStreamReader和OutputStreamWriter来实现字符流与字节流的转换。</li>
<li>管道流主要解决线程间通信，应用不多。</li>
<li>缓存流为了数据的传输提供了一种包装的形式，例如BufferedReader则提供了readLine()方法，可以更好地处理数据的流通。</li>
<li>打印流需要制定流向，可以流向屏幕，可以流向文件，在构造的时候进行装填即可。</li>
<li>对象流无疑是将数据以对象的形式保存到文件或其他地方，提供了一种数据持久化方案，配合实现对象序列化，在很多大型项目都有非常重要的使用。</li>
<li>数据流用于保存和读取数据，readInt或writeInt方法等。</li>
<li>Scanner接收用户输入，更便捷的处理方式。</li>
<li>文件压缩和解压缩流，提供了文件压缩与解压缩方法，每个压缩文件都是一个ZipEntry实体对象。</li>
</ol>
<h3 id="程序代码示例">程序代码示例</h3><h4 id="文件拷贝">文件拷贝</h4><p>该例子系统讲述了字符流、字节流、输入流、输出流、包装流、打印流的使用。需要注意的时候，在程序执行完，需要关闭打开的所有流。</p>
<pre><code><span class="keyword">class</span> FileCopy{
     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> copyByChar(String srcFilePath, String desFilePath){
        <span class="keyword">File</span> srcFile = <span class="keyword">null</span>;
        <span class="keyword">File</span> desFile = <span class="keyword">null</span>;
      BufferedReader br = <span class="keyword">null</span>;
        PrintWriter pw = <span class="keyword">null</span>;
        <span class="keyword">try</span>{
            srcFile = <span class="keyword">new</span> <span class="keyword">File</span>(srcFilePath);
            desFile = <span class="keyword">new</span> <span class="keyword">File</span>(desFilePath);
            br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(srcFile));
            pw = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(desFile));
            String temp = <span class="keyword">null</span>;
            <span class="keyword">while</span>((temp = br.readLine()) != <span class="keyword">null</span>){
                pw.<span class="keyword">println</span>(temp);
                pw.flush();
            }
        }<span class="keyword">catch</span>(Exception e){
               e.printStackTrace();
        }<span class="keyword">finally</span>{
               <span class="keyword">try</span>{
                pw.close();
                br.close();
               }<span class="keyword">catch</span>(Exception e){
                e.printStackTrace();
               }
        }
        System.out.<span class="keyword">println</span>(<span class="string">"copy file by char done"</span>);
     }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> copyByByte(String srcFilePath, String desFilePath){
        <span class="keyword">File</span> srcFile = <span class="keyword">null</span>;
          <span class="keyword">File</span> desFile = <span class="keyword">null</span>;
          InputStream is = <span class="keyword">null</span>;
          OutputStream os = <span class="keyword">null</span>;
          <span class="keyword">try</span>{
               srcFile = <span class="keyword">new</span> <span class="keyword">File</span>(srcFilePath);
               desFile = <span class="keyword">new</span> <span class="keyword">File</span>(desFilePath);
               is = <span class="keyword">new</span> FileInputStream(srcFile);
              os = <span class="keyword">new</span> FileOutputStream(desFile);
               <span class="keyword">byte</span> buf[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];
               <span class="keyword">int</span> len = <span class="number">0</span>;
               <span class="keyword">while</span>((len = is.<span class="keyword">read</span>(buf)) != -<span class="number">1</span>){
                os.<span class="keyword">write</span>(buf,<span class="number">0</span>,len);
                os.flush();
               }
          }<span class="keyword">catch</span>(Exception e){
               e.printStackTrace();
          }<span class="keyword">finally</span>{
               <span class="keyword">try</span>{
                    os.close();
                is.close();
               }<span class="keyword">catch</span>(Exception e){
               }
          }
          System.out.<span class="keyword">println</span>(<span class="string">"copy file by byte done"</span>);
    }
}
</code></pre><h4 id="内存流的使用">内存流的使用</h4><pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> testByteArrayStream(<span class="keyword">String</span> <span class="built_in">str</span>){
      ByteArrayInputStream bais = <span class="keyword">null</span>;
      ByteArrayOutputStream baos = <span class="keyword">null</span>;
      <span class="keyword">try</span>{
           bais = <span class="keyword">new</span> ByteArrayInputStream(<span class="built_in">str</span>.getBytes());
          baos = <span class="keyword">new</span> ByteArrayOutputStream();

           <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">str</span>.length();i++){
            <span class="built_in">char</span> c = (<span class="built_in">char</span>)bais.read();
            baos.write(Character.toUpperCase(c));
           }
           System.out.<span class="built_in">println</span>(baos.toString());

       <span class="comment">/*
       byte buf[] = new byte[1024];
       int len = bais.read(buf);
       baos.write(buf,0,len);
       System.out.println(baos.toString().toUpperCase());
       */</span>
      }<span class="keyword">catch</span>(Exception e){
           e.printStackTrace();
      }
}
</code></pre><h4 id="管道流的使用">管道流的使用</h4><pre><code><span class="keyword">class</span> <span class="title">Sender</span> <span class="title">implements</span> <span class="title">Runnable</span> {
     <span class="keyword">private</span> PipedOutputStream <span class="keyword">out</span> = <span class="keyword">null</span>;

     <span class="function"><span class="keyword">public</span> <span class="title">Sender</span>(<span class="params"></span>)</span>{
          <span class="keyword">out</span> = <span class="keyword">new</span> PipedOutputStream();
     }

     <span class="function"><span class="keyword">public</span> PipedOutputStream <span class="title">getOut</span>(<span class="params"></span>)</span>{
          <span class="keyword">return</span> <span class="keyword">out</span>;
     }

     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span>{
          String message = <span class="string">"hello, moto"</span>;
          <span class="keyword">try</span>{
               <span class="keyword">out</span>.write(message.getBytes());
          }<span class="keyword">catch</span>(Exception e){
               e.printStackTrace();
          }<span class="keyword">finally</span>{
               <span class="keyword">try</span>{
                    <span class="keyword">out</span>.close();
               }<span class="keyword">catch</span>(Exception e){
               }
          }
     }
}

<span class="keyword">class</span> <span class="title">Receiver</span> <span class="title">implements</span> <span class="title">Runnable</span> {
     <span class="keyword">private</span> PipedInputStream <span class="keyword">in</span> = <span class="keyword">null</span>;

     <span class="function"><span class="keyword">public</span> <span class="title">Receiver</span>(<span class="params"></span>)</span>{
          <span class="keyword">in</span> = <span class="keyword">new</span> PipedInputStream();
     }

     <span class="function"><span class="keyword">public</span> PipedInputStream <span class="title">getIn</span>(<span class="params"></span>)</span>{
          <span class="keyword">return</span> <span class="keyword">in</span>;
     }

     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span>{
          <span class="keyword">byte</span> buf[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];
          <span class="keyword">int</span> len = <span class="number">0</span>;
          <span class="keyword">try</span>{
               len = <span class="keyword">in</span>.read(buf);
          }<span class="keyword">catch</span>(Exception e){
               e.printStackTrace();
          }<span class="keyword">finally</span>{
               <span class="keyword">try</span>{
                <span class="keyword">in</span>.close();
               }<span class="keyword">catch</span>(Exception e){
               }
          }
          System.<span class="keyword">out</span>.println(<span class="string">"recevied:"</span> + <span class="keyword">new</span> String(buf,<span class="number">0</span>,len));
     }
}
</code></pre><p>以上是发送线程和接收线程，为了支持线程通信，需要使用PipedOutpuStream的connect方法连接PipedInputStream。    </p>
<pre><code>public static void testPipedStream<span class="literal">()</span>{
    <span class="type">Sender</span> sender = <span class="keyword">new</span> <span class="type">Sender</span><span class="literal">()</span>;
    <span class="type">Receiver</span> receiver = <span class="keyword">new</span> <span class="type">Receiver</span><span class="literal">()</span>;
    <span class="keyword">try</span>{
         sender.getOut<span class="literal">()</span>.connect(receiver.getIn<span class="literal">()</span>);
    }catch(<span class="type">Exception</span> e){
         e.printStackTrace<span class="literal">()</span>;
    }
    <span class="keyword">new</span> <span class="type">Thread</span>(sender).start<span class="literal">()</span>;
    <span class="keyword">new</span> <span class="type">Thread</span>(receiver).start<span class="literal">()</span>;
}
</code></pre><h4 id="Scanner_接收用户输入">Scanner 接收用户输入</h4><pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testScaner</span>(<span class="params"></span>)</span>{
    Scanner sc = <span class="keyword">new</span> Scanner(System.<span class="keyword">in</span>);
    String name = sc.next();
    <span class="keyword">int</span> age = sc.nextInt();
    System.<span class="keyword">out</span>.println(<span class="string">"name="</span>+name+<span class="string">" age="</span>+age);
}
</code></pre><h4 id="文件压缩流">文件压缩流</h4><pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> testFileZip(String srcFilePath, String zipFilePath){
      <span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">null</span>;
      InputStream in = <span class="keyword">null</span>;
      ZipOutputStream zipOut = <span class="keyword">null</span>;
      <span class="keyword">try</span>{
           <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(srcFilePath);
           in = <span class="keyword">new</span> FileInputStream(<span class="keyword">file</span>);
           zipOut = <span class="keyword">new</span> ZipOutputStream(<span class="keyword">new</span> FileOutputStream(zipFilePath));
           zipOut.putNextEntry(<span class="keyword">new</span> ZipEntry(<span class="keyword">file</span>.getName()));
           zipOut.setComment(<span class="string">"hello world"</span>);
           <span class="keyword">int</span> temp = <span class="number">0</span>;
           <span class="keyword">while</span>((temp = in.<span class="keyword">read</span>()) != -<span class="number">1</span>){
            zipOut.<span class="keyword">write</span>(temp);
           }
      }<span class="keyword">catch</span>(Exception e){
           e.printStackTrace();
      }<span class="keyword">finally</span>{
           <span class="keyword">try</span>{
            zipOut.close();
            in.close();
           }<span class="keyword">catch</span>(Exception e){
            e.printStackTrace();
           }
      }
      System.out.<span class="keyword">println</span>(<span class="string">"zip done"</span>);
}
</code></pre><h4 id="文件解压缩流">文件解压缩流</h4><pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> testFileUnZip(String zipFilePath){
      <span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">null</span>;
       <span class="keyword">File</span> outFile = <span class="keyword">null</span>;
       ZipFile zipFile = <span class="keyword">null</span>;
       ZipInputStream zipIn = <span class="keyword">null</span>;
       ZipEntry entry = <span class="keyword">null</span>;
       InputStream in = <span class="keyword">null</span>;
       OutputStream out = <span class="keyword">null</span>;
       <span class="keyword">try</span>{
           <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(zipFilePath);
           zipFile = <span class="keyword">new</span> ZipFile(<span class="keyword">file</span>);
           zipIn = <span class="keyword">new</span> ZipInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">file</span>));
           <span class="keyword">while</span>((entry = zipIn.getNextEntry()) != <span class="keyword">null</span>){
            System.out.<span class="keyword">println</span>(<span class="string">"un zip "</span> +entry.getName());
            outFile = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"./unzip/"</span> + entry.getName());
            <span class="keyword">if</span>(!outFile.getParentFile().exists()){
                 outFile.getParentFile().mkdir();
            }
            <span class="keyword">if</span>(!outFile.exists()){
                 outFile.createNewFile();
            }
            in = zipFile.getInputStream(entry);
            out = <span class="keyword">new</span> FileOutputStream(outFile);
            <span class="keyword">int</span> temp = <span class="number">0</span>;
            <span class="keyword">while</span>((temp = in.<span class="keyword">read</span>()) != -<span class="number">1</span>){
                 out.<span class="keyword">write</span>(temp);
            }
           }
      }<span class="keyword">catch</span>(Exception e){
           e.printStackTrace();
      }<span class="keyword">finally</span>{
           <span class="keyword">try</span>{
            out.close();
            in.close();
            zipIn.close();
           }<span class="keyword">catch</span>(Exception e){
            e.printStackTrace();
           }
      }
      System.out.<span class="keyword">println</span>(<span class="string">"un zip done"</span>);
}
</code></pre><p>以上几乎包含了所有Java Io流的操作，关于对象流及其支持的序列化与反序列化特性将在后面介绍。</p>
</div></article></div><div class="tags"></div><div class="paginator"><a href="/2016/04/10/Java微信公众号应用部署在阿里云ECS/" class="prev"><i class="fa fa-chevron-left"></i><span> 上一页</span></a><a href="/2016/03/08/CENTOS-6-5安装vncserver/" class="next"><span>下一页</span><i class="fa fa-chevron-right"></i></a></div></section><footer><section id="comments"><div data-thread-key="http://blog.zbvae.com/2016/04/10/Java-IO-学习/index.html" data-title="" data-url="http://blog.zbvae.com/2016/04/10/Java-IO-学习/index.html" class="ds-thread"></div><script type="text/javascript">var duoshuoQuery = {short_name: "zbbk" };
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></section><div class="copyright"><p>© 2015 -  2016<span class="heart"><i class="icon-next-heart fa fa-heart"></i></span><a href="http://blog.zbvae.com">Bin Zhang</a></p></div></footer></div><label for="sidebar-toggle" class="sidebar-menu"><div class="menu"></div></label><label class="back2top"> <a href="#top"><div class="arrow"></div></a></label></body></html>