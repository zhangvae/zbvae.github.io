<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="UNHn0suvw2" />
  <meta name="google-site-verification" content="2AQ75-m5QPW0KN4FrtIw60tT9cSP-sf_6V5Md4QyzaU" />
  
  <title>数据结构-串 | zbvae&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="摘要 串是一种数据元素类型只能为字符的线性数据结构，可以理解为字符序列。按存储结构也可以分为顺序串和链式串，一般以顺序串为代表，定义在串上的操作，如求串长，判断空串，判断串是否为满，指定位置插入字符，指定位置删除字符，这些操作与线性表中一模一样，所以，有兴趣的读者可以参照本系列博客数据结构-线性表进行阅读。对于串，主要算法有模式匹配，而本文所讲的重点也是串的KMP模式匹配算法。">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构-串">
<meta property="og:url" content="http://blog.zbvae.com/2015/07/20/数据结构-串/index.html">
<meta property="og:site_name" content="zbvae's blog">
<meta property="og:description" content="摘要 串是一种数据元素类型只能为字符的线性数据结构，可以理解为字符序列。按存储结构也可以分为顺序串和链式串，一般以顺序串为代表，定义在串上的操作，如求串长，判断空串，判断串是否为满，指定位置插入字符，指定位置删除字符，这些操作与线性表中一模一样，所以，有兴趣的读者可以参照本系列博客数据结构-线性表进行阅读。对于串，主要算法有模式匹配，而本文所讲的重点也是串的KMP模式匹配算法。">
<meta property="og:image" content="http://blog.zbvae.com/images/next.jpg">
<meta property="og:image" content="http://blog.zbvae.com/images/next1.jpg">
<meta property="og:image" content="http://blog.zbvae.com/images/next2.jpg">
<meta property="og:image" content="http://blog.zbvae.com/images/kmp.jpg">
<meta property="og:updated_time" content="2015-08-06T11:45:18.652Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据结构-串">
<meta name="twitter:description" content="摘要 串是一种数据元素类型只能为字符的线性数据结构，可以理解为字符序列。按存储结构也可以分为顺序串和链式串，一般以顺序串为代表，定义在串上的操作，如求串长，判断空串，判断串是否为满，指定位置插入字符，指定位置删除字符，这些操作与线性表中一模一样，所以，有兴趣的读者可以参照本系列博客数据结构-线性表进行阅读。对于串，主要算法有模式匹配，而本文所讲的重点也是串的KMP模式匹配算法。">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<div style="z-index:9999; position: absolute; top: 10px; left: 75px;">
			<object width="160" height="70" align="middle" id="honehoneclock" classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" codebase="http://fpdownload.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=8,0,0,0"><PARAM NAME="_cx" VALUE="4233"><PARAM NAME="_cy" VALUE="1852"><PARAM NAME="FlashVars" VALUE=""><PARAM NAME="Movie" VALUE="http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_tr.swf"><PARAM NAME="Src" VALUE="http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_tr.swf"><PARAM NAME="WMode" VALUE="Transparent"><PARAM NAME="Play" VALUE="0"><PARAM NAME="Loop" VALUE="-1"><PARAM NAME="Quality" VALUE="High"><PARAM NAME="SAlign" VALUE=""><PARAM NAME="Menu" VALUE="-1"><PARAM NAME="Base" VALUE=""><PARAM NAME="AllowScriptAccess" VALUE="always"><PARAM NAME="Scale" VALUE="ShowAll"><PARAM NAME="DeviceFont" VALUE="0"><PARAM NAME="EmbedMovie" VALUE="0"><PARAM NAME="BGColor" VALUE="FFFFFF"><PARAM NAME="SWRemote" VALUE=""><PARAM NAME="MovieData" VALUE=""><PARAM NAME="SeamlessTabbing" VALUE="1"><PARAM NAME="Profile" VALUE="0"><PARAM NAME="ProfileAddress" VALUE=""><PARAM NAME="ProfilePort" VALUE="0"><PARAM NAME="AllowNetworking" VALUE="all"><PARAM NAME="AllowFullScreen" VALUE="false"><PARAM NAME="AllowFullScreenInteractive" VALUE="false"><PARAM NAME="IsDependent" VALUE="0">
				<param name="allowScriptAccess" value="always">
				<param name="movie" value="http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_tr.swf">
				<param name="quality" value="high">
				<param name="bgcolor" value="#ffffff">
				<param name="wmode" value="transparent">
				<embed name="honehoneclock" width="160" height="70" align="middle" pluginspage="http://www.macromedia.com/go/getflashplayer" src="http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_tr.swf" type="application/x-shockwave-flash" wmode="transparent" quality="high" bgcolor="#ffffff" allowscriptaccess="always">
			</object>
		</div>
		<!--
		<a href="https://github.com/zbvae">
			<img style="position: absolute; top: 0; left: 0; border: 0;" src="https://camo.githubusercontent.com/82b228a3648bf44fc1163ef44c62fcc60081495e/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_red_aa0000.png">
		</a>-->
  
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/zbvae.JPG" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Bin Zhang</a></h1>
		</hgroup>

		
		<p class="header-subtitle">这个世界怎么了，明明可以靠才华吃饭，偏要靠脸!</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主頁</a></li>
				        
							<li><a href="/archives">歸檔</a></li>
				        
							<li><a href="/MyAlbum">相冊</a></li>
				        
							<li><a href="/books/">閱讀</a></li>
				        
							<li><a href="/music/">音樂</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/zbvae/" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/zbvae/" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="mailto:zbbk@zbvae.com" title="mail">mail</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/zbvae" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Java学习/" style="font-size: 20px;">Java学习</a> <a href="/tags/云服务器/" style="font-size: 12.5px;">云服务器</a> <a href="/tags/微信公众号/" style="font-size: 10px;">微信公众号</a> <a href="/tags/心情/" style="font-size: 10px;">心情</a> <a href="/tags/技术/" style="font-size: 10px;">技术</a> <a href="/tags/技术交流/" style="font-size: 15px;">技术交流</a> <a href="/tags/数据结构/" style="font-size: 17.5px;">数据结构</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">中南大学09级学生，现为2013级研究生，写论文中，求职中，待毕业中！</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Bin Zhang</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/zbvae.JPG" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Bin Zhang</h1>
			</hgroup>
			
			<p class="header-subtitle">这个世界怎么了，明明可以靠才华吃饭，偏要靠脸!</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主頁</a></li>
		        
					<li><a href="/archives">歸檔</a></li>
		        
					<li><a href="/MyAlbum">相冊</a></li>
		        
					<li><a href="/books/">閱讀</a></li>
		        
					<li><a href="/music/">音樂</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/zbvae/" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/zbvae/" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="mailto:zbbk@zbvae.com" title="mail">mail</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/zbvae" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-数据结构-串" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/20/数据结构-串/" class="article-date">
  	<time datetime="2015-07-20T07:00:00.000Z" itemprop="datePublished">2015-07-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      数据结构-串
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
		
        <!-- Table of Contents -->
        
          
            <div id="toc" class="article-toc">
            <h2>目录</h2>
              <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-串的定义"><span class="toc-number">1.</span> <span class="toc-text">1.串的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-朴素匹配算法"><span class="toc-number">2.</span> <span class="toc-text">2.朴素匹配算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-KMP模式匹配算法"><span class="toc-number">3.</span> <span class="toc-text">3.KMP模式匹配算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1next_数组的计算"><span class="toc-number">3.1.</span> <span class="toc-text">3.1next 数组的计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2KMP算法实现"><span class="toc-number">3.2.</span> <span class="toc-text">3.2KMP算法实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3next_数组的优化"><span class="toc-number">3.3.</span> <span class="toc-text">3.3next 数组的优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-KMP算法的时间复杂度"><span class="toc-number">4.</span> <span class="toc-text">4.KMP算法的时间复杂度</span></a></li></ol>
            </div>
            <script type="text/javascript">
              var _article = document.getElementsByClassName('article')[0];
              <!-- setTimeout("_article.style.marginRight = '211px'",0);  -->
              setTimeout("_article.className += ' article2'",0);
              setTimeout("document.getElementById('toc').style.right = '15px'", 0);
            </script>
          
        
        <p><strong>摘要</strong> 串是一种数据元素类型只能为字符的线性数据结构，可以理解为字符序列。按存储结构也可以分为顺序串和链式串，一般以顺序串为代表，定义在串上的操作，如求串长，判断空串，判断串是否为满，指定位置插入字符，指定位置删除字符，这些操作与线性表中一模一样，所以，有兴趣的读者可以参照本系列博客数据结构-线性表进行阅读。对于串，主要算法有模式匹配，而本文所讲的重点也是串的KMP模式匹配算法。<a id="more"></a></p>
<h2 id="1-串的定义">1.串的定义</h2><p>串是一种类似线性表的线性数据结构，其数据类型只能为字符，下面是顺序串的定义，可以发现与顺序表的定义一模一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeqString</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STRING_SIZE = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">char</span> data[] = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SeqString</span><span class="params">()</span></span>&#123;</span><br><span class="line">		data = <span class="keyword">new</span> <span class="keyword">char</span>[STRING_SIZE];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SeqString</span><span class="params">(<span class="keyword">char</span>[] data)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data = <span class="keyword">new</span> <span class="keyword">char</span>[STRING_SIZE];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;data.length;i++)&#123;</span><br><span class="line">			<span class="keyword">this</span>.insert(i+<span class="number">1</span>, data[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.length;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.length == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.length == STRING_SIZE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">char</span> val)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(pos &lt; <span class="number">1</span> || pos &gt; length+<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.isFull())</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=length-<span class="number">1</span>;i&gt;=pos-<span class="number">1</span>;i--)</span><br><span class="line">			data[i+<span class="number">1</span>] = data[i];</span><br><span class="line">		data[pos-<span class="number">1</span>] = val;</span><br><span class="line">		<span class="keyword">this</span>.length++;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(pos &lt; <span class="number">1</span> || pos &gt; length)</span><br><span class="line">			<span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty())</span><br><span class="line">			<span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">		<span class="keyword">char</span> c = data[pos-<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=pos;i&lt;length;i++)</span><br><span class="line">			data[i-<span class="number">1</span>] = data[i];</span><br><span class="line">		<span class="keyword">this</span>.length--;</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> String(<span class="keyword">this</span>.data,<span class="number">0</span>,<span class="keyword">this</span>.length);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于串的结构类型定义，这里就不再赘述。下面介绍串的模式匹配算法。先以朴素匹配算法作为引例，然后在此基础之上，介绍KMP算法。</p>
<h2 id="2-朴素匹配算法">2.朴素匹配算法</h2><p>串的朴素匹配算法，实现简单，容易理解，也可以认为是一种暴力匹配算法，将主串与模式串中的字符进行一个一个的比对，如果匹配成功，主串与模式串各自递进向前滑动一位，如果匹配失败，那么一切从头来过，模式串重新从0位置开始，主串从下一个位置开始，这里的下一个位置的计算(i-j+1，因为j走了多少，i也走了多少，然后下一个也就是加1)，循环结束条件为模式串匹配完毕，即在主串中找到了所有模式串的字符，或者主串都走完了，还没有找到与模式串匹配的子串，结束匹配，返回-1.</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * [indexOf description]</span><br><span class="line"> * @param  t [mask <span class="type">string</span>]</span><br><span class="line"> * @<span class="constant">return</span>   [<span class="keyword">first</span> pos <span class="keyword">of</span> mask <span class="keyword">in</span> main <span class="type">string</span>]</span><br><span class="line"> */</span><br><span class="line">public int indexOf(SeqString t)&#123;</span><br><span class="line">	SeqString s = this;</span><br><span class="line">	int i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i &lt; s.<span class="property">length</span> &amp;&amp; j &lt; t.<span class="property">length</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s.data[i] == t.data[j])&#123;</span><br><span class="line">			i++;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			j=<span class="number">0</span>;</span><br><span class="line">			i = i-j+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(j == t.<span class="property">length</span>)</span><br><span class="line"><span class="command">		return</span> i-j;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line"><span class="command">		return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-KMP模式匹配算法">3.KMP模式匹配算法</h2><p>上述朴素匹配算法，实现简单，易于理解，但是其时间复杂度时O(m*n)，其中m是主串长度，n是模式串长度。算法的关键在于，当主串中i位置字符与模式串中j位置字符失配时，模式串从0开始，主串也回溯到i-j+1的位置，其实如果充分利用模式串失配位置字符之前的字符序列信息，就可以发现，主串不需要回溯，只需要回溯模式串即可，而且模式串每次回溯的步长可以根据失配位置之前的字符隐含关系来确定，失配位置之前的所有字符如果拥有相同前缀和后缀字符，那么模式串就可以不用回溯到开始位置，而只需要回溯到最长公共前缀的下一个位置即可。这样主串不用回溯，模式串减少回溯的位置，该算法的时间复杂度变为O(m+n)。</p>
<p>Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法。</p>
<h3 id="3-1next_数组的计算">3.1next 数组的计算</h3><p>定义next数组为模式串中每一个字符之前的最长公共前缀后缀的长度。同时定义next[0] = -1。对于给定的模式串：ABCDABD，它的最大长度表及next 数组分别如下：</p>
<center><img src="/images/next.jpg" alt="next"></center>

<p>上图中最大长度值为该字符位置的最长公共前缀与后缀长度，前最大长度值表向右移动一位，并将next[0]赋值为-1就得到了next数组。<strong>模式串next数组的求法是KMP算法中最难理解的部分</strong>。它需要对模式串进行递推搜索：</p>
<blockquote>
<ul>
<li>如果对于值k，已有p0 p1, …, pk-1 = pj-k pj-k+1, …, pj-1，相当于next[j] = k。<blockquote>
<ul>
<li>next[j] = k 代表p[j] 之前的模式串子串中，有长度为k 的相同前缀和后缀</li>
<li>有了这个next 数组，在KMP匹配中，当模式串中j 处的字符失配时，下一步用next[j]处的字符继续跟文本串匹配，相当于模式串向右移动j - next[j] 位。</li>
</ul>
</blockquote>
</li>
<li>递推问题：已知next [0, …, j]，如何求出next [j + 1]呢？<blockquote>
<ul>
<li>若p[k] == p[j]，则next[j + 1 ] = next [j] + 1 = k + 1</li>
<li>若p[k ] ≠ p[j]，如果此时p[ next[k] ] == p[j ]，则next[ j + 1 ] =  next[k] + 1，否则继续递归前缀索引k = next[k]，而后重复此过程。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p>为何递归前缀索引k = next[k]，就能找到长度更小的相同前缀后缀呢?这又归根到next数组的含义。<strong>为了寻找长度相同的前缀后缀，我们拿前缀 p0 pk-1 pk 去跟后缀pj-k pj-1 pj匹配，如果pk 跟pj 失配，下一步就是用p[next[k]] 去跟pj 继续匹配，如果p[ next[k] ]跟pj还是不匹配，则下一步用p[ next[ next[k] ] ]去跟pj匹配。</strong>。相当于在不断的递归k = next[k]，直到要么找到长度更小的相同前缀后缀，要么没有长度更小的相同前缀后缀。</p>
<p>下面这段代码展示了模式串next数组的求法，其中data[k]表示前缀，data[j]表示后缀。</p>
 <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">int</span>[] <span class="keyword">next</span>()&#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">next</span>[] = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">	<span class="keyword">next</span>[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>, k = -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(j &lt; length-<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(k == -<span class="number">1</span> || data[k] == data[j])&#123;</span><br><span class="line">			k++;</span><br><span class="line">			j++;</span><br><span class="line">			<span class="keyword">next</span>[j] = k;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			k = <span class="keyword">next</span>[k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">next</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2KMP算法实现">3.2KMP算法实现</h3><p>有了模式串next数组，再来实现KMP算法就变得简单很多了。KMP算法相对于朴素算法的改进在于，如果模式串在j位置失配，主串无需回溯，模式串每次回溯到next[j]位置。下面是KMP算法的实现代码。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">int</span> indexOf_KMP(SeqString t)&#123;</span><br><span class="line">	SeqString <span class="keyword">s</span> = this;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">next</span>[] = t.getNext();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(i &lt; <span class="keyword">s</span>.<span class="keyword">length</span> &amp;&amp; j &lt; t.<span class="keyword">length</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(j == -<span class="number">1</span> || <span class="keyword">s</span>.data[i] == t.data[j])&#123;</span><br><span class="line">			i++;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			j = <span class="keyword">next</span>[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(j == t.<span class="keyword">length</span>)</span><br><span class="line">		<span class="keyword">return</span> i-j;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3next_数组的优化">3.3next 数组的优化</h3><p>如果用之前的next 数组方法求模式串“abab”的next 数组，可得其next 数组为-1 0 0 1（0 0 1 2整体右移一位，初值赋为-1），当它跟下图中的文本串去匹配的时候，发现b跟c失配，于是模式串右移j - next[j] = 3 - 1 =2位。</p>
<center><img src="/images/next1.jpg" alt="next优化1"></center>

<p>右移2位后，b又跟c失配。事实上，因为在上一步的匹配中，已经得知p.data[3] = b，与s.data[3] = c失配，在3位置失配，由于next[3]=1，而右移两位之后，让p.data[1] = b 再跟s.data[3]匹配时，必然失配。问题出在哪呢？</p>
<center><img src="/images/next2.jpg" alt="next优化2"></center>

<p>问题出在不该出现p.data[j] = p.data[ next[j] ]。为什么呢？理由是：当p.data[j] != s.data[i] 时，下次匹配必然是p.data[ next [j]] 跟s.data[i]匹配，如果p.data[j] = p.data[ next[j] ]，必然导致后一步匹配失败（因为p.data[j]已经跟s.data[i]失配，然后你还用跟p.data[j]等同的值p.data[next[j]]去跟s.data[i]匹配，很显然，必然失配），所以不能允许p.data[j] = p.data[ next[j ]]。如果出现了p.data[j] = p.data[ next[j] ]咋办呢？如果出现了，则需要再次递归，即令next[j] = next[ next[j] ]。</p>
<p>优化后的next数组的求法如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">int</span>[] getNext()&#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">next</span>[] = new <span class="keyword">int</span>[<span class="keyword">length</span>];</span><br><span class="line">	<span class="keyword">next</span>[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>, k = -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(j &lt; <span class="keyword">length</span>-<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="regexp">//already</span> knows <span class="keyword">next</span>[j] = k, how to compute <span class="keyword">next</span>[j+<span class="number">1</span>]</span><br><span class="line">		<span class="keyword">if</span>(k == -<span class="number">1</span> || data[j] == data[k])&#123;</span><br><span class="line">			k++;</span><br><span class="line">			j++;</span><br><span class="line">			<span class="keyword">if</span>(data[j] != data[k])</span><br><span class="line">				<span class="keyword">next</span>[j] = k;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">next</span>[j] = <span class="keyword">next</span>[k];</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			k = <span class="keyword">next</span>[k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">next</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用优化过后的next 数组求法，可知模式串“abab”的新next数组为：-1 0 -1 0。下面这幅图揭示了KMP算法的实际执行过程。</p>
<center><img src="/images/kmp.jpg" alt="KMP算法图示"></center>

<p>上述部分图示和文字来源于 <a href="http://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="external">http://blog.csdn.net/v_july_v/article/details/7041827</a></p>
<h2 id="4-KMP算法的时间复杂度">4.KMP算法的时间复杂度</h2><p>如果文本串的长度为n，模式串的长度为m，那么匹配过程的时间复杂度为O(n)，算上计算next的O(m)时间，KMP的整体时间复杂度为O(m + n)。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/07/21/数据结构-多维数组和广义表/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          数据结构-多维数组和广义表
        
      </div>
    </a>
  
  
    <a href="/2015/07/20/数据结构-栈与队列/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">数据结构-栈与队列</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>

<div class="share">
  
  <div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">post.share: &nbsp; </span>
		<a class="jiathis_button_weixin">微信</a>
		<a class="jiathis_button_cqq">QQ好友</a>
		<a class="jiathis_button_qzone">QQ空间</a>
		<a class="jiathis_button_tsina">新浪微博</a>
		<a href="http://www.jiathis.com/share?uid=2080230" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
		<a class="jiathis_counter_style"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=2080230" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>
<!-- JiaThis Button BEGIN -->

  

  
</div>

<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="数据结构-串" data-title="数据结构-串" data-url="http://blog.zbvae.com/2015/07/20/数据结构-串/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"[object Object]"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>





</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Bin Zhang
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>



<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-51346799-2', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
  
</body>
</html>