<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[zbvae's blog]]></title>
  <subtitle><![CDATA[这个世界怎么了，明明可以靠才华吃饭，偏要靠脸!]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.zbvae.com//"/>
  <updated>2016-02-24T03:41:16.896Z</updated>
  <id>http://blog.zbvae.com//</id>
  
  <author>
    <name><![CDATA[Bin Zhang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[新新新年]]></title>
    <link href="http://blog.zbvae.com/2016/02/24/%E6%96%B0%E6%96%B0%E6%96%B0%E5%B9%B4/"/>
    <id>http://blog.zbvae.com/2016/02/24/新新新年/</id>
    <published>2016-02-24T03:00:38.000Z</published>
    <updated>2016-02-24T03:41:16.896Z</updated>
    <content type="html"><![CDATA[<h3 id="新的一年来临了">新的一年来临了</h3><p>从家里带着未收拾好的心情，就赶到了学校，为的是一次集体拜年。</p>
<h3 id="我要长大">我要长大</h3><p>总觉着自己还没成熟，在某些事情上的观察力和判断力，远不及别人。</p>
<h3 id="要不要读博">要不要读博</h3><p><strong>读博</strong> <em>or</em> <strong>工作</strong>，以前并没有这样的疑惑，可如今，谁也想不到，我尽然也会产生这样纠结与思考。</p>
<h3 id="好好做事">好好做事</h3><p>想归想，但还是要珍惜最后几个月的研究生生活，把该做的事完满的完成，给老师，给同学，给自己都交上一份完美的青春答卷。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="新的一年来临了">新的一年来临了</h3><p>从家里带着未收拾好的心情，就赶到了学校，为的是一次集体拜年。</p>
<h3 id="我要长大">我要长大</h3><p>总觉着自己还没成熟，在某些事情上的观察力和判断力，远不及别人。</p>
<h3 id="要不要]]>
    </summary>
    
      <category term="心情" scheme="http://blog.zbvae.com/tags/%E5%BF%83%E6%83%85/"/>
    
      <category term="随笔" scheme="http://blog.zbvae.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java Web中文乱码问题解决方法]]></title>
    <link href="http://blog.zbvae.com/2015/07/31/Java-Web%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://blog.zbvae.com/2015/07/31/Java-Web中文乱码问题解决方法/</id>
    <published>2015-07-31T08:31:52.000Z</published>
    <updated>2015-07-31T09:04:17.062Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong> 所有基于Java的应用程序都面临着一个让初学者非常头痛的问题-中文乱码。由于Java的内核和.class文件都是基于Unicode的，这使得Java程序具有良好的跨平台特性，但却容易造成中文乱码。另外，Web容器的默认编码方式是ISO-8859-1，所以在Java Web程序中用户在客户端输入以GBK方式编码的中文传输到服务器端，由Web容器以ISO-8859-1方式包装编码，并以该编码形式的html页面回送到本地客户端，这样都会造成中文乱码的问题，本文就Java Web中文乱码问题提出一些解决方案。<a id="more"></a></p>
<h2 id="1-以POST方式提交的表单数据中含有中文">1.以POST方式提交的表单数据中含有中文</h2><p>由于Web容器默认的编码方式是ISO-8859-1，在Servlet/JSP程序中，通过请求对象的<strong>getParameter</strong>方法得到的字符串是以ISO-8859-1转换而来，这是导致乱码产生的原因之一。为了避免容器以ISO-8859-1编码方式返回字符串，对于以POST提交的表单数据，可以在获取请求参数之前，调用<code>request.setCharacterEncoding(&quot;GBK&quot;)</code>，明确指定正文使用的编码方式是GBK。在向浏览器回送中文数据html页面时，调用<code>response.setContentType(&quot;text/html;charset=GBK&quot;)</code>，指定输出内容的编码方式是GBK。</p>
<p>对于JSP页面，在获取请求参数值之前，加上以下代码：</p>
<blockquote>
<p>&lt;%request.setCharacterEncoding(“GBK”);%&gt;</p>
</blockquote>
<p>为了指定输出内容的编码格式，设置页面属性：</p>
<blockquote>
<p>&lt;%page contentType=”text/html; charset=GBK” %&gt;</p>
</blockquote>
<p>在Web容器转换JSP页面后的Servlet类中，会自动添加以下代码：</p>
<blockquote>
<p>response.setContentType(“text/html; charset=GBK”);</p>
</blockquote>
<h2 id="2-以GET方式提交的表单数据中含有中文">2.以GET方式提交的表单数据中含有中文</h2><p>当提交表单采用GET方法时，提交的数据作为查询字符串被附加到URL的末端，发送到服务器，此时在服务器调用setCharacterEncoding方法也就没有作用了，我们需要在得到请求参数值后，自己做正确的编码转换。</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> name = <span class="built_in">request</span>.getParameter(<span class="string">"name"</span>);</span><br><span class="line">name = <span class="keyword">new</span> <span class="built_in">String</span>(name.getBytes(<span class="string">"ISO-8859-1"</span>), <span class="string">"GBK"</span>);</span><br></pre></td></tr></table></figure>
<p>上述代码在第一行，调用getParameter方法得到的字符串name的Unicode值是以ISO-8859-1的编码转换而来，调用names.getBytes(“ISO-8859-1”)，将得到原始的GBK编码值，接着对new String()方法的调用将以GBK字符集重新构造字符串的Unicoe编码。</p>
<p>为了方便从ISO-8859-1编码转换到GBK编码，我们编写一个工具方法，如下：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> toGBK(<span class="keyword">String</span> <span class="built_in">str</span>) <span class="keyword">throws</span> java.io.UnsupportedEncodingException&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">String</span>(<span class="built_in">str</span>.getBytes(<span class="string">"ISO-8859-1"</span>), <span class="string">"GBK"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-总结">3.总结</h2><p>在实际的Web应用中，乱码问题产生的原因多种多样，然而只要我们理解了字符编码转换过程，仔细地分析乱码产生的原因，找到问题的关键，就能对症下药，解决问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong> 所有基于Java的应用程序都面临着一个让初学者非常头痛的问题-中文乱码。由于Java的内核和.class文件都是基于Unicode的，这使得Java程序具有良好的跨平台特性，但却容易造成中文乱码。另外，Web容器的默认编码方式是ISO-8859-1，所以在Java Web程序中用户在客户端输入以GBK方式编码的中文传输到服务器端，由Web容器以ISO-8859-1方式包装编码，并以该编码形式的html页面回送到本地客户端，这样都会造成中文乱码的问题，本文就Java Web中文乱码问题提出一些解决方案。]]>
    
    </summary>
    
      <category term="技术交流" scheme="http://blog.zbvae.com/tags/%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构-内排序算法]]></title>
    <link href="http://blog.zbvae.com/2015/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%86%85%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.zbvae.com/2015/07/28/数据结构-内排序算法/</id>
    <published>2015-07-28T01:10:43.000Z</published>
    <updated>2016-02-24T07:55:51.150Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong> 排序是数据结构中非常重要的内容，也是公司笔试面试经常会考的内容。掌握所有的排序并不是必须的，关键是知道在什么情况下，使用什么排序算法，效率更高，知道哪种排序算法是稳定的，以及该排序算法的时间复杂度。排序要求的数据结构一般都是静态数组的形式，如果单单去背诵某一排序算法的实现，你可能这段时间能够记住，但不能保证过段时间你还能记住，因此，要想彻底记住这些排序算法，必须从它的实现法则上去记忆。<a id="more"></a></p>
<h2 id="1-排序算法简介">1.排序算法简介</h2><p>本文主要讲述的是内排序算法，关乎外排序需要与外存交互，因此这里不做考虑。所有的内排序算法可以分为五类：选择排序，插入排序，交换排序，归并排序，基数排序。其中选择排序又可以分为简单选择排序，树形选择排序（锦标赛排序），堆排序（树形选择排序的一种），插入排序分为直接插入排序和希尔排序（缩小增量排序），交换排序分为冒泡排序，快速排序。下面是对所有内排序算法的时间复杂度，空间复杂度和稳定性的统计表格。</p>
<p>时间复杂度：执行该算法的基本语句的执行频度，通常指最坏情况下的时间复杂度。<br>空间复杂度：执行该算法所需要的额外辅助存储空间的大小。<br>稳定性：如果待排序列中有若干个相等的元素，排序结束之后，这些相等元素的先后顺序并没有随排序的执行而发生改变，就称该排序算法是稳定的。</p>
<table>
<thead>
<tr>
<th>排序算法</th>
<th style="text-align:center">时间复杂度</th>
<th style="text-align:center">空间复杂度</th>
<th style="text-align:center">稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>简单选择排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td style="text-align:center">$O(nlgn)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td>直接插入排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td style="text-align:center">$O(n^{1.4})$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td>冒泡排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td style="text-align:center">$O(nlgn)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td style="text-align:center">$O(nlgn)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">稳定</td>
</tr>
</tbody>
</table>
<p>对以上统计信息的总结：</p>
<blockquote>
<ul>
<li>时间复杂度<blockquote>
<ul>
<li>$O(n^2)$:简单选择排序、直接插入排序、冒泡排序</li>
<li>$O(nlgn)$:堆排序、快速排序、归并排序</li>
<li>$O(n^{1.4})$:希尔排序</li>
<li>$O(n)$:基数排序</li>
</ul>
</blockquote>
</li>
<li>空间复杂度<blockquote>
<ul>
<li>快速排序和归并排序都需要额外的$O(n)$的辅助栈空间用于递归。</li>
<li>基数排序用空间换时间。空间复杂度也为$O(n)$</li>
<li>其余排序算法都是就地排序，空间复杂度为$O(1)$</li>
</ul>
</blockquote>
</li>
<li>稳定性<blockquote>
<ul>
<li>直接插入排序、冒泡排序、归并排序、基数排序是稳定的。</li>
<li>其余排序算法不稳定。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="2-排序算法实现">2.排序算法实现</h2><h3 id="2-1简单选择排序">2.1简单选择排序</h3><p>思想：每次从剩下的无序区中选取最小的加入的有序区中，最后无序区只剩一个元素，直接加入即可，简单选择排序的实现关键在于无序区元素的比较。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> void selectSort(<span class="built_in">int</span>[] <span class="type">data</span>)&#123;</span><br><span class="line">	for(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;<span class="type">data</span>.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">		<span class="built_in">int</span> minIndex = i;</span><br><span class="line">		for(<span class="built_in">int</span> j=i+<span class="number">1</span>; j&lt;<span class="type">data</span>.length; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="type">data</span>[j] &lt; <span class="type">data</span>[minIndex])&#123;</span><br><span class="line">				minIndex = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(minIndex <span class="comment">!= i)&#123;</span></span><br><span class="line">			<span class="built_in">int</span> temp = <span class="type">data</span>[i];</span><br><span class="line">			<span class="type">data</span>[i] = <span class="type">data</span>[minIndex];</span><br><span class="line">			<span class="type">data</span>[minIndex] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2堆排序">2.2堆排序</h3><p>思想：堆排序是树形选择排序的一种，相对于简单选择排序，它可以充分利用上一次比较的结果，因而较快地完成排序。堆排序是利用完全二叉树顺序存储的特性完成。堆中，任何双亲结点的关键字均不大于或不小于其孩子节点的关键字。堆中任何一棵子树也是堆。以大根堆（堆中任何双亲结点的关键字都大于其孩子结点关键字）为例，介绍堆排序主要的两个步骤如下：</p>
<blockquote>
<ul>
<li>初始化堆</li>
<li>将当前无序区中的第一个元素与最后一个元素交换，使最后一个元素进入有序区。重新调整无序区，并再次将无序区中第一个元素加入有序区，直到无序区只包含一个元素。</li>
</ul>
</blockquote>
<p>堆排序的关键问题在于：如何初始化堆，如何调整堆。这两个问题都要从堆的性质出发去解决，假设，现在的堆满足堆性质，我们可以将第一个元素加入有序区，这样一来，无序区的最后一个元素被交换到了第一个位置，那么该元素极有可能破坏堆性质。我们从该元素出发，讨论如果该元素小于其孩子中的一个，那就证明它破坏了堆性质，需要将其与其拥有较大关键字的孩子进行交换。交换之后它的孩子也有可能破坏堆性质，因此如此递推下去，调整区间为整个无序区，直至该堆重新满足堆性质。每次需要调整的都只是按树的层级往下递推，而不需要像简单选择排序一样每次都从无序区所有元素选择最小的，比较的次数显然减少了。这种调整堆的方法称之为<strong>筛选法</strong>。</p>
<p>初始化堆的过程也可以理解为调整堆，按照完全二叉树的顺序存储，只有根节点才有可能不满足堆性质，需要进行调整，而完全二叉树中，结点编号在[0,n/2]的为根节点，因此只需要调整[0,n/2]的所有根节点即可，由于初始化堆，所有元素均为无序区，因此调整区间为整个数据序列。既然堆排序的两个关键步骤都依赖调整堆，那接下来先介绍调整堆的算法实现。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> void heapAdjust(<span class="built_in">int</span>[] <span class="type">data</span>, <span class="built_in">int</span> low, <span class="built_in">int</span> high)&#123;</span><br><span class="line">	for(<span class="built_in">int</span> j=<span class="number">2</span>*low; j&lt;=high; j*=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="built_in">int</span> temp = <span class="type">data</span>[low];</span><br><span class="line">		<span class="keyword">if</span>(j &lt; high &amp;&amp; <span class="type">data</span>[j] &lt; <span class="type">data</span>[j+<span class="number">1</span>])</span><br><span class="line">			j++;</span><br><span class="line">		<span class="keyword">if</span>(temp &gt; a[j])</span><br><span class="line">			break;</span><br><span class="line">		<span class="type">data</span>[low] = <span class="type">data</span>[j];</span><br><span class="line">		<span class="type">data</span>[j] = temp;</span><br><span class="line">		low = j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面给出初始化堆的算法实现：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> void initHeap(<span class="built_in">int</span>[] <span class="type">data</span>)&#123;</span><br><span class="line">	for(<span class="built_in">int</span> i=<span class="type">data</span>.length/<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">		heapAdjust(<span class="type">data</span>, i, <span class="type">data</span>.length-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了初始化堆和调整堆的算法实现，堆排序的算法实现如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> void heapSort(<span class="built_in">int</span>[] <span class="type">data</span>)&#123;</span><br><span class="line">		initHeap(<span class="type">data</span>);</span><br><span class="line"></span><br><span class="line">		for(<span class="built_in">int</span> i=<span class="type">data</span>.length-<span class="number">1</span>; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">			<span class="built_in">int</span> temp = <span class="type">data</span>[<span class="number">0</span>];</span><br><span class="line">			<span class="type">data</span>[<span class="number">0</span>] = <span class="type">data</span>[i];</span><br><span class="line">			<span class="type">data</span>[i] = temp;</span><br><span class="line"></span><br><span class="line">			heapAdjust(<span class="type">data</span>, <span class="number">0</span>, i-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3直接插入排序">2.3直接插入排序</h3><p>思想：直接插入排序非常类似于我们生活中的打扑克，在拿到下一张扑克牌的时候，我们需要将其插入到手中已排好序的所有扑克牌中的合适位置。开始时，有序区为第一个元素，无序区为待插入的其余元素。从第二个元素起开始插入，如果插入元素大于前一个元素（前一个元素为当前有序区最后一个元素），则无需调整，如果插入元素小于前一个元素，则顺序往前，并将比插入元素大的元素往后移动直到找到比插入元素小的元素位置，此即为插入位置。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> void insertSort(<span class="built_in">int</span>[] <span class="type">data</span>)&#123;</span><br><span class="line">	for(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;<span class="type">data</span>.length; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="type">data</span>[i] &lt; <span class="type">data</span>[i-<span class="number">1</span>])&#123;</span><br><span class="line">			<span class="built_in">int</span> temp = <span class="type">data</span>[i];</span><br><span class="line">			<span class="built_in">int</span> j = i-<span class="number">1</span>;</span><br><span class="line">			for(; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">				<span class="keyword">if</span>(temp &lt; <span class="type">data</span>[j])&#123;</span><br><span class="line">					<span class="type">data</span>[j+<span class="number">1</span>] = <span class="type">data</span>[j];</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">data</span>[j+<span class="number">1</span>] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4希尔排序">2.4希尔排序</h3><p>思想：希尔排序是一种缩小增量插入排序，每次不是比较一位，而是跨越一个增量进行插入，先将待排数据区以增量d划分为d个小组，距离为d的倍数的记录在一个组，如1,2,3,4,5,6,7,8,9,10，这10个元素，选择增量d=5进行划分，则可以分为(1,6),(2,7),(3,8),(4,9),(5,10)这5个组，对每一个增量进行组内排序，然后依次选定较小的增量，划分为较小的组，借助上一次的排序结果，已经近似有序了，所以这次排序相对较快，最后的增量一定是1，而且这个时候，记录序列已基本有序。</p>
<p>希尔排序为什么比直接插入排序快，其原因在于：</p>
<blockquote>
<ul>
<li>单文件近似有序时，直接插入排序移动和比较的次数都较少。</li>
<li>希尔排序开始增量较大，分组较多，每组的记录数目少，所以各个小组内完成直接插入较快，后来随着增量逐渐减少，组内元素变多，但是借助上一次增量的排序结果，此时组内元素已基本有序，因此新的增量排序也较快。</li>
</ul>
</blockquote>
<p>下面先介绍给定一个增量的一趟排序算法实现</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> shellInsert(<span class="built_in">int</span>[] <span class="type">data</span>, <span class="built_in">int</span> d)&#123;</span><br><span class="line">	for(<span class="built_in">int</span> i=d+<span class="number">1</span>; i&lt;<span class="type">data</span>.length; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="type">data</span>[i] &lt; <span class="type">data</span>[i-d])&#123;</span><br><span class="line">			<span class="built_in">int</span> temp = <span class="type">data</span>[i];</span><br><span class="line">			<span class="built_in">int</span> j= i-d;</span><br><span class="line">			for(; j&gt;=<span class="number">0</span>; j-=d)&#123;</span><br><span class="line">				<span class="keyword">if</span>(temp &lt; <span class="type">data</span>[j])&#123;</span><br><span class="line">					<span class="type">data</span>[j+d] = <span class="type">data</span>[j];</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">data</span>[j+d] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上代码也可以发现，每一个组内都是直接插入排序，但是由于组内元素距离是d的倍数，因此，每次直接插入的步长不再是1,而是d.</p>
<p>希尔排序性能的好坏关键在于增量序列的选取：</p>
<blockquote>
<ul>
<li>最后一个增量必须为1</li>
<li>应该尽量避免增量序列中的值(尤其是相邻的值)互为倍数的情况。</li>
</ul>
</blockquote>
<p>对于增量序列increment，希尔排序实现如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span>[] increment)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;increment.length; i++)&#123;</span><br><span class="line">		shellInsert(data, increment[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5冒泡排序">2.5冒泡排序</h3><p>思想：冒泡排序是最简单也是最直接的排序算法，冒泡排序属于交换类排序，排序过程中需要频繁交换关键字。一趟冒泡排序之后，会选出最大关键字到最后位置，类似冒出最大气泡，每趟排序过程中，都需要进行关键字的两两比对，并可能交换，直至交换出最大关键字。外循环为排序趟数,至多为n-1次。每趟排序过程即内循环，需要从剩下的无序气泡中不断交换出最大者。冒泡排序实现如下.</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">public</span> void <span class="keyword">bubbleSort(int[] </span><span class="preprocessor">data</span>)&#123;</span><br><span class="line">	<span class="keyword">boolean </span>flag = false<span class="comment">;</span></span><br><span class="line">	for(int i<span class="number">=0</span><span class="comment">; i&lt;data.length-1; i++)&#123;</span></span><br><span class="line">		flag = false<span class="comment">; </span></span><br><span class="line">		for(int j<span class="number">=0</span><span class="comment">; j&lt;data.length-i-1; j++)&#123;</span></span><br><span class="line">			<span class="preprocessor">if</span>(<span class="preprocessor">data</span>[j+<span class="number">1</span>] &lt; <span class="preprocessor">data</span>[j])&#123;</span><br><span class="line">				<span class="preprocessor">data</span>[j+<span class="number">1</span>] ^= <span class="preprocessor">data</span>[j]<span class="comment">;</span></span><br><span class="line">				<span class="preprocessor">data</span>[j] ^= <span class="preprocessor">data</span>[j+<span class="number">1</span>]<span class="comment">;</span></span><br><span class="line">				<span class="preprocessor">data</span>[j+<span class="number">1</span>] ^= <span class="preprocessor">data</span>[j]<span class="comment">;</span></span><br><span class="line">				flag = true<span class="comment">;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="preprocessor">if</span>(flag == false)</span><br><span class="line">			<span class="keyword">break;</span><br><span class="line"></span>	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码是属于优化的冒泡排序算法，设置一个标志变量，如果前一趟排序过程中，没有元素发生位置交换，说明所有未知区的元素已有序，因此退出冒泡排序过程。</p>
<h3 id="2-6快速排序">2.6快速排序</h3><p>思想：快速排序平均性能与最坏性能相同，因此比较常用。快速排序算法的关键在于每一次排序过程的划分，找到基准位置，并通过基准位置一分为二，递归实现快排，实际上是一种分治策略。基准元素的选取也会影响快排效率，不失一般性，我们通常选取第一个位置元素作为基准元素，参与快排。每次划分过程中，先从后往前遍历，直到找到比基准元素小的元素，将其放置到基准元素位置，然后再从前往后直到找到比基准元素大的元素，将其放到上一次放置的基准元素位置。直到前后指针碰到，该指针位置就是基准位置，将基准元素放置到该位置并返回该基准位置。下面是划分实现。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> partition(<span class="built_in">int</span>[] <span class="type">data</span>, <span class="built_in">int</span> low, <span class="built_in">int</span> high)&#123;</span><br><span class="line">	<span class="built_in">int</span> i=low,j=high;</span><br><span class="line">	<span class="built_in">int</span> pivot = <span class="type">data</span>[low];</span><br><span class="line">	<span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;j &amp;&amp; <span class="type">data</span>[j] &gt; temp)</span><br><span class="line">			j--;</span><br><span class="line">		<span class="type">data</span>[i] = <span class="type">data</span>[j];</span><br><span class="line">		<span class="keyword">while</span>(i&lt;j &amp;&amp; <span class="type">data</span>[i] &lt; pivot)</span><br><span class="line">			i++;</span><br><span class="line">		<span class="type">data</span>[j] = <span class="type">data</span>[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">data</span>[i] = pivot;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快排的递归实现：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> void quickSort(<span class="built_in">int</span>[] <span class="type">data</span>, <span class="built_in">int</span> low, <span class="built_in">int</span> high)&#123;</span><br><span class="line">	<span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">		<span class="built_in">int</span> pivotPos = partition(<span class="type">data</span>, low, high);</span><br><span class="line">		quickSort(<span class="type">data</span>, low, pivotPos-<span class="number">1</span>);</span><br><span class="line">		quickSort(<span class="type">data</span>, pivotPos+<span class="number">1</span>, high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-7归并排序">2.7归并排序</h3><p>思想：和快排类似，归并排序也是一种递归分治策略，区分于快排，归并排序关键在于两个以中间位置划分的有序序列的合并。二路归并排序，最终子序列中只有一个元素一定是有序的，将其合并，然后一层层地递归进行。合并算法实现如下：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="type">void</span> merge(<span class="type">int</span>[] data, <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)&#123;</span><br><span class="line">	<span class="type">int</span> i = low;</span><br><span class="line">	<span class="type">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> k= <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="literal">result</span>[] = new <span class="type">int</span>[high-low+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= high)</span><br><span class="line">		<span class="literal">result</span>[k++] = data[i] &lt; data[j] ? data[i++] : data[j++];</span><br><span class="line">	<span class="keyword">while</span>(i &lt;= mid)</span><br><span class="line">		<span class="literal">result</span>[k++] = data[i++];</span><br><span class="line">	<span class="keyword">while</span>(j &lt;= high)</span><br><span class="line">		<span class="literal">result</span>[k++] = data[j++];</span><br><span class="line">	<span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;<span class="literal">result</span>.length; k++)&#123;</span><br><span class="line">		data[low++] = <span class="literal">result</span>[k];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二路归并策略，以中间位置，将待排序列一分为二，进行递归计算</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> void mergeSort(<span class="built_in">int</span>[] <span class="type">data</span>, <span class="built_in">int</span> low, <span class="built_in">int</span> high)&#123;</span><br><span class="line">	<span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">		<span class="built_in">int</span> mid = (low+high) / <span class="number">2</span>;</span><br><span class="line">		mergeSort(<span class="type">data</span>, low, mid);</span><br><span class="line">		mergeSort(<span class="type">data</span>, mid+<span class="number">1</span>, high);</span><br><span class="line">		<span class="built_in">merge</span>(<span class="type">data</span>, low, mid, high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-8基数排序">2.8基数排序</h3><p>思想：基数排序属于一种空间换时间的策略，要了解基数排序，最好先了解桶排序思想。</p>
<p>桶排序：将数据序列分到有限数量的桶子里。每个桶子再分别排序，桶子内部的排序算法可采用上述基本排序算法中的任意一种，排序完成之后，依次输出每个桶子里的数字，且每个桶子的数字从小到大输出，这样就得到数字排好序的序列了。</p>
<p>假设有n个关键字，有m个桶，如果数字是平均分布的，则每个桶子平均有n/m个数字，如果对每个桶采用快速排序，那么整个算法的时间复杂度是：</p>
<p>$$O(n+m*n/m*lg(n/m)) = O(n+nlgn-nlgm)$$</p>
<p>从上式可以看出，当m接近n时，，桶排序复杂度接近$O(n)$。</p>
<p>基数排序：按照低位先排序，然后搜集；再按照高位排序，然后搜集；依次类推，直到最高位。基数排序是分别排序，分别搜集，所以是稳定的。具体实现，请读者自行查阅。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong> 排序是数据结构中非常重要的内容，也是公司笔试面试经常会考的内容。掌握所有的排序并不是必须的，关键是知道在什么情况下，使用什么排序算法，效率更高，知道哪种排序算法是稳定的，以及该排序算法的时间复杂度。排序要求的数据结构一般都是静态数组的形式，如果单单去背诵某一排序算法的实现，你可能这段时间能够记住，但不能保证过段时间你还能记住，因此，要想彻底记住这些排序算法，必须从它的实现法则上去记忆。]]>
    
    </summary>
    
      <category term="数据结构" scheme="http://blog.zbvae.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构-图]]></title>
    <link href="http://blog.zbvae.com/2015/07/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
    <id>http://blog.zbvae.com/2015/07/26/数据结构-图/</id>
    <published>2015-07-26T07:22:29.000Z</published>
    <updated>2015-08-06T12:17:27.847Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong> 图与树一样都属于非线性结构，又有点类似于广义表。图中各结点之间都可能具有逻辑关系，结点之间的关系是任意的，因此它是一种比线性表和树更为复杂的数据结构。图在科研和生活中有着非常广泛的应用，如生活中的最短路径问题，以及搜索引擎中深度和广度搜索问题。本文主要介绍图的存储结构定义，以及使用邻接矩阵表示的图的最短路径问题。<a id="more"></a></p>
<h2 id="1-图的相关术语">1.图的相关术语</h2><ul>
<li>图：由有穷、非空点集合和边的集合组成，简称G(V,E)</li>
<li>有向图与无向图：图中的边用弧表示，用弧连接的两个顶点有弧头和弧尾之分，这种图为有向图，连接顶点的边没有方向之分，该图称为无向图。</li>
<li>有向完全图与无向完全图：有向图每两个顶点之间都有两条反向的弧相连表示两顶点互通，弧的数目为n(n-1)，改图为有向完全图；无向图中每两个顶点之间都有一条边相连，表示两顶点连通，边的数目为n(n-1)/2，该图为无向完全图。</li>
<li>稠密图与稀疏图：图中边的数目很多的图为稠密图；图中边的数目相对顶点较少的图为稀疏图。</li>
<li>出度与入度：对于有向图，出度表示，以该顶点为弧尾的并与该顶点相连的弧的数目；入度表示，以该顶点为弧头的并与该顶点相连的弧的数目。</li>
<li>环与简单路径：图中有一条路径，其中第一个顶点与最后一个顶点相同，该路径为环；路径序列中不存在重复顶点的称为简单路径。</li>
<li>连通图与强连通图：无向图中任意两个顶点都有路径相通，则称该图是连通的;有向图中任意两个顶点之间都有路径相通，则称该有向图为强连通图。</li>
<li>连通分量与强连通分量：分别针对无向图与有向图而言，无向图中的极大连通子图为连通分量；有向图中的极大强连通子图为强连通分量。</li>
<li>生成树：一个连通图的生成树是一个极小连通子图，它包含图中全部顶点，但只有n-1条边。<br>网：带权的图。</li>
</ul>
<h2 id="2-图的存储结构">2.图的存储结构</h2><p>下面这幅图是本文介绍图的存储及最短路径所使用的图，实际上它是有向网。</p>
<center><img src="/images/graph.png" alt="graph"></center>

<h3 id="2-1邻接矩阵">2.1邻接矩阵</h3><p>邻接矩阵是一个二维数组，对于无向图是对称矩阵，矩阵中用0表示i,j两点之间没有边，1表示i,j两点之间有边。以上面的有向网为例，则邻接矩阵中，存储的不再是0或1而是两点边的权值，如果没有边则赋值为无穷大。</p>
<p>除了二维数组保存边的权值外，图中还需要维护一个整型变量保存顶点个数，以及Vertex类型的数组，Vertex类型保存顶点信息，主要是顶点编号以及顶点名称。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeqGraph</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INFINITY = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Vertex</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> vIndex;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">char</span> data;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Vertex</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Vertex</span><span class="params">(<span class="keyword">int</span> vIndex, <span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.vIndex = vIndex;</span><br><span class="line">			<span class="keyword">this</span>.data = data;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> vexNum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> Vertex vex[] = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> adj[][] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SeqGraph</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SeqGraph</span><span class="params">(<span class="keyword">int</span> vexNum)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.vexNum = vexNum;</span><br><span class="line">		<span class="keyword">this</span>.vex = <span class="keyword">new</span> Vertex[vexNum];</span><br><span class="line">		<span class="keyword">this</span>.adj = <span class="keyword">new</span> <span class="keyword">int</span>[vexNum][vexNum];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>构造邻接矩阵，分为初始化邻接矩阵和静态构造两步，这里也可以手动输入边相连的顶点编号以及权值，来建立邻接矩阵。静态构造的示例如下：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">public</span> <span class="atom">void</span> <span class="atom">initAdj</span>()&#123;</span><br><span class="line">	<span class="atom">for</span>(<span class="atom">int</span> <span class="atom">i</span>=<span class="number">0</span>; <span class="atom">i</span>&lt;<span class="atom">vexNum</span>; <span class="atom">i</span>++)&#123;</span><br><span class="line">		<span class="atom">for</span>(<span class="atom">int</span> <span class="atom">j</span>=<span class="number">0</span>; <span class="atom">j</span>&lt;<span class="atom">vexNum</span>; <span class="atom">j</span>++)&#123;</span><br><span class="line">			<span class="atom">adj</span>[<span class="atom">i</span>][<span class="atom">j</span>] = <span class="name">INFINITY</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="atom">public</span> <span class="atom">void</span> <span class="atom">staticCreate</span>()&#123;</span><br><span class="line">	<span class="atom">for</span>(<span class="atom">int</span> <span class="atom">i</span>=<span class="number">0</span>; <span class="atom">i</span>&lt;<span class="atom">vexNum</span>; <span class="atom">i</span>++)&#123;</span><br><span class="line">		<span class="atom">vex</span>[<span class="atom">i</span>] = <span class="atom">new</span> <span class="name">Vertex</span>(<span class="atom">i</span>, (<span class="atom">char</span>)(<span class="string">'A'</span>+<span class="atom">i</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="atom">adj</span>[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line">	<span class="atom">adj</span>[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">7</span>;</span><br><span class="line">	<span class="atom">adj</span>[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">4</span>;</span><br><span class="line">	<span class="atom">adj</span>[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">8</span>;</span><br><span class="line">	<span class="atom">adj</span>[<span class="number">2</span>][<span class="number">5</span>] = <span class="number">9</span>;</span><br><span class="line">	<span class="atom">adj</span>[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">	<span class="atom">adj</span>[<span class="number">3</span>][<span class="number">5</span>] = <span class="number">6</span>;</span><br><span class="line">	<span class="atom">adj</span>[<span class="number">4</span>][<span class="number">3</span>] = <span class="number">5</span>;</span><br><span class="line">	<span class="atom">adj</span>[<span class="number">5</span>][<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">	<span class="atom">adj</span>[<span class="number">5</span>][<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在构造函数里面依次调用上述两个函数，这里静态构造的邻接矩阵是根据上面的有向网的形态构造的，试着输出看一下,其中，对于无穷大的数据，我们输出0来表示。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printGraph</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vexNum; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;vexNum; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(adj[i][j] == INFINITY)&#123;</span><br><span class="line">				System.<span class="keyword">out</span>.print(<span class="number">0</span>+<span class="string">" "</span>);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				System.<span class="keyword">out</span>.print(adj[i][j]+<span class="string">" "</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.<span class="keyword">out</span>.println();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>0 5 0 7 0 0<br>0 0 4 0 0 0<br>8 0 0 0 0 9<br>0 0 5 0 0 6<br>0 0 0 5 0 0<br>3 0 0 0 1 0 </p>
</blockquote>
<h3 id="2-2邻接表">2.2邻接表</h3><p>邻接表，相当于链表，我们为每一个顶点维护一个单链表，保存以该顶点为出度的弧相连所有其它顶点。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">LinkGraph</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">class</span> <span class="title">Vertex</span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> vIndex;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">char</span> data;</span><br><span class="line">		<span class="keyword">private</span> Vertex next;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Vertex</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Vertex</span>(<span class="params"><span class="keyword">int</span> vIndex, <span class="keyword">char</span> data, Vertex next</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.vIndex = vIndex;</span><br><span class="line">			<span class="keyword">this</span>.data = data;</span><br><span class="line">			<span class="keyword">this</span>.next = next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> vexNum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> Vertex vex[] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LinkGraph</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LinkGraph</span>(<span class="params"><span class="keyword">int</span> vexNum</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.vexNum = vexNum;</span><br><span class="line">		<span class="keyword">this</span>.vex = <span class="keyword">new</span> Vertex[vexNum];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的顶点类型与以上邻接矩阵稍有区别的是，每一个顶点都包含下一个出度顶点的信息。以手动输入来动态创建邻接表，如下所示：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> create()&#123;</span><br><span class="line">	Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">	System.out.<span class="keyword">println</span>(<span class="string">"please input the every arc of graph with \"tIndex hIndex\""</span>);</span><br><span class="line">	System.out.<span class="keyword">println</span>(<span class="string">"input 0 0 for end!"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (((i = sc.nextInt()) != <span class="number">0</span>) &amp;&amp; ((j = sc.nextInt()) != <span class="number">0</span>))&#123;</span><br><span class="line">		<span class="keyword">int</span> tIndex = i-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> hIndex = j-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		Vertex hVertex = <span class="keyword">new</span> Vertex(hIndex, (<span class="keyword">char</span>)(<span class="string">'A'</span>+hIndex), <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(vex[tIndex] == <span class="keyword">null</span>)&#123;</span><br><span class="line">			vex[tIndex] = <span class="keyword">new</span> Vertex(tIndex, (<span class="keyword">char</span>)(<span class="string">'A'</span>+tIndex), hVertex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			Vertex pVertex = vex[tIndex];</span><br><span class="line">			<span class="keyword">while</span>((pVertex.<span class="keyword">next</span> != <span class="keyword">null</span>) &amp;&amp; (pVertex.<span class="keyword">next</span>.vIndex &lt; hVertex.vIndex))&#123;</span><br><span class="line">				pVertex = pVertex.<span class="keyword">next</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			hVertex.<span class="keyword">next</span> = pVertex.<span class="keyword">next</span>;</span><br><span class="line">			pVertex.<span class="keyword">next</span> = hVertex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依次输入如下信息：</p>
<p>1 2<br>1 4<br>2 3<br>3 1<br>3 6<br>4 3<br>5 4<br>6 5<br>6 1<br>0 0</p>
<p>用如下函数输出邻接表表示的图的信息：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> printGraph()&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;vexNum; i++)&#123;</span><br><span class="line">		Vertex <span class="built_in">vertex</span> = vex[i];</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">vertex</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">			System.out.<span class="built_in">print</span>(<span class="built_in">vertex</span>.data + <span class="string">"---&gt;"</span>);</span><br><span class="line">			<span class="built_in">vertex</span> = <span class="built_in">vertex</span>.next;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.<span class="built_in">println</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出信息如下图所示:</p>
<center><img src="/images/linkgraph.png" alt="linkgraph"></center>

<h3 id="2-3十字链表">2.3十字链表</h3><p>邻接表只包含了出度信息，为了寻找入度信息，必须遍历整个表，耗费的时间是相当可观的。为了解决寻找入度信息困难的问题，我们可以额外建立一个逆连接表。而十字链表则可以看成是邻接表和逆邻接表的结合体。顶点信息中除了保存下一个出度信息外，还要保存下一个入度信息。十字链表的结构定义如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CrossGraph</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">class</span> <span class="title">Vertex</span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> vIndex;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">char</span> data;</span><br><span class="line">		<span class="keyword">private</span> Vertex nextOut;</span><br><span class="line">		<span class="keyword">private</span> Vertex nextIn;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Vertex</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Vertex</span>(<span class="params"><span class="keyword">int</span> vIndex, <span class="keyword">char</span> data, Vertex nextOut, Vertex nextIn</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.vIndex = vIndex;</span><br><span class="line">			<span class="keyword">this</span>.data = data;</span><br><span class="line">			<span class="keyword">this</span>.nextOut = nextOut;</span><br><span class="line">			<span class="keyword">this</span>.nextIn = nextIn;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> vexNum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> Vertex inVex[] = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> Vertex outVex[] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CrossGraph</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CrossGraph</span>(<span class="params"><span class="keyword">int</span> vexNum</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.vexNum = vexNum;</span><br><span class="line">		<span class="keyword">this</span>.inVex = <span class="keyword">new</span> Vertex[vexNum];</span><br><span class="line">		<span class="keyword">this</span>.outVex = <span class="keyword">new</span> Vertex[vexNum];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与邻接表类似，通过手动输入方式建立十字链表的函数如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	Scanner sc = <span class="keyword">new</span> Scanner(System.<span class="keyword">in</span>);</span><br><span class="line">	System.<span class="keyword">out</span>.println(<span class="string">"please input the every arc of graph with \"tIndex hIndex\""</span>);</span><br><span class="line">	System.<span class="keyword">out</span>.println(<span class="string">"input 0 0 for end!"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (((i = sc.nextInt()) != <span class="number">0</span>) &amp;&amp; ((j = sc.nextInt()) != <span class="number">0</span>))&#123;</span><br><span class="line">		<span class="keyword">int</span> tIndex = i-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> hIndex = j-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		Vertex hVertex = <span class="keyword">new</span> Vertex(hIndex, (<span class="keyword">char</span>)(hIndex+<span class="string">'A'</span>), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">		Vertex tVertex = <span class="keyword">new</span> Vertex(tIndex, (<span class="keyword">char</span>)(tIndex+<span class="string">'A'</span>), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">		hVertex.nextIn = tVertex;</span><br><span class="line">		tVertex.nextOut = hVertex;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.outVex[tIndex] == <span class="keyword">null</span>)&#123;</span><br><span class="line">			outVex[tIndex] = tVertex;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			Vertex pVertex = outVex[tIndex];</span><br><span class="line">			<span class="keyword">while</span>((pVertex.nextOut != <span class="keyword">null</span>) &amp;&amp; (pVertex.nextOut.vIndex &lt; hVertex.vIndex))&#123;</span><br><span class="line">				pVertex = pVertex.nextOut;</span><br><span class="line">			&#125;</span><br><span class="line">			hVertex.nextOut = pVertex.nextOut;</span><br><span class="line">			pVertex.nextOut = hVertex;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.inVex[hIndex] == <span class="keyword">null</span>)&#123;</span><br><span class="line">			inVex[hIndex] = hVertex;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			Vertex pVertex = inVex[hIndex];</span><br><span class="line">			<span class="keyword">while</span>((pVertex.nextIn != <span class="keyword">null</span>) &amp;&amp; (pVertex.nextIn.vIndex &lt; tVertex.vIndex))&#123;</span><br><span class="line">				pVertex = pVertex.nextIn;</span><br><span class="line">			&#125;</span><br><span class="line">			tVertex.nextIn = pVertex.nextIn;</span><br><span class="line">			pVertex.nextIn = tVertex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入与建立邻接表时一样的数据，输出十字链表的数据如下图所示：</p>
<center><img src="/images/crossgraph.png" alt="crossgraph"></center>

<p>显然邻接表和十字链表都是有利于有向图的存储结构，与十字链表对应的无向图的存储结构为邻接多重表，这里就不再介绍了。</p>
<h2 id="3-图的遍历">3.图的遍历</h2><p>图的遍历分为深度优先遍历和广度优先遍历。深度优先遍历类似于树的先序遍历，而广度优先遍历则类似于树的层序遍历。</p>
<p>深度优先遍历：选择图中某个顶点，依次遍历该顶点的第一个邻接点，然后再依次遍历该邻接点的第一个邻接点，直到图中所有顶点都遍历完为止。</p>
<p>广度优先遍历：选择图中某个顶点，依次遍历该顶点的所有邻接顶点，并保证<strong>先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问</strong>，直到图中所有顶点遍历完毕。</p>
<p>为了在遍历过程中区分顶点是否已被访问，需要设置一个访问标志数组visited[]，大小为顶点数目，初始化为所有顶点都未被访问，下面以邻接矩阵表示的有向网的结构，分别以深度优先遍历和广度优先遍历方式访问该图。</p>
<p>显然深度遍历图是一个递归的过程，我们先用递归实现，后用栈来模拟实现递归深度遍历。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span>(<span class="params"><span class="keyword">int</span> i</span>)</span>&#123;</span><br><span class="line">	visited[i] = <span class="keyword">true</span>;</span><br><span class="line">	System.<span class="keyword">out</span>.print(vex[i].data+<span class="string">"---&gt;"</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;vexNum; j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!visited[j] &amp;&amp; adj[i][j] != INFINITY)&#123;</span><br><span class="line">			DFS(j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFSTraverse</span>(<span class="params"><span class="keyword">int</span> i</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.initVisit();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vexNum; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">			DFS(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面用栈来模拟递归实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonRecDFSTraverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.initVisit();</span><br><span class="line">	Stack&lt;Integer&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>, j;</span><br><span class="line">	<span class="keyword">while</span>(!visited[i] || <span class="built_in">stack</span>.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>(!visited[i])&#123;</span><br><span class="line">			visited[i] = <span class="keyword">true</span>;</span><br><span class="line">			System.out.print(vex[i].data+<span class="string">"---&gt;"</span>);</span><br><span class="line">			<span class="built_in">stack</span>.push(i);</span><br><span class="line">			j = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(j &lt; vexNum)&#123;</span><br><span class="line">				<span class="keyword">if</span>(adj[i][j] != INFINITY &amp;&amp; !visited[j])&#123;</span><br><span class="line">					i = j;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">stack</span>.size() &gt;<span class="number">0</span>)&#123;</span><br><span class="line">			i = <span class="built_in">stack</span>.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>广度优先遍历，由于要保证先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，因此队列是很好的结构。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void BFSTraverse<span class="params">()</span>&#123;</span><br><span class="line">	this.initVisit<span class="params">()</span>;</span><br><span class="line">	LinkedList&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;<span class="params">()</span>;</span><br><span class="line">	<span class="keyword">for</span> <span class="params">(int i=<span class="number">0</span>; i&lt;vexNum; i++)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span><span class="params">(!visited[i])</span>&#123;</span><br><span class="line">			visited[i] = <span class="literal">true</span>;</span><br><span class="line">			System.out.print<span class="params">(vex[i].data+<span class="string">"---&gt;"</span>)</span>;</span><br><span class="line">			queue.add<span class="params">(i)</span>;</span><br><span class="line">			while<span class="params">(queue.size<span class="params">()</span> &gt; <span class="number">0</span>)</span>&#123;</span><br><span class="line">				i = queue.poll<span class="params">()</span>;</span><br><span class="line">				<span class="keyword">for</span><span class="params">(int j=<span class="number">0</span>; j&lt;vexNum; j++)</span> &#123;</span><br><span class="line">					<span class="keyword">if</span><span class="params">(adj[i][j] != INFINITY &amp;&amp; !visited[j])</span>&#123;</span><br><span class="line">						visited[j] = <span class="literal">true</span>;</span><br><span class="line">						System.out.print<span class="params">(vex[j].data+<span class="string">"---&gt;"</span>)</span>;</span><br><span class="line">						queue.add<span class="params">(j)</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-最短路径问题">4.最短路径问题</h2><p>以有向网为例，来讨论最短路径问题，其中分为单源最短路径和所有顶点对之间的最短路径问题，其中Dijkstra算法和Floyd算法是最为典型的代表。</p>
<p>Dijkstra算法目的是为解决单源最短路径，即求图中某一顶点到图中其它顶点间的最短路径，Dijkstra算法利用贪心策略，求解最短路径，其中每次求解，都是求当前路径最短的顶点，然后利用该顶点去更新其它顶点最短路径，因此属于最短路径长度递增的顺序，求得所有顶点最短路径。</p>
<p>参数说明：Dijkstra算法需要维护一个已求得最短路径的顶点集合以及到每个顶点的最短路径的长度数组。每求得一个顶点的最短路径，就将该顶点加入已求得最短路径的顶点集合。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span>[] dijkstraShortestPath(<span class="built_in">int</span> v0)&#123;</span><br><span class="line">	<span class="built_in">boolean</span> s[] = <span class="keyword">new</span> <span class="built_in">boolean</span>[vexNum];</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">dist</span>[] = <span class="keyword">new</span> <span class="built_in">int</span>[vexNum];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;vexNum; i++)&#123;</span><br><span class="line">		s[i] = <span class="keyword">false</span>;</span><br><span class="line">		<span class="built_in">dist</span>[i] = adj[v0][i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s[v0] = <span class="keyword">true</span>;</span><br><span class="line">	<span class="built_in">dist</span>[v0] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">1</span>; j&lt;vexNum; j++)&#123;</span><br><span class="line">		<span class="built_in">int</span> u = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">int</span> minDist = INFINITY;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> k=<span class="number">0</span>; k&lt;vexNum; k++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[k] == <span class="keyword">false</span> &amp;&amp; (<span class="built_in">dist</span>[k] &lt; minDist))&#123;</span><br><span class="line">				u = k;</span><br><span class="line">				minDist = <span class="built_in">dist</span>[k];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		s[u] = <span class="keyword">true</span>;</span><br><span class="line">		<span class="built_in">dist</span>[u] = minDist;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> w=<span class="number">0</span>; w&lt;vexNum; w++)&#123;</span><br><span class="line">			<span class="built_in">int</span> midDist = (adj[u][w] == INFINITY ? INFINITY : <span class="built_in">dist</span>[u]+adj[u][w]);</span><br><span class="line">			<span class="keyword">if</span>(s[w] == <span class="keyword">false</span> &amp;&amp; <span class="built_in">dist</span>[w] &gt; midDist)&#123;</span><br><span class="line">				<span class="built_in">dist</span>[w] = midDist;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">dist</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Floyd算法解决图中所有顶点对之间的最短路径，其求解策略属于动态规划的范畴，即当前状态下，D(i,j,k)为结点vi到vj的以结点vk为中间结点的最短路径长度。那么</p>
<ul>
<li>若最短路径经过结点vk,则D(i,j,k)=D(i,j,k-1)+D(k,j,k-1);</li>
<li>若最短路径不经过结点vk,则D(i,j,k) = D(i,j,k-1).</li>
</ul>
<p>所以求vi到vj的最短路径可以表示为</p>
<p>$$D(i,j,k)=min(D(i,k,k-1)+D(k,j,k-1),D(i,j,k-1))$$</p>
<p>Floyd算法为求得所有顶点之间的最短路径，需要经过N次更新，N为顶点数目。Floyd算法实现需要设置二维数组，保存每对顶点之间的最短路径长度，初始化即为邻接矩阵，下面是Floyd算法的实现代码。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span>[][] floydShortestPath()&#123;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">dist</span>[][] = <span class="keyword">new</span> <span class="built_in">int</span>[vexNum][vexNum];</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;vexNum; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>; j&lt;vexNum; j++)&#123;</span><br><span class="line">			<span class="built_in">dist</span>[i][j] = adj[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> k=<span class="number">0</span>; k&lt;vexNum; k++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;vexNum; i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>; j&lt;vexNum; j++)&#123;</span><br><span class="line">				<span class="built_in">int</span> midDist = ((<span class="built_in">dist</span>[i][k] == INFINITY || <span class="built_in">dist</span>[k][j] == INFINITY) ? INFINITY : (<span class="built_in">dist</span>[i][k] + <span class="built_in">dist</span>[k][j]));</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">dist</span>[i][j] &gt; midDist)&#123;</span><br><span class="line">					<span class="built_in">dist</span>[i][j] = midDist;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">dist</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Floyd算法的时间复杂度为O(n^3)，Dijkstra算法主要是求单源最短路径，也可以对Dijkstra循环调用N次已求得所有顶点对之间的最短路径，因此，二者求出所有顶点的最短路径的时间复杂度都为O(n^3)。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong> 图与树一样都属于非线性结构，又有点类似于广义表。图中各结点之间都可能具有逻辑关系，结点之间的关系是任意的，因此它是一种比线性表和树更为复杂的数据结构。图在科研和生活中有着非常广泛的应用，如生活中的最短路径问题，以及搜索引擎中深度和广度搜索问题。本文主要介绍图的存储结构定义，以及使用邻接矩阵表示的图的最短路径问题。]]>
    
    </summary>
    
      <category term="数据结构" scheme="http://blog.zbvae.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构-二叉树]]></title>
    <link href="http://blog.zbvae.com/2015/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://blog.zbvae.com/2015/07/23/数据结构-二叉树/</id>
    <published>2015-07-23T03:15:09.000Z</published>
    <updated>2015-08-06T12:46:51.757Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong> 树是数据结构中非常重要的内容，是典型的非线性结构，并具有明显层次关系，非常类似于自然界的树。二叉树又是树形结构的代表，许多实际问题抽象出来的数据结构往往都是二叉树的形式，即使是一般的树也能转换为二叉树，而且二叉树的存储结构和算法都较为简单，因此二叉树显得尤为重要，本章为大家讲述二叉树的存储结构，创建，遍历等操作，以及线索二叉树的创建和最优二叉树赫夫曼树的定义和构造，另外还包含赫夫曼编码的输出等内容。<a id="more"></a></p>
<h2 id="1-树的定义与相关术语">1.树的定义与相关术语</h2><h3 id="1-1树的定义">1.1树的定义</h3><p>树的递归定义如下：</p>
<blockquote>
<p>树是n(n&gt;=0)个结点的有限集T，T为空时称之为空树，否则，它满足以下两个条件：</p>
<blockquote>
<ul>
<li>有且仅有一个特定的称之为根的结点；</li>
<li>其余的结点可分为m(m&gt;=0)个互不相交的子集T1，T2，…Tm，其中每个子集本身又是一棵树，并称其为根的子树。</li>
</ul>
</blockquote>
</blockquote>
<h3 id="1-2树的相关术语">1.2树的相关术语</h3><ul>
<li>结点的度：树中一个结点拥有的子树的数目，称之为该结点的度。</li>
<li>树的度：树中结点的最大度数。</li>
<li>双亲和孩子：树中某个结点的子树的根称之为该结点的孩子，相应地，该结点称为孩子的双亲。</li>
<li>祖先和子孙：若树中存在一个结点序列k1,k2,k3,…,kj,使得ki是ki+1(1&lt;=i&lt;=j)的双亲，则称该结点序列时从k1到kj的一条路径或通路。路径的长度是指路径经过的边的数目。若树中结点ki到kj存在一条路径，则称ki是kj的祖先，kj是ki的子孙，一个结点的祖先是从根节点到该条路径上所经过的所有结点，而一个结点的子孙则是以该结点为根的子树中的所有结点。</li>
<li>结点的层数：结点的层数从根起算，根的层数为1，其余结点的层数等于其双亲结点的层数+1。</li>
<li>树的高度：树中结点的最大层数。</li>
<li>有序树和无序树：若将树中每个结点的子树看成是从左到右有次序的，则称之为有序树，否则为无序树。</li>
<li>森林：是m棵互不相交的树的集合。</li>
</ul>
<h2 id="2-二叉树的定义和相关性质">2.二叉树的定义和相关性质</h2><h3 id="2-1二叉树的定义">2.1二叉树的定义</h3><p>二叉树的递归定义：</p>
<blockquote>
<p>二叉树是n(n&gt;=0)个结点的有限集，它或者是空集(n=0)，或者是由一个根节点及两棵互不相交的，分别称之为根的<strong>左子树</strong>和<strong>右子树</strong>的二叉树组成。</p>
</blockquote>
<h3 id="2-2二叉树相关性质">2.2二叉树相关性质</h3><ul>
<li>二叉树中第i层上的结点数目最多为$2^{i-1}$(i&gt;=1) 。</li>
<li>深度为k的二叉树最多包含 $2^k$-1 个结点。</li>
<li>在任意一棵二叉树中，若终端结点的个数为n0,度为2的结点个数为n2，则n0=n2+1。</li>
</ul>
<p>满二叉树和完全二叉树是二叉树的两种特殊情形。</p>
<p>满二叉树的定义：一棵深度为k且有 $2^k-1$ 个结点的二叉树为满二叉树。<br>满二叉树的特点：</p>
<ul>
<li>每一层上结点数达到最大值，即对给定的高度，它是具有最多结点数的二叉树。</li>
<li>满二叉树不存在度为1的结点，每个分支结点均有两棵高度相同的子树，且树叶都在最下一层。</li>
</ul>
<p>完全二叉树的定义：若一棵二叉树至多只有最下面的两层上节点的度数可以小于2，并且最下一层上的结点都集中在该层最左边的若干位置上，则称之为完全二叉树。<br>完全二叉树的的特点：</p>
<ul>
<li>满二叉树是完全二叉树，完全二叉树不一定是满二叉树。</li>
<li>在满二叉树的最下一层上，从最右边开始连续删去若干结点后得到的二叉树仍然是一棵完全二叉树。</li>
<li>完全二叉树中，若某个结点没有左孩子，则它一定没有右孩子，该结点必定是叶子结点。</li>
<li>具有n个结点的完全二叉树的深度为[lgn]+1</li>
</ul>
<h2 id="3-二叉树的存储结构">3.二叉树的存储结构</h2><h3 id="3-1二叉树的顺序存储结构">3.1二叉树的顺序存储结构</h3><p>完全二叉树可以按照结点编号的方法进行顺序存储。</p>
<blockquote>
<p>在一棵n个结点的完全二叉树中，从树根起，自上层到下层，每层从左到右，给所有结点从1开始顺序编号，能得到一个反映整个二叉树结构的线性序列。</p>
</blockquote>
<p>结点编号的方法存储的完全二叉树有如下特点，对编号为i的结点：</p>
<ul>
<li>若i&gt;1，则其双亲编号为[i/2]；若i=1，则是根结点，无双亲。</li>
<li>若2i&lt;=n，则其左孩子编号一定是2i，否则无左孩子，必定是叶子。</li>
<li>若2i+1&lt;=n，则其右孩子编号一定是2i+1，否则无右孩子。</li>
</ul>
<p>从编号法可以得到结论：完全二叉树中编号为[n/2,n]的结点必定是叶子结点。</p>
<p>一般二叉树也可以仿照完全二叉树的存储方法，在树中添加一些虚结点构成完全二叉树，再采用结点编号的方法顺序存储到向量中。</p>
<p>对完全二叉树而言，顺序存储结构既简单，又节省空间，一般二叉树若采用顺序存储方法，虽然简单，但容易造成存储空间的浪费。</p>
<h3 id="3-2二叉树的链式存储结构">3.2二叉树的链式存储结构</h3><p>链式存储结构适合任何二叉树，定义树中结点包含数据域，左孩子域和右孩子域。二叉树只需要保存树根结点即可，二叉树的链式存储结构又可以称为二叉链表。用java语言描述的结构定义如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">BiTree</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">class</span> <span class="title">BiNode</span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">char</span> data;</span><br><span class="line">		<span class="keyword">private</span> BiNode lChild;</span><br><span class="line">		<span class="keyword">private</span> BiNode rChild;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">BiNode</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">BiNode</span>(<span class="params"><span class="keyword">char</span> data, BiNode lChild, BiNode rChild</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.data = data;</span><br><span class="line">			<span class="keyword">this</span>.lChild = lChild;</span><br><span class="line">			<span class="keyword">this</span>.rChild = rChild;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> BiNode root = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BiTree</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-二叉树的运算">4.二叉树的运算</h2><h3 id="4-1二叉树的创建">4.1二叉树的创建</h3><p>使用指定二叉树结构图，创建如下二叉树。</p>
<center><img src="/images/bitree.png" alt="bitree"></center>

<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">()</span></span>&#123;</span><br><span class="line">	BiNode dNode = <span class="keyword">new</span> BiNode(<span class="string">'D'</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">	BiNode eNode = <span class="keyword">new</span> BiNode(<span class="string">'E'</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">	BiNode fNode = <span class="keyword">new</span> BiNode(<span class="string">'F'</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">	BiNode cNode = <span class="keyword">new</span> BiNode(<span class="string">'C'</span>,<span class="keyword">null</span>,fNode);</span><br><span class="line">	BiNode bNode = <span class="keyword">new</span> BiNode(<span class="string">'B'</span>,dNode,eNode);</span><br><span class="line">	root = <span class="keyword">new</span> BiNode(<span class="string">'A'</span>,bNode,cNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2求二叉树的高度">4.2求二叉树的高度</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> <span class="variable">height</span>(BiNode root)&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>+(<span class="variable">height</span>(root.lChild) &gt; <span class="variable">height</span>(root.rChild) ? <span class="variable">height</span>(root.lChild) : <span class="variable">height</span>(root.rChild));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3求二叉树结点总数">4.3求二叉树结点总数</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">size</span>(BiNode root)&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>+<span class="keyword">size</span>(root.lChild)+<span class="keyword">size</span>(root.rChild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-4二叉树的递归遍历">4.4二叉树的递归遍历</h3><p>定义二叉树的遍历顺序有先序遍历，中序遍历和后序遍历，其中：</p>
<ul>
<li>先序遍历：根结点-&gt;左子树-&gt;右子树</li>
<li>中序遍历：左子树-&gt;根结点-&gt;右子树</li>
<li>后序遍历：左子树-&gt;右子树-&gt;根结点</li>
</ul>
<p>对二叉树进行递归遍历，形式非常简单，且易于实现。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span>(<span class="params">BiNode root</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">		System.<span class="keyword">out</span>.print(root.data+<span class="string">"---&gt;"</span>);</span><br><span class="line">		preOrder(root.lChild);</span><br><span class="line">		preOrder(root.rChild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span>(<span class="params">BiNode root</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">		inOrder(root.lChild);</span><br><span class="line">		System.<span class="keyword">out</span>.print(root.data+<span class="string">"---&gt;"</span>);</span><br><span class="line">		inOrder(root.rChild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span>(<span class="params">BiNode root</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">		postOrder(root.lChild);</span><br><span class="line">		postOrder(root.rChild);</span><br><span class="line">		System.<span class="keyword">out</span>.print(root.data+<span class="string">"---&gt;"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-5二叉树的非递归遍历">4.5二叉树的非递归遍历</h3><p>相比较二叉树的递归遍历，非递归遍历则显得相当麻烦，尤其是后序遍历，我们需要像递归那样，另外维护一个操作栈，来记录之前的结点。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="literal">void</span> nonRecPreOrder()&#123;</span><br><span class="line">	<span class="built_in">Stack</span><span class="subst">&lt;</span>BiNode<span class="subst">&gt;</span> <span class="built_in">stack</span> <span class="subst">=</span> <span class="literal">new</span> <span class="built_in">Stack</span><span class="subst">&lt;</span>BiNode<span class="subst">&gt;</span>();</span><br><span class="line">	<span class="keyword">while</span>(root <span class="subst">!=</span> <span class="built_in">null</span> <span class="subst">||</span> <span class="built_in">stack</span><span class="built_in">.</span>size() <span class="subst">&gt;</span> <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>(root <span class="subst">!=</span> <span class="built_in">null</span>)&#123;</span><br><span class="line">			System<span class="built_in">.</span>out<span class="built_in">.</span>print(root<span class="built_in">.</span><span class="built_in">data</span><span class="subst">+</span><span class="string">"---&gt;"</span>);</span><br><span class="line">			<span class="built_in">stack</span><span class="built_in">.</span>push(root);</span><br><span class="line">			root <span class="subst">=</span> root<span class="built_in">.</span>lChild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">stack</span><span class="built_in">.</span>size() <span class="subst">&gt;</span> <span class="number">0</span>)&#123;</span><br><span class="line">			root <span class="subst">=</span> <span class="built_in">stack</span><span class="built_in">.</span>pop();</span><br><span class="line">			root <span class="subst">=</span> root<span class="built_in">.</span>rChild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="literal">void</span> nonRecInOrder()&#123;</span><br><span class="line">	<span class="built_in">Stack</span><span class="subst">&lt;</span>BiNode<span class="subst">&gt;</span> <span class="built_in">stack</span> <span class="subst">=</span> <span class="literal">new</span> <span class="built_in">Stack</span><span class="subst">&lt;</span>BiNode<span class="subst">&gt;</span>();</span><br><span class="line">	<span class="keyword">while</span>(root <span class="subst">!=</span> <span class="built_in">null</span> <span class="subst">||</span> <span class="built_in">stack</span><span class="built_in">.</span>size() <span class="subst">&gt;</span> <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>(root <span class="subst">!=</span> <span class="built_in">null</span>)&#123;</span><br><span class="line">			<span class="built_in">stack</span><span class="built_in">.</span>push(root);</span><br><span class="line">			root <span class="subst">=</span> root<span class="built_in">.</span>lChild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">stack</span><span class="built_in">.</span>size() <span class="subst">&gt;</span> <span class="number">0</span>)&#123;</span><br><span class="line">			root <span class="subst">=</span> <span class="built_in">stack</span><span class="built_in">.</span>pop();</span><br><span class="line">			System<span class="built_in">.</span>out<span class="built_in">.</span>print(root<span class="built_in">.</span><span class="built_in">data</span><span class="subst">+</span><span class="string">"---&gt;"</span>);</span><br><span class="line">			root <span class="subst">=</span> root<span class="built_in">.</span>rChild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="literal">void</span> nonRecPostOrder()&#123;</span><br><span class="line">	<span class="built_in">Stack</span><span class="subst">&lt;</span>BiNode<span class="subst">&gt;</span> <span class="built_in">stack</span> <span class="subst">=</span> <span class="literal">new</span> <span class="built_in">Stack</span><span class="subst">&lt;</span>BiNode<span class="subst">&gt;</span>();</span><br><span class="line">	BiNode cur, pre <span class="subst">=</span> <span class="built_in">null</span>;</span><br><span class="line">	<span class="built_in">stack</span><span class="built_in">.</span>push(root);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">stack</span><span class="built_in">.</span>size() <span class="subst">&gt;</span> <span class="number">0</span>)&#123;</span><br><span class="line">		cur <span class="subst">=</span> <span class="built_in">stack</span><span class="built_in">.</span>peek();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>((cur<span class="built_in">.</span>lChild <span class="subst">==</span> <span class="built_in">null</span> <span class="subst">&amp;&amp;</span> cur<span class="built_in">.</span>rChild <span class="subst">==</span> <span class="built_in">null</span>) <span class="subst">||</span> (pre <span class="subst">!=</span> <span class="built_in">null</span> <span class="subst">&amp;&amp;</span> (pre <span class="subst">==</span> cur<span class="built_in">.</span>lChild <span class="subst">||</span> pre <span class="subst">==</span> cur<span class="built_in">.</span>rChild)))&#123;</span><br><span class="line">			System<span class="built_in">.</span>out<span class="built_in">.</span>print(cur<span class="built_in">.</span><span class="built_in">data</span><span class="subst">+</span><span class="string">"---&gt;"</span>);</span><br><span class="line">			<span class="built_in">stack</span><span class="built_in">.</span>pop();</span><br><span class="line">			pre <span class="subst">=</span> cur;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(cur<span class="built_in">.</span>rChild <span class="subst">!=</span> <span class="built_in">null</span>)</span><br><span class="line">				<span class="built_in">stack</span><span class="built_in">.</span>push(cur<span class="built_in">.</span>rChild);</span><br><span class="line">			<span class="keyword">if</span>(cur<span class="built_in">.</span>lChild <span class="subst">!=</span> <span class="built_in">null</span>)</span><br><span class="line">				<span class="built_in">stack</span><span class="built_in">.</span>push(cur<span class="built_in">.</span>lChild);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-线索二叉树">5.线索二叉树</h2><p>前言：n个结点的二叉链表有n-1个空指针域，利用二叉链表中的空指针域，存放指向结点在某种遍历次序下的前驱和后继结点的指针，这种附加的指针称之为线索。加上了线索的链表称之为线索链表，相应的二叉树为线索二叉树。</p>
<p>线索链表解决了二叉链表找左、右孩子容易，但无法直接找到该结点在某种遍历次序下的前驱和后继困难的问题。线索链表的结构定义如下所示：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> PointerTag&#123;</span><br><span class="line">	Link,Thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">BiThreadTree</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">class</span> <span class="title">BiThreadNode</span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">char</span> data;</span><br><span class="line">		<span class="keyword">private</span> PointerTag lTag,rTag;</span><br><span class="line">		<span class="keyword">private</span> BiThreadNode lChild,rChild;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">BiThreadNode</span>(<span class="params"><span class="keyword">char</span> data, BiThreadNode lChild, BiThreadNode rChild</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.data = data;</span><br><span class="line">			<span class="keyword">this</span>.lChild = lChild;</span><br><span class="line">			<span class="keyword">this</span>.rChild = rChild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> BiThreadNode root = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BiThreadTree</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上定义可以看出，线索链表与二叉链表的唯一区别在于，其结点，多了两个枚举变量，该枚举变量指示当前结点指针域是指针还是线索。枚举变量lTag=Link,表示当前lChild指针域是指向左孩子的指针，枚举变量lTag=Thread,表示当前lChild指针域是指向其前驱的线索，没有左孩子；对于枚举变量rTag也一样。</p>
<p>根据不同的遍历次序，可以构造不同的线索二叉树，以中序遍历为例，构造中序线索二叉树如下，需要设置pre指针指示当前访问结点的前一个结点。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BiThreadNode pre <span class="subst">=</span> <span class="built_in">null</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="literal">void</span> inOrderThreading(BiThreadNode root)&#123;</span><br><span class="line">	<span class="keyword">if</span>(root <span class="subst">!=</span> <span class="built_in">null</span>)&#123;</span><br><span class="line">		inOrderThreading(root<span class="built_in">.</span>lChild);</span><br><span class="line"></span><br><span class="line">		root<span class="built_in">.</span>lTag <span class="subst">=</span> (root<span class="built_in">.</span>lChild <span class="subst">!=</span> <span class="built_in">null</span>) <span class="subst">?</span> PointerTag<span class="built_in">.</span><span class="keyword">Link</span> : PointerTag<span class="built_in">.</span><span class="keyword">Thread</span>;</span><br><span class="line">		root<span class="built_in">.</span>rTag <span class="subst">=</span> (root<span class="built_in">.</span>rChild <span class="subst">!=</span> <span class="built_in">null</span>) <span class="subst">?</span> PointerTag<span class="built_in">.</span><span class="keyword">Link</span> : PointerTag<span class="built_in">.</span><span class="keyword">Thread</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(pre <span class="subst">!=</span> <span class="built_in">null</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(pre<span class="built_in">.</span>rTag <span class="subst">==</span> PointerTag<span class="built_in">.</span><span class="keyword">Thread</span>)</span><br><span class="line">				pre<span class="built_in">.</span>rChild <span class="subst">=</span> root;</span><br><span class="line">			<span class="keyword">if</span>(root<span class="built_in">.</span>lTag <span class="subst">==</span> PointerTag<span class="built_in">.</span><span class="keyword">Thread</span>)</span><br><span class="line">				root<span class="built_in">.</span>lChild <span class="subst">=</span> pre;</span><br><span class="line">		&#125;</span><br><span class="line">		pre <span class="subst">=</span> root;</span><br><span class="line"></span><br><span class="line">		inOrderThreading(root<span class="built_in">.</span>rChild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-赫夫曼树和赫夫曼编码">6.赫夫曼树和赫夫曼编码</h2><h3 id="6-1相关概念">6.1相关概念</h3><ul>
<li>树的路径长度：是从树根到树中每一叶子结点的路径长度之和。在结点数目相同的二叉树中，完全二叉树的路径长度最短。</li>
<li>树的带权路径长度：树中某一叶子结点的带权路径长度为结点到根的路径长度与该结点权值的乘积，树中所有叶子结点的带权路径长度之和。</li>
<li>最优二叉树或赫夫曼树：在权值分别为 $w_1$ , $w_2$ ,…, $w_n$ 的n个叶子所构成的所有二叉树中，带权路径长度最小(代价最小)的二叉树称为最优二叉树或赫夫曼树。</li>
</ul>
<h3 id="6-2赫夫曼树特点">6.2赫夫曼树特点</h3><ul>
<li>所有叶子的权值均相等时，完全二叉树就是最优二叉树(赫夫曼树)。</li>
<li>最优二叉树中，权越大的叶子离根越近。</li>
<li>最优二叉树形态不唯一，WPL最小。</li>
</ul>
<h3 id="6-3构造赫夫曼树">6.3构造赫夫曼树</h3><p>赫夫曼树的构造过程，可以概括为以下内容：</p>
<ol>
<li>根据给定的n个权值w1,w2,…,wn构成n棵二叉树的森林F={T1,T2,…Tn}，其中每棵二叉树Ti中都只有一个权值为wi的根结点，其左右子树均为空。</li>
<li>在森林F中选出两棵根结点权值最小的树，将这两棵树合并成一颗新树，为了保证新树仍是二叉树，需要增加一个新结点作为新二叉树的根，并将所选两棵树的根分别作为该新二叉树根的左孩子和右孩子(谁左谁右，无关紧要)，将这两个孩子的权值之和作为新树根的权值。</li>
<li>对新的森林F重复步骤2，直到森林F中只剩下一棵树为止。这棵树便是赫夫曼树。</li>
</ol>
<p>构造赫夫曼树的注意点：</p>
<ul>
<li>初始森林中的n棵二叉树，每棵树只有一个结点，它们既是根也是叶子。</li>
<li>n个叶子的赫夫曼树要经过n-1次合并，产生n-1个新结点，最终求得的赫夫曼树一共有2n-1个结点。</li>
<li>赫夫曼树是严格的二叉树，树中没有度为1的结点。</li>
</ul>
<p>根据以下相关内容，可以知道赫夫曼树是一种顺序存储结构，最后的赫夫曼树包含2n-1个结点，存储在向量中，结点需要包含权值信息，双亲，左孩子和右孩子。下面是赫夫曼树及其结点的类型定义：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">HuffmanTree</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">class</span> <span class="title">HuffmaNode</span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> lChild, rChild, parent;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">HuffmaNode</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.weight = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">this</span>.lChild = -<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">this</span>.rChild = -<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">this</span>.parent = -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> leafNodeNum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> nodeNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> HuffmaNode[] data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HuffmanTree</span>(<span class="params"><span class="keyword">int</span>[] inputData</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.leafNodeNum = inputData.length;</span><br><span class="line">		<span class="keyword">this</span>.nodeNum = <span class="keyword">this</span>.leafNodeNum*<span class="number">2</span>-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.data = <span class="keyword">new</span> HuffmaNode[nodeNum];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造赫夫曼树的过程，包括初始化森林F，即根据输入权值序列，初始化前n个叶子结点，构成森林，然后依次从前面的结点中选出根节点权值最小的2个，并生成新结点，共重复n-1次。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">public</span> void create(int[] input)&#123;</span><br><span class="line">	int i = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">	for(<span class="comment">; i&lt;leafNodeNum; i++)&#123;</span></span><br><span class="line">		<span class="preprocessor">data</span>[i] = new HuffmaNode()<span class="comment">;</span></span><br><span class="line">		<span class="preprocessor">data</span>[i].weight = input[i]<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for(<span class="comment">; i&lt;nodeNum; i++)&#123;</span></span><br><span class="line">		int <span class="keyword">select[] </span>= <span class="keyword">selectMin2(data, </span>i)<span class="comment">;</span></span><br><span class="line">		<span class="preprocessor">data</span>[i] = new HuffmaNode()<span class="comment">;</span></span><br><span class="line">		<span class="preprocessor">data</span>[i].lChild = <span class="keyword">select[0];</span><br><span class="line"></span>		<span class="preprocessor">data</span>[i].rChild = <span class="keyword">select[1];</span><br><span class="line"></span>		<span class="preprocessor">data</span>[i].weight = <span class="preprocessor">data</span>[<span class="keyword">select[0]].weight </span>+ <span class="preprocessor">data</span>[<span class="keyword">select[1]].weight;</span><br><span class="line"></span>		<span class="preprocessor">data</span>[<span class="keyword">select[0]].parent </span>= <span class="preprocessor">data</span>[<span class="keyword">select[1]].parent </span>= i<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中从前i个结点选出根节点权值最小的两个结点序号如下所示：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">public</span> int[] <span class="keyword">selectMin2(HuffmaNode[] </span><span class="preprocessor">data</span>, int n)&#123;</span><br><span class="line">	int <span class="keyword">select[] </span>= new int[<span class="number">2</span>]<span class="comment">;</span></span><br><span class="line">	int <span class="literal">s1</span> = <span class="number">0</span>, <span class="literal">s2</span> = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">	int minWeight1 = MAX_WEIGHT<span class="comment">;</span></span><br><span class="line">	int minWeight2 = MAX_WEIGHT<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	for(int i<span class="number">=0</span><span class="comment">; i&lt;n; i++)&#123;</span></span><br><span class="line">		<span class="preprocessor">if</span>(<span class="preprocessor">data</span>[i].parent == -<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="preprocessor">if</span>(<span class="preprocessor">data</span>[i].weight &lt; minWeight1)&#123;</span><br><span class="line">				minWeight1 = <span class="preprocessor">data</span>[i].weight<span class="comment">;</span></span><br><span class="line">				<span class="literal">s1</span> = i<span class="comment">;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for(int i<span class="number">=0</span><span class="comment">; i&lt;n; i++)&#123;</span></span><br><span class="line">		<span class="preprocessor">if</span>(i != <span class="literal">s1</span> &amp;&amp; <span class="preprocessor">data</span>[i].parent == -<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="preprocessor">if</span>(<span class="preprocessor">data</span>[i].weight &lt; minWeight2)&#123;</span><br><span class="line">				minWeight2 = <span class="preprocessor">data</span>[i].weight<span class="comment">;</span></span><br><span class="line">				<span class="literal">s2</span> = i<span class="comment">;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select[0] </span>= <span class="literal">s1</span><span class="comment">;</span></span><br><span class="line">	<span class="keyword">select[1] </span>= <span class="literal">s2</span><span class="comment">;</span></span><br><span class="line">	return <span class="keyword">select;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>经过以上步骤，输入n个结点权值的赫夫曼树构建完成，赫夫曼树的主要用途就是赫夫曼编码，接下来为大家介绍赫夫曼编码的相关知识。</p>
<h3 id="6-4赫夫曼编码">6.4赫夫曼编码</h3><p>前言：数据压缩过程称为编码，数据解压过程称为解码。给定一个字符集，可能存在多种编码方案。</p>
<blockquote>
<p>等长编码方案：给定字符集中每个字符包含相同长度的编码。<br>变长编码方案：将频度高的字符编码设置短，将频度低的字符编码设置较长。<br>前缀码方案：对字符集进行编码时，要求字符集中任一字符的编码都不是其它字符的编码的前缀。<br>最优前缀码：平均码长或文件总长最小的前缀编码称为最优前缀码，最优前缀码的压缩效果最佳</p>
</blockquote>
<p>变长编码方案比等长编码方案，一定程度上节约了存储空间，但是可能会使解码产生二义性，产生该问题的原因是某些字符的编码可能与其它某些字符的编码开始部分(称为前缀)相同。例如假设A:00,B:01,C:0001,则解码时无法确定0001是C还是AB。因此引出前缀码方案。</p>
<p>利用赫夫曼树很容易求出给定字符集及其概率分布的最优前缀码，赫夫曼编码是一种应用广泛且非常有效的数据压缩技术。赫夫曼编码是最优前缀码的原因：</p>
<ul>
<li>每个叶子字符ci的码长恰为从根到该叶子的路径长度li,平均码长(或是文件总长)又是二叉树的带权路径长度WPL,而赫夫曼树是WPL最小的二叉树，因此编码的平均码长或文件总长最小。</li>
<li>赫夫曼树中没有一片叶子是另一叶子的祖先，每片叶子对应的编码就不可能是其它叶子编码的前缀，即上述编码是前缀编码。</li>
</ul>
<p>赫夫曼编码类型定义为除了包含叶子字符属性，还包含该字符对应的编码。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmaNode</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">private</span> String code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> HuffmaNode[] encode;</span><br></pre></td></tr></table></figure>
<p>求赫夫曼编码的思想：依次以叶子T<a href="0&lt;=i&lt;=n">i</a>为出发点，向上回溯至根为止，上溯时，走左分支则生成代码0，走右分支则生成代码1。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">huffmanEncoding</span><span class="params">(<span class="keyword">char</span>[] inputCode)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;leafNodeNum; i++)&#123;</span><br><span class="line">		encode[i] = <span class="keyword">new</span> HuffmaNode();</span><br><span class="line">		encode[i].ch = inputCode[i];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> p, c = i;</span><br><span class="line">		<span class="keyword">char</span> cd[] = <span class="keyword">new</span> <span class="keyword">char</span>[leafNodeNum];</span><br><span class="line">		<span class="keyword">int</span> start = leafNodeNum-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>((p = data[c].parent) != -<span class="number">1</span>)&#123;</span><br><span class="line">			cd[start--] = (c == data[p].lChild) ? <span class="string">'0'</span> : <span class="string">'1'</span>;</span><br><span class="line">			c = p;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		encode[i].code = <span class="keyword">new</span> String(cd).substring(start+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong> 树是数据结构中非常重要的内容，是典型的非线性结构，并具有明显层次关系，非常类似于自然界的树。二叉树又是树形结构的代表，许多实际问题抽象出来的数据结构往往都是二叉树的形式，即使是一般的树也能转换为二叉树，而且二叉树的存储结构和算法都较为简单，因此二叉树显得尤为重要，本章为大家讲述二叉树的存储结构，创建，遍历等操作，以及线索二叉树的创建和最优二叉树赫夫曼树的定义和构造，另外还包含赫夫曼编码的输出等内容。]]>
    
    </summary>
    
      <category term="数据结构" scheme="http://blog.zbvae.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构-多维数组和广义表]]></title>
    <link href="http://blog.zbvae.com/2015/07/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/"/>
    <id>http://blog.zbvae.com/2015/07/21/数据结构-多维数组和广义表/</id>
    <published>2015-07-21T05:22:54.000Z</published>
    <updated>2015-08-06T11:52:33.737Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong> 多维数组和广义表属于数据结构中非线性结构的基础内容。虽然较线性结构相对复杂，但是，从其递归意义上来说，组成它们的基础也是线性数据结构。本文主要以稀疏矩阵为代表探讨多维数组和广义表数据结构的存储和计算。<a id="more"></a></p>
<h2 id="1-多维数组和广义表">1.多维数组和广义表</h2><p>多维数组可以理解为一维数组里的数据元素是一维或者多维数组，通过降维处理可以简化分析。广义表包含表头和表尾，表头可以原子也可以是列表，表尾是由表中除表头以外的所有元素构成的字表，因此表尾一定是列表。广义表从递归意义上也可以理解为线性表中的数据元素是普通元素或者是嵌套的线性表。</p>
<p>多维数组从存储习惯上主要分为按行存储和按列存储，其中C和C++以及JAVA等主流语言都是按行存储，FORTRAN语言采用按列存储的原则，按行存储，只需要先变最右边的下标即可；反之，按列存储只需要先改变最左边的下标即可。对于已知三维数组长宽高分别为m,n,l，数组基址a[0][0][0]为loc(a[0][0][0])，如何求a[i][j][k]的地址。</p>
<p>loc(a[i][j][k]) = loc(a[0][0][0]) + (k*m*n+j*m+i)*d</p>
<h2 id="2-稀疏矩阵的存储">2.稀疏矩阵的存储</h2><p>多维数组实际上就是矩阵，只是在科学计算领域，矩阵有着特殊含义。在一个矩阵中，如果非零元素的个数远小于零元素的个数，我们称之为稀疏矩阵。对于稀疏矩阵的存储，我们不用像普通多维数组那样，为所有的元素分配内存空间，而把注意力放在非零元的存储问题上。下面介绍两种稀疏矩阵的存储方法，一种顺序存储方式表现为三元组表，另一种属于链式存储方式，即十字链表。</p>
<h3 id="2-1三元组表">2.1三元组表</h3><p>三元组表为稀疏矩阵的顺序存储方式，稀疏矩阵中的每一个非零元都表现为一个三元组，包含该非零元所在行号，所在列号，以及非零元的值。整个稀疏矩阵只存储所有的非零元，是一个三元组顺序表，其属性包含三元组数组，稀疏矩阵行数，列数以及非零元个数。下面分别是三元组类型定义个稀疏矩阵三元组表的类型定义。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeqMatrix</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ELE_NUM = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TriNode</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> j;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> e;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> TriNode data[] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> rowNum;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> colNum;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">count</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> SeqMatrix()&#123;</span><br><span class="line">		data = <span class="keyword">new</span> TriNode[MAX_ELE_NUM];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> SeqMatrix(<span class="keyword">int</span> rowNum, <span class="keyword">int</span> colNum, <span class="keyword">int</span> <span class="keyword">count</span>)&#123;</span><br><span class="line">		data = <span class="keyword">new</span> TriNode[MAX_ELE_NUM];</span><br><span class="line">		<span class="keyword">this</span>.rowNum = rowNum;</span><br><span class="line">		<span class="keyword">this</span>.colNum = colNum;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">count</span> &gt; MAX_ELE_NUM)&#123;</span><br><span class="line">			System.out.println(<span class="string">"the element is too much!"</span>);</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.<span class="keyword">count</span> = <span class="keyword">count</span>;</span><br><span class="line">		System.out.println(<span class="string">"the row num is "</span>+rowNum+<span class="string">", the col num is "</span>+colNum+<span class="string">", the element num is "</span>+<span class="keyword">count</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三元组表的定义类似于顺序表，底层也是数组实现，下面采用接收用户输入的方式创建三元组表：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> create()&#123;</span><br><span class="line">	System.out.<span class="built_in">println</span>(<span class="string">"please input trinode:\ni j e"</span>);</span><br><span class="line">	<span class="keyword">BufferedReader</span> br = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		br = <span class="keyword">new</span> <span class="keyword">BufferedReader</span>(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> t=<span class="number">0</span>; t&lt;count; t++)&#123;</span><br><span class="line">			<span class="keyword">String</span> inputStr = br.readLine();</span><br><span class="line">			<span class="keyword">if</span>(inputStr != <span class="keyword">null</span> &amp;&amp; inputStr.<span class="built_in">split</span>(<span class="string">" "</span>).length == <span class="number">3</span>)&#123;</span><br><span class="line">				<span class="keyword">String</span> strs[] = inputStr.<span class="built_in">split</span>(<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">				<span class="built_in">int</span> i = Integer.parseInt(strs[<span class="number">0</span>]);</span><br><span class="line">				<span class="built_in">int</span> j = Integer.parseInt(strs[<span class="number">1</span>]);</span><br><span class="line">				<span class="built_in">int</span> e = Integer.parseInt(strs[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;rowNum || j&lt;<span class="number">1</span> || j&gt;colNum)&#123;</span><br><span class="line">					System.out.<span class="built_in">println</span>(<span class="string">"Your input is wrong!"</span>);</span><br><span class="line">					System.<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				data[t] = <span class="keyword">new</span> TriNode();</span><br><span class="line">				data[t].i = i-<span class="number">1</span>;</span><br><span class="line">				data[t].j = j-<span class="number">1</span>;</span><br><span class="line">				data[t].e = e;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		getRowOrderMatrix();</span><br><span class="line">	&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意以上代码中，待用户输入完所有三元组后，调用了一个getRowOrderMatrix函数目的是为了将其转换为按行有序，而三元组按行有序排列是为了便于后续的转置等运算。下面是转换成按行有序的程序代码，先以行号排列，如果行号相等，再以列号排列，注意下面采用的是冒泡排序算法。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> void getRowOrderMatrix()&#123;</span><br><span class="line">	for(<span class="built_in">int</span> t=<span class="number">0</span>; t&lt;<span class="built_in">count</span>-<span class="number">1</span>; t++)&#123;</span><br><span class="line">		for(<span class="built_in">int</span> x=<span class="built_in">count</span>-t-<span class="number">1</span>; x&gt;= <span class="number">1</span>; x--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="type">data</span>[x].i &lt; <span class="type">data</span>[x-<span class="number">1</span>].i)&#123;</span><br><span class="line">				TriNode temp = <span class="type">data</span>[x];</span><br><span class="line">				<span class="type">data</span>[x] = <span class="type">data</span>[x-<span class="number">1</span>];</span><br><span class="line">				<span class="type">data</span>[x-<span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for(<span class="built_in">int</span> t=<span class="number">0</span>; t&lt;<span class="built_in">count</span>-<span class="number">1</span>; t++)&#123;</span><br><span class="line">		for(<span class="built_in">int</span> x=<span class="built_in">count</span>-t-<span class="number">1</span>; x&gt;= <span class="number">1</span>; x--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="type">data</span>[x].i == <span class="type">data</span>[x-<span class="number">1</span>].i &amp;&amp; <span class="type">data</span>[x].j &lt; <span class="type">data</span>[x-<span class="number">1</span>].j)&#123;</span><br><span class="line">				TriNode temp = <span class="type">data</span>[x];</span><br><span class="line">				<span class="type">data</span>[x] = <span class="type">data</span>[x-<span class="number">1</span>];</span><br><span class="line">				<span class="type">data</span>[x-<span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如本程序定义一个三元组表，用户按以下顺序输入三元组2 2 1,2 1 2,1 2 3。经过按行排序之后，三元组表为1 2 3,2 1 2,2 2 1。三元组表按行排序之后，我们就可以对其方便的进行转置操作了。一个矩阵经转置之后，原始矩阵中的第i行变成转置矩阵的第i列。即矩阵中行列数互换，每一个元素行列号互换。稀疏矩阵转置之后仍然是稀疏矩阵，为了保证转置之后的稀疏矩阵仍然是按行有序的。这里我们选择对原始矩阵按列进行转置，原始矩阵的每一列就是转置矩阵的每一行，因此对原始矩阵按列运算，得到的转置矩阵就是按行有序的。</p>
<p>对原始矩阵的每一列，在三元组表中查找列号等于该列的元素，如果有的话，直接将其行列号互换，就得到了转置矩阵中的某一行非零元。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SeqMatrix transpose()&#123;</span><br><span class="line">	SeqMatrix tMatrix = <span class="keyword">new</span> SeqMatrix(colNum, rowNum, <span class="keyword">count</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(tMatrix.<span class="keyword">count</span> &lt; <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> q = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>; col&lt;<span class="keyword">this</span>.colNum; col++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>; t&lt;<span class="keyword">count</span>; t++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">this</span>.data[t].j == col)&#123;</span><br><span class="line">				tMatrix.data[q] = <span class="keyword">new</span> TriNode();</span><br><span class="line">				tMatrix.data[q].i = <span class="keyword">this</span>.data[t].j;</span><br><span class="line">				tMatrix.data[q].j = <span class="keyword">this</span>.data[t].i;</span><br><span class="line">				tMatrix.data[q].e = <span class="keyword">this</span>.data[t].e;</span><br><span class="line">				q++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> tMatrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>稀疏矩阵的三元组表存储方式比较易于理解，但不利于插入或改变某个非零元，如果要频繁地进行插入或删除非零元的工作，则需要采用链式存储方式，即下面要介绍的十字链表存储。</p>
<h2 id="2-2十字链表">2.2十字链表</h2><p>在原有三元组的基础之上，再增加两个指针域right和down，构成五元组，right指向该行下一个五元组，down指向该列下一个五元组，这便是十字链表中的结点。同样十字链表除了具有稀疏矩阵行数，列数以及非零元个数之外，还需要维护一份行链表数组和列链表数组，因为稀疏矩阵的每一行和每一列都是一个链表，链表表头为该行或该列第一个非零元，因此行链表数组的大小是稀疏矩阵的行数，列链表数组的大小是稀疏矩阵的列数。下面是五元组和十字链表的定义。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkMatrix</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkNode</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> j;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> e;</span><br><span class="line">		<span class="keyword">private</span> LinkNode right;</span><br><span class="line">		<span class="keyword">private</span> LinkNode down;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> LinkNode()&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> LinkNode(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> e, LinkNode right, LinkNode down)&#123;</span><br><span class="line">			<span class="keyword">this</span>.i = i;</span><br><span class="line">			<span class="keyword">this</span>.j = j;</span><br><span class="line">			<span class="keyword">this</span>.e = e;</span><br><span class="line">			<span class="keyword">this</span>.right = right;</span><br><span class="line">			<span class="keyword">this</span>.down = down;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> LinkNode rHead[];</span><br><span class="line">	<span class="keyword">private</span> LinkNode dHead[];</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> rowNum;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> colNum;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">count</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> LinkMatrix()&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> LinkMatrix(<span class="keyword">int</span> rowNum, <span class="keyword">int</span> colNum, <span class="keyword">int</span> <span class="keyword">count</span>)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.rowNum = rowNum;</span><br><span class="line">		<span class="keyword">this</span>.colNum = colNum;</span><br><span class="line">		<span class="keyword">this</span>.<span class="keyword">count</span> = <span class="keyword">count</span>;</span><br><span class="line">		<span class="keyword">this</span>.rHead = <span class="keyword">new</span> LinkNode[rowNum];</span><br><span class="line">		<span class="keyword">this</span>.dHead = <span class="keyword">new</span> LinkNode[colNum];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面以接收用户输入方式创建十字链表，十字链表的创建过程有点复杂，考察的是单链表的知识，因此，如果这里有什么不清楚的，再回过头去查看线性表中单链表的相关知识。下面是十字链表创建代码。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> create()&#123;</span><br><span class="line">	System.out.<span class="built_in">println</span>(<span class="string">"please input trinode:\ni j e"</span>);</span><br><span class="line">	<span class="keyword">BufferedReader</span> br = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		br = <span class="keyword">new</span> <span class="keyword">BufferedReader</span>(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> t=<span class="number">0</span>; t&lt;count; t++)&#123;</span><br><span class="line">			<span class="keyword">String</span> inputStr = br.readLine();</span><br><span class="line">			<span class="keyword">if</span>(inputStr != <span class="keyword">null</span> &amp;&amp; inputStr.<span class="built_in">split</span>(<span class="string">" "</span>).length == <span class="number">3</span>)&#123;</span><br><span class="line">				<span class="keyword">String</span> strs[] = inputStr.<span class="built_in">split</span>(<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">				<span class="built_in">int</span> i = Integer.parseInt(strs[<span class="number">0</span>])-<span class="number">1</span>;</span><br><span class="line">				<span class="built_in">int</span> j = Integer.parseInt(strs[<span class="number">1</span>])-<span class="number">1</span>;</span><br><span class="line">				<span class="built_in">int</span> e = Integer.parseInt(strs[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;rowNum-<span class="number">1</span> || j&lt;<span class="number">0</span> || j&gt;colNum-<span class="number">1</span>)&#123;</span><br><span class="line">					System.out.<span class="built_in">println</span>(<span class="string">"Your input is wrong!"</span>);</span><br><span class="line">					System.<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				LinkNode s = <span class="keyword">new</span> LinkNode(i,j,e,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span>(<span class="keyword">this</span>.rHead[i] == <span class="keyword">null</span> || <span class="keyword">this</span>.rHead[i].j &gt; s.j)&#123;</span><br><span class="line">					s.right = <span class="keyword">this</span>.rHead[i];</span><br><span class="line">					<span class="keyword">this</span>.rHead[i] = s;	</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					LinkNode p = <span class="keyword">this</span>.rHead[i];<span class="comment">//first row node</span></span><br><span class="line">					<span class="keyword">while</span>(p.j &lt; s.j)&#123;</span><br><span class="line">						p = p.right;</span><br><span class="line">					&#125;</span><br><span class="line">					s.right = p.right;</span><br><span class="line">					p.right = s;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span>(<span class="keyword">this</span>.dHead[j] == <span class="keyword">null</span> || <span class="keyword">this</span>.rHead[j].i &gt; s.i)&#123;</span><br><span class="line">					s.down = <span class="keyword">this</span>.dHead[j];</span><br><span class="line">					<span class="keyword">this</span>.dHead[j] = s;	</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					LinkNode p = <span class="keyword">this</span>.dHead[j];<span class="comment">//first row node</span></span><br><span class="line">					<span class="keyword">while</span>(p.i &lt; s.i)&#123;</span><br><span class="line">						p = p.down;</span><br><span class="line">					&#125;</span><br><span class="line">					s.down = p.down;</span><br><span class="line">					p.down = s;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接收用户收入将其转换成三元组，并实例化LinkNode是比较容易理解了，初始化时，right和down都为空，设新结点为s。</p>
<p>先构造行链表数组：</p>
<ul>
<li>如果s中行号所在的行链表即rHead[i]为空，说明这一行还没有非零元加入或者rHead[i].j &gt; s.j说明这一行表头结点的列号大于用户新输入的三元组列号，这两种情况，都只需要将新结点直接加入表头即可，对应单链表的头插法。</li>
<li>如果这两个条件都不满足，说明这一行已经有非零元，为了保证行链表中结点按列号有序，需要为新结点找到合适的插入位置，我们先获取表头结点赋值给工作结点p,只要p.j &lt; s.j，继续让p = p.right，直到找到p的下一个结点列号大于用户输入的三元组列号，按照单链表中的插入结点方法，s.right = p.right;p.right = s。</li>
</ul>
<p>再构造列链表数组：</p>
<ul>
<li>如果s中列号所在的行链表即dHead[j]为空，说明这一列还没有非零元加入或者dHead[j].i &gt; s.i说明这一列表头结点的行号大于用户新输入的三元组行号，这两种情况，都只需要将新结点直接加入表头即可，对应单链表的头插法。</li>
<li>如果这两个条件都不满足，说明这一列已经有非零元，为了保证列链表中结点按行号有序，需要为新结点找到合适的插入位置，我们先获取表头结点赋值给工作结点p,只要p.i &lt; s.i，继续让p = p.down，直到找到p的下一个结点行号大于用户输入的三元组行号，按照单链表中的插入结点方法，s.down = p.down;p.down = s。</li>
</ul>
<p>完成了行链表数组和链表数组的构建工作，也就完成十字链表的创建工作。</p>
<p>采用十字链表表示的稀疏矩阵的转置运算，主要也是在于行链表和列链表数组的调整，将之前的行链表数组调整为列链表数组，将之前的列链表数组调整为行链表数组即可。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function">LinkMatrix <span class="title">transpose</span><span class="params">()</span></span>&#123;</span><br><span class="line">	LinkMatrix linkMatrix = <span class="keyword">new</span> LinkMatrix(colNum, rowNum, count);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rowNum; i++)&#123;</span><br><span class="line">		LinkNode p = <span class="keyword">this</span>.rHead[i];</span><br><span class="line">		LinkNode r = <span class="keyword">new</span> LinkNode(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);<span class="comment">//rear node</span></span><br><span class="line">		<span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">			LinkNode q = <span class="keyword">new</span> LinkNode(p.j,p.i,p.e,p.down,p.right);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(linkMatrix.dHead[i] == <span class="keyword">null</span>)&#123;</span><br><span class="line">				linkMatrix.dHead[i] = q;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				r.down = q;</span><br><span class="line">				r = q;</span><br><span class="line">			&#125;</span><br><span class="line">			p = p.right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;colNum; i++)&#123;</span><br><span class="line">		LinkNode p = <span class="keyword">this</span>.dHead[i];</span><br><span class="line">		LinkNode r = <span class="keyword">new</span> LinkNode(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);<span class="comment">//rear node</span></span><br><span class="line">		<span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">			LinkNode q = <span class="keyword">new</span> LinkNode(p.j,p.i,p.e,p.down,p.right);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(linkMatrix.rHead[i] == <span class="keyword">null</span>)&#123;</span><br><span class="line">				linkMatrix.rHead[i] = q;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				r.right = q;</span><br><span class="line">				r = q;</span><br><span class="line">			&#125;</span><br><span class="line">			p = p.down;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> linkMatrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对原始稀疏矩阵行链表数组，将其转换为对应的转置矩阵的列链表数组。这里采用单链表尾插法构造。下面是本程序的测试类：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> TestSMatrix&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">		System.out.<span class="keyword">println</span>(<span class="string">"text sequence matrix"</span>);</span><br><span class="line">		SeqMatrix seqMatrix = <span class="keyword">new</span> SeqMatrix(<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">		seqMatrix.create();</span><br><span class="line">		seqMatrix.<span class="keyword">print</span>();</span><br><span class="line">		System.out.<span class="keyword">println</span>(<span class="string">"after transpose:"</span>);</span><br><span class="line">		SeqMatrix tSeqMatrix = seqMatrix.transpose();</span><br><span class="line">		tSeqMatrix.<span class="keyword">print</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		System.out.<span class="keyword">println</span>(<span class="string">"text link matrix"</span>);</span><br><span class="line">		LinkMatrix linkMatrix = <span class="keyword">new</span> LinkMatrix(<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">		linkMatrix.create();</span><br><span class="line">		linkMatrix.<span class="keyword">print</span>();</span><br><span class="line">		System.out.<span class="keyword">println</span>(<span class="string">"after transpose:"</span>);</span><br><span class="line">		LinkMatrix tLinkMatrix = linkMatrix.transpose();</span><br><span class="line">		tLinkMatrix.<span class="keyword">print</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输入和输出如下所示：</p>
<center><img src="/images/matrix.png" alt="smatrix"></center>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong> 多维数组和广义表属于数据结构中非线性结构的基础内容。虽然较线性结构相对复杂，但是，从其递归意义上来说，组成它们的基础也是线性数据结构。本文主要以稀疏矩阵为代表探讨多维数组和广义表数据结构的存储和计算。]]>
    
    </summary>
    
      <category term="数据结构" scheme="http://blog.zbvae.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构-串]]></title>
    <link href="http://blog.zbvae.com/2015/07/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%B2/"/>
    <id>http://blog.zbvae.com/2015/07/20/数据结构-串/</id>
    <published>2015-07-20T07:00:00.000Z</published>
    <updated>2015-08-06T11:45:18.652Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong> 串是一种数据元素类型只能为字符的线性数据结构，可以理解为字符序列。按存储结构也可以分为顺序串和链式串，一般以顺序串为代表，定义在串上的操作，如求串长，判断空串，判断串是否为满，指定位置插入字符，指定位置删除字符，这些操作与线性表中一模一样，所以，有兴趣的读者可以参照本系列博客数据结构-线性表进行阅读。对于串，主要算法有模式匹配，而本文所讲的重点也是串的KMP模式匹配算法。<a id="more"></a></p>
<h2 id="1-串的定义">1.串的定义</h2><p>串是一种类似线性表的线性数据结构，其数据类型只能为字符，下面是顺序串的定义，可以发现与顺序表的定义一模一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeqString</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STRING_SIZE = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">char</span> data[] = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SeqString</span><span class="params">()</span></span>&#123;</span><br><span class="line">		data = <span class="keyword">new</span> <span class="keyword">char</span>[STRING_SIZE];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SeqString</span><span class="params">(<span class="keyword">char</span>[] data)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data = <span class="keyword">new</span> <span class="keyword">char</span>[STRING_SIZE];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;data.length;i++)&#123;</span><br><span class="line">			<span class="keyword">this</span>.insert(i+<span class="number">1</span>, data[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.length;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.length == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.length == STRING_SIZE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">char</span> val)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(pos &lt; <span class="number">1</span> || pos &gt; length+<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.isFull())</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=length-<span class="number">1</span>;i&gt;=pos-<span class="number">1</span>;i--)</span><br><span class="line">			data[i+<span class="number">1</span>] = data[i];</span><br><span class="line">		data[pos-<span class="number">1</span>] = val;</span><br><span class="line">		<span class="keyword">this</span>.length++;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(pos &lt; <span class="number">1</span> || pos &gt; length)</span><br><span class="line">			<span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty())</span><br><span class="line">			<span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">		<span class="keyword">char</span> c = data[pos-<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=pos;i&lt;length;i++)</span><br><span class="line">			data[i-<span class="number">1</span>] = data[i];</span><br><span class="line">		<span class="keyword">this</span>.length--;</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> String(<span class="keyword">this</span>.data,<span class="number">0</span>,<span class="keyword">this</span>.length);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于串的结构类型定义，这里就不再赘述。下面介绍串的模式匹配算法。先以朴素匹配算法作为引例，然后在此基础之上，介绍KMP算法。</p>
<h2 id="2-朴素匹配算法">2.朴素匹配算法</h2><p>串的朴素匹配算法，实现简单，容易理解，也可以认为是一种暴力匹配算法，将主串与模式串中的字符进行一个一个的比对，如果匹配成功，主串与模式串各自递进向前滑动一位，如果匹配失败，那么一切从头来过，模式串重新从0位置开始，主串从下一个位置开始，这里的下一个位置的计算(i-j+1，因为j走了多少，i也走了多少，然后下一个也就是加1)，循环结束条件为模式串匹配完毕，即在主串中找到了所有模式串的字符，或者主串都走完了，还没有找到与模式串匹配的子串，结束匹配，返回-1.</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * [indexOf description]</span><br><span class="line"> * @param  t [mask <span class="type">string</span>]</span><br><span class="line"> * @<span class="constant">return</span>   [<span class="keyword">first</span> pos <span class="keyword">of</span> mask <span class="keyword">in</span> main <span class="type">string</span>]</span><br><span class="line"> */</span><br><span class="line">public int indexOf(SeqString t)&#123;</span><br><span class="line">	SeqString s = this;</span><br><span class="line">	int i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i &lt; s.<span class="property">length</span> &amp;&amp; j &lt; t.<span class="property">length</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s.data[i] == t.data[j])&#123;</span><br><span class="line">			i++;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			j=<span class="number">0</span>;</span><br><span class="line">			i = i-j+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(j == t.<span class="property">length</span>)</span><br><span class="line"><span class="command">		return</span> i-j;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line"><span class="command">		return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-KMP模式匹配算法">3.KMP模式匹配算法</h2><p>上述朴素匹配算法，实现简单，易于理解，但是其时间复杂度时O(m*n)，其中m是主串长度，n是模式串长度。算法的关键在于，当主串中i位置字符与模式串中j位置字符失配时，模式串从0开始，主串也回溯到i-j+1的位置，其实如果充分利用模式串失配位置字符之前的字符序列信息，就可以发现，主串不需要回溯，只需要回溯模式串即可，而且模式串每次回溯的步长可以根据失配位置之前的字符隐含关系来确定，失配位置之前的所有字符如果拥有相同前缀和后缀字符，那么模式串就可以不用回溯到开始位置，而只需要回溯到最长公共前缀的下一个位置即可。这样主串不用回溯，模式串减少回溯的位置，该算法的时间复杂度变为O(m+n)。</p>
<p>Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法。</p>
<h3 id="3-1next_数组的计算">3.1next 数组的计算</h3><p>定义next数组为模式串中每一个字符之前的最长公共前缀后缀的长度。同时定义next[0] = -1。对于给定的模式串：ABCDABD，它的最大长度表及next 数组分别如下：</p>
<center><img src="/images/next.jpg" alt="next"></center>

<p>上图中最大长度值为该字符位置的最长公共前缀与后缀长度，前最大长度值表向右移动一位，并将next[0]赋值为-1就得到了next数组。<strong>模式串next数组的求法是KMP算法中最难理解的部分</strong>。它需要对模式串进行递推搜索：</p>
<blockquote>
<ul>
<li>如果对于值k，已有p0 p1, …, pk-1 = pj-k pj-k+1, …, pj-1，相当于next[j] = k。<blockquote>
<ul>
<li>next[j] = k 代表p[j] 之前的模式串子串中，有长度为k 的相同前缀和后缀</li>
<li>有了这个next 数组，在KMP匹配中，当模式串中j 处的字符失配时，下一步用next[j]处的字符继续跟文本串匹配，相当于模式串向右移动j - next[j] 位。</li>
</ul>
</blockquote>
</li>
<li>递推问题：已知next [0, …, j]，如何求出next [j + 1]呢？<blockquote>
<ul>
<li>若p[k] == p[j]，则next[j + 1 ] = next [j] + 1 = k + 1</li>
<li>若p[k ] ≠ p[j]，如果此时p[ next[k] ] == p[j ]，则next[ j + 1 ] =  next[k] + 1，否则继续递归前缀索引k = next[k]，而后重复此过程。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p>为何递归前缀索引k = next[k]，就能找到长度更小的相同前缀后缀呢?这又归根到next数组的含义。<strong>为了寻找长度相同的前缀后缀，我们拿前缀 p0 pk-1 pk 去跟后缀pj-k pj-1 pj匹配，如果pk 跟pj 失配，下一步就是用p[next[k]] 去跟pj 继续匹配，如果p[ next[k] ]跟pj还是不匹配，则下一步用p[ next[ next[k] ] ]去跟pj匹配。</strong>。相当于在不断的递归k = next[k]，直到要么找到长度更小的相同前缀后缀，要么没有长度更小的相同前缀后缀。</p>
<p>下面这段代码展示了模式串next数组的求法，其中data[k]表示前缀，data[j]表示后缀。</p>
 <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">int</span>[] <span class="keyword">next</span>()&#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">next</span>[] = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">	<span class="keyword">next</span>[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>, k = -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(j &lt; length-<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(k == -<span class="number">1</span> || data[k] == data[j])&#123;</span><br><span class="line">			k++;</span><br><span class="line">			j++;</span><br><span class="line">			<span class="keyword">next</span>[j] = k;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			k = <span class="keyword">next</span>[k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">next</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2KMP算法实现">3.2KMP算法实现</h3><p>有了模式串next数组，再来实现KMP算法就变得简单很多了。KMP算法相对于朴素算法的改进在于，如果模式串在j位置失配，主串无需回溯，模式串每次回溯到next[j]位置。下面是KMP算法的实现代码。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">int</span> indexOf_KMP(SeqString t)&#123;</span><br><span class="line">	SeqString <span class="keyword">s</span> = this;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">next</span>[] = t.getNext();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(i &lt; <span class="keyword">s</span>.<span class="keyword">length</span> &amp;&amp; j &lt; t.<span class="keyword">length</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(j == -<span class="number">1</span> || <span class="keyword">s</span>.data[i] == t.data[j])&#123;</span><br><span class="line">			i++;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			j = <span class="keyword">next</span>[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(j == t.<span class="keyword">length</span>)</span><br><span class="line">		<span class="keyword">return</span> i-j;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3next_数组的优化">3.3next 数组的优化</h3><p>如果用之前的next 数组方法求模式串“abab”的next 数组，可得其next 数组为-1 0 0 1（0 0 1 2整体右移一位，初值赋为-1），当它跟下图中的文本串去匹配的时候，发现b跟c失配，于是模式串右移j - next[j] = 3 - 1 =2位。</p>
<center><img src="/images/next1.jpg" alt="next优化1"></center>

<p>右移2位后，b又跟c失配。事实上，因为在上一步的匹配中，已经得知p.data[3] = b，与s.data[3] = c失配，在3位置失配，由于next[3]=1，而右移两位之后，让p.data[1] = b 再跟s.data[3]匹配时，必然失配。问题出在哪呢？</p>
<center><img src="/images/next2.jpg" alt="next优化2"></center>

<p>问题出在不该出现p.data[j] = p.data[ next[j] ]。为什么呢？理由是：当p.data[j] != s.data[i] 时，下次匹配必然是p.data[ next [j]] 跟s.data[i]匹配，如果p.data[j] = p.data[ next[j] ]，必然导致后一步匹配失败（因为p.data[j]已经跟s.data[i]失配，然后你还用跟p.data[j]等同的值p.data[next[j]]去跟s.data[i]匹配，很显然，必然失配），所以不能允许p.data[j] = p.data[ next[j ]]。如果出现了p.data[j] = p.data[ next[j] ]咋办呢？如果出现了，则需要再次递归，即令next[j] = next[ next[j] ]。</p>
<p>优化后的next数组的求法如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">int</span>[] getNext()&#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">next</span>[] = new <span class="keyword">int</span>[<span class="keyword">length</span>];</span><br><span class="line">	<span class="keyword">next</span>[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>, k = -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(j &lt; <span class="keyword">length</span>-<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="regexp">//already</span> knows <span class="keyword">next</span>[j] = k, how to compute <span class="keyword">next</span>[j+<span class="number">1</span>]</span><br><span class="line">		<span class="keyword">if</span>(k == -<span class="number">1</span> || data[j] == data[k])&#123;</span><br><span class="line">			k++;</span><br><span class="line">			j++;</span><br><span class="line">			<span class="keyword">if</span>(data[j] != data[k])</span><br><span class="line">				<span class="keyword">next</span>[j] = k;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">next</span>[j] = <span class="keyword">next</span>[k];</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			k = <span class="keyword">next</span>[k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">next</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用优化过后的next 数组求法，可知模式串“abab”的新next数组为：-1 0 -1 0。下面这幅图揭示了KMP算法的实际执行过程。</p>
<center><img src="/images/kmp.jpg" alt="KMP算法图示"></center>

<p>上述部分图示和文字来源于 <a href="http://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="external">http://blog.csdn.net/v_july_v/article/details/7041827</a></p>
<h2 id="4-KMP算法的时间复杂度">4.KMP算法的时间复杂度</h2><p>如果文本串的长度为n，模式串的长度为m，那么匹配过程的时间复杂度为O(n)，算上计算next的O(m)时间，KMP的整体时间复杂度为O(m + n)。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong> 串是一种数据元素类型只能为字符的线性数据结构，可以理解为字符序列。按存储结构也可以分为顺序串和链式串，一般以顺序串为代表，定义在串上的操作，如求串长，判断空串，判断串是否为满，指定位置插入字符，指定位置删除字符，这些操作与线性表中一模一样，所以，有兴趣的读者可以参照本系列博客数据结构-线性表进行阅读。对于串，主要算法有模式匹配，而本文所讲的重点也是串的KMP模式匹配算法。]]>
    
    </summary>
    
      <category term="数据结构" scheme="http://blog.zbvae.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构-栈与队列]]></title>
    <link href="http://blog.zbvae.com/2015/07/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>http://blog.zbvae.com/2015/07/20/数据结构-栈与队列/</id>
    <published>2015-07-20T02:49:59.000Z</published>
    <updated>2015-07-20T13:07:36.958Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong> 自上一章讲述了数据结构最基本的内容线性表之后，本章继续讲述线性表的两个特殊现象，但是有着极其重要作用的栈与队列。总而言之，栈与队列是操作受限的线性表，其逻辑定义和存储结构与线性表一模一样，但是定义在其上的操作却有着一定的特殊性。首先，我们只需要了解，栈是一种后进先出结构，而队列则是一种先进先出结构，其它详细信息将在接下来的内容中讲述。<a id="more"></a></p>
<h2 id="1-栈与队列概述">1.栈与队列概述</h2><p>栈属于一种后进先出的结构，只允许在同一端进行插入和删除元素，这一称之为栈顶；而队列属于先进先出的线性结构，只允许在一端插入元素，在另一端删除元素，其中插入元素的一端称之为队尾，删除元素的一端称之为队头。</p>
<p>栈类似于生活中的叠盘子，洗完的盘子，只能从顶部开始叠，要取盘子上菜，也只能从顶部开始一个一个地取，栈的用途非常广泛。栈的应用例子如下：</p>
<blockquote>
<ul>
<li>数制转换（取模）</li>
<li>文本编辑器括号匹配问题{[]},只能是右括号匹配左括号</li>
<li>文本编辑，先存入字符缓冲区（栈），再刷新至文本区</li>
<li>迷宫求解（穷举法，配合回退）</li>
<li>算数表达式求值的算符优先算法</li>
</ul>
</blockquote>
<p>在我们经常使用的递归算法，其底层实现与栈也有着不可分割的关系。队列在操作系统以及线程进程之间的通信都非常重要。</p>
<h2 id="2-栈的实现">2.栈的实现</h2><p>按其存储结构，栈的实现可以划分为顺序栈和链式栈。顺序栈就是操作受限的顺序表，由于栈只有栈顶一端需要不断变化，因此我们在定义栈的结构时，通常定义一个<strong>栈顶指针</strong>便于运算。</p>
<h3 id="2-1顺序栈">2.1顺序栈</h3><p>在顺序栈中，栈顶指针顺序移动，因此类似于数组中的下标，其实顺序栈的底层就是数组。下面是顺序栈的程序示例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeqStack</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STACK_SIZE = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> data[] = <span class="keyword">new</span> <span class="keyword">int</span>[STACK_SIZE];</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> top+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (top == STACK_SIZE-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (top == -<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.isFull())</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		data[++top] = val;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty())</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> data[top--];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上程序示例可以看出，栈相对线性表，其插入和删除元素有着特殊的含义，分别称之为压栈和弹栈操作。在整个操作过程中修改的只是栈底指针的顺序滑动，因此理解起来非常简单。</p>
<h3 id="2-2链栈">2.2链栈</h3><p>使用链式存储结构来表示栈，其底层就不是数组了，而且插入元素的个数也将不受限制，因此没有判断栈是否为满的操作。通常链式存储结构的结点都包含一个数据域和指针域，链栈也一样。定义了链栈结点之后，我们为了定义链，同样由于只有栈顶指针发生变化，我们只需要定义一个栈顶指针结点即可。下面是链式栈的程序示例。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> LinkStack&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">class</span> StackNode&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">		<span class="keyword">private</span> StackNode <span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> StackNode top = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> length()&#123;</span><br><span class="line">		<span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">		StackNode p = top;</span><br><span class="line">		<span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">			length++;</span><br><span class="line">			p = p.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> length;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> isEmpty()&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">this</span>.length() == <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="keyword">push</span>(<span class="keyword">int</span> val)&#123;</span><br><span class="line">		StackNode oldTop = <span class="keyword">this</span>.top;</span><br><span class="line">		StackNode newNode = <span class="keyword">new</span> StackNode();</span><br><span class="line">		newNode.data = val;</span><br><span class="line">		newNode.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">this</span>.top = newNode;</span><br><span class="line">		<span class="keyword">this</span>.top.<span class="keyword">next</span> = oldTop;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">pop</span>()&#123;</span><br><span class="line">		<span class="keyword">int</span> data =  <span class="keyword">this</span>.top.data;</span><br><span class="line">		top = top.<span class="keyword">next</span>;</span><br><span class="line">		<span class="keyword">return</span> data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述程序示例以内部类的形式定义链栈结点，初始化设栈顶指针为空，对应顺序栈中top=-1,进行压栈操作时，需要生成新的栈顶结点，修改栈顶指针指向该位置，修改栈顶指针的next指向上一个栈顶指针位置。</p>
<h2 id="3-队列的实现">3.队列的实现</h2><p>与栈的实现一样，队列也可以分为顺序队列和链式队列。但是对于队列，这里为了简单起见，我只介绍顺序队列，另外还向大家介绍一种特殊的顺序队列即循环队列。队列在插入元素的时候，只能在队尾插入，因此需要定义一个队尾指针不断地移动来插入元素；另外在删除元素的时候，只能在队头删除，因此还需要定义一个队头指针向后移动来删除元素。</p>
<h3 id="3-1顺序队列">3.1顺序队列</h3><p>在顺序队列中，这两个指针也类似于数组的下标。<strong>其中队头指针front始终指向队头元素，即队列中的第一个元素，队尾指针rear始终指向队尾元素的下一个元素</strong>下面是顺序队列的程序示例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeqQueue</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_SIZE = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> data[] = <span class="keyword">new</span> <span class="keyword">int</span>[QUEUE_SIZE];</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> rear = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> rear-front;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (front == rear);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (rear == QUEUE_SIZE-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.isFull())</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		data[rear++] = val;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty())</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> data[front++];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上顺序队列的程序示例，也可以看出，队列相对于线性表，其插入和删除操作也有着特殊的定义，分别称之为入队和出队。当队头和队尾指针相等的时候，队列为空。另外，由于在插入元素的时候，队尾指针不断向后移动直至最大位置，删除元素的时候，队头指针也是不断向后移动追赶队尾指针，由于移动方向一样，这就造成了，队尾指针已经到达最大位置，但实际上只包含几个元素，也就是一种<strong>假上溢</strong>现象，即队列空间并没有好好利用，为了克服队列的<strong>假上溢</strong>现象，引入循环队列的概念，下面为大家介绍循环队列。</p>
<h3 id="3-2循环队列">3.2循环队列</h3><p>循环队列为了克服假上溢现象，定义插入和删除的规则为，队尾指针和队头指针并不只是一直向后移动达到最大位置就停止，而是到达最大位置之后，队列的第一个位置为空，队尾指针又可以循环到队列的第一个位置开始插入，队头指针在删除元素的时候也一样。这里的移动队头和队尾指针就不仅仅是加1操作，而是加1之后对队列大小进行取模，而且，这种情况下，front==rear并不能判断队列是空还是满，因此定义在插入元素的时候如果满足(rear+1)%QUEUE_SIZE == front，即认为队满，也就是少用一个元素的空间。下面是循环队列的程序示例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CirQueue</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_SIZE = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> data[] = <span class="keyword">new</span> <span class="keyword">int</span>[QUEUE_SIZE];</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> rear = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rear &gt; front)</span><br><span class="line">			<span class="keyword">return</span> (rear-front)%QUEUE_SIZE;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> (QUEUE_SIZE-front)+rear;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> rear == front;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (rear+<span class="number">1</span>)%QUEUE_SIZE == front;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.isFull())</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		data[rear] = val;</span><br><span class="line">		rear = (rear+<span class="number">1</span>)%QUEUE_SIZE;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty())</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> val = data[front];</span><br><span class="line">		front = (front+<span class="number">1</span>)%QUEUE_SIZE;</span><br><span class="line">		<span class="keyword">return</span> val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-栈与递归的关系">4.栈与递归的关系</h2><p>最后讲述一下，递归操作时，栈的作用：</p>
<ul>
<li><p>调用函数时：系统将会为调用者构造一个由参数表和返回地址组成的活动记录，并将其压入到由系统提供的运行时刻栈的栈顶，然后将程序的控制权转移到被调函数。若被调函数有局部变量，则在运行时刻栈的栈顶也要为其分配相应的空间。因此，活动记录和这些局部变量形成了一个可供被调函数使用的活动结构。</p>
</li>
<li><p>被调函数执行完毕时：系统将运行时刻栈栈顶的活动结构退栈，并根据退栈的活动结构中所保存的返回地址将程序的控制权转移给调用者继续执行。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong> 自上一章讲述了数据结构最基本的内容线性表之后，本章继续讲述线性表的两个特殊现象，但是有着极其重要作用的栈与队列。总而言之，栈与队列是操作受限的线性表，其逻辑定义和存储结构与线性表一模一样，但是定义在其上的操作却有着一定的特殊性。首先，我们只需要了解，栈是一种后进先出结构，而队列则是一种先进先出结构，其它详细信息将在接下来的内容中讲述。]]>
    
    </summary>
    
      <category term="数据结构" scheme="http://blog.zbvae.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构-线性表]]></title>
    <link href="http://blog.zbvae.com/2015/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://blog.zbvae.com/2015/07/19/数据结构-线性表/</id>
    <published>2015-07-19T07:13:34.000Z</published>
    <updated>2015-08-06T11:19:26.463Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong> 从本篇开始，将为大家带来数据结构的系列博客，也许我所介绍的内容包含的不是很全，但相信一定是最容易理解的，有兴趣的读者可以对本人的博客进行跟踪学习。数据结构简而言之，<strong>数据结构是一门描述数据之间逻辑关系和解决数据在计算机中的存储问题，以及定义在这些存储结构上的操作的集合，这些操作集也可以称之为算法，狭义上的数据结构只是指的是数据之间的逻辑结构和物理存储结构，广义上的数据结构还包含算法的定义。</strong> 从逻辑关系上，数据结构又可以分为线性结构和非线性结构，而线性表则是线性结构中最基础的内容，下面本文将系统介绍数据结构的线性表的内容。<a id="more"></a></p>
<h2 id="1-线性表概述">1.线性表概述</h2><p>线性表是线性结构最基本的内容，那么何为线性结构和非线性结构呢？这需要从数据的逻辑关系上来区分，首先，把数据之间的逻辑关系概括为：每一个数据元素至多包含一个直接前驱和一个直接后继，有且仅有一个数据元素只有一个直接后继，没有直接前驱称之为开始结点，有且仅有一个只有一个直接前驱没有直接后继的数据元素称之为终端结点。非线性结构就是数据元素有多个直接前驱和直接后继。</p>
<h2 id="2-线性表分类">2.线性表分类</h2><p>前面介绍线性表的逻辑关系，那么从存储上，又可以将线性表分为顺序表和链接表，为求简单起见，本文只介绍顺序表和单链表。顺序表指的是逻辑上相邻的数据元素物理上也相邻，是一种随机存取结构，即节点的位置是其下标的线性函数，顺序表便于查找，但不利于插入和删除；单链表指的是逻辑上相邻的数据元素物理上不一定相邻，是一种顺序存取结构，即要得到某一节点的位置，必须从开始节点起顺序往后遍历，因此不利于查找，但是易于插入和删除(只需要修改指针或引用即可)。</p>
<h2 id="3-顺序表解析">3.顺序表解析</h2><h3 id="3-1顺序表属性操作解析">3.1顺序表属性操作解析</h3><p>顺序表的底层就是数组，因此可以用数组来模拟顺序表。顺序表的属性包含：</p>
<ul>
<li>最多可以容纳的数据元素的个数；</li>
<li>当前元素个数；</li>
<li>存放这些数据元素的数组。</li>
</ul>
<p>其操作包含：</p>
<ul>
<li>求长度；</li>
<li>判断是否为空；</li>
<li>判断是否为满</li>
<li>指定位置插入元素；</li>
<li>指定位置删除元素。</li>
</ul>
<p>下面是顺序表的实现结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeqList</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIST_SIZE = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> data[] = <span class="keyword">new</span> <span class="keyword">int</span>[LIST_SIZE];</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SeqList</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.length;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">this</span>.length == <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">this</span>.length == LIST_SIZE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * [insert description]</span><br><span class="line">	 * <span class="doctag">@param</span>  pos [insert pos, start from 1 to length]</span><br><span class="line">	 * <span class="doctag">@param</span>  val [insert value]</span><br><span class="line">	 * <span class="doctag">@return</span>     [insert successfully or not]</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">		<span class="comment">//judge if the pos is correct</span></span><br><span class="line">		<span class="keyword">if</span>(pos &lt; <span class="number">1</span> || pos &gt; length+<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="comment">//judge if the list is full</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.isFull())</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=length-<span class="number">1</span>;i&gt;=pos-<span class="number">1</span>;i--)&#123;</span><br><span class="line">			data[i+<span class="number">1</span>] = data[i];</span><br><span class="line">		&#125;</span><br><span class="line">		data[pos-<span class="number">1</span>] = val;</span><br><span class="line">		<span class="keyword">this</span>.length++;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * [delete description]</span><br><span class="line">	 * <span class="doctag">@param</span>  pos [delete pos, start from 1 to length]</span><br><span class="line">	 * <span class="doctag">@return</span>     [delete value]</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">		<span class="comment">//judge if the pos is correct</span></span><br><span class="line">		<span class="keyword">if</span>(pos &lt; <span class="number">1</span> || pos &gt; length)</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		<span class="comment">//judge if the list is empty</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty())</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> val = data[pos-<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=pos;i&lt;length;i++)&#123;</span><br><span class="line">			data[i-<span class="number">1</span>] = data[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.length--;</span><br><span class="line">		<span class="keyword">return</span> val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2顺序表主要函数解析">3.2顺序表主要函数解析</h3><p>类似于求长度和判断是空还是满的函数比较简单，这里就不做过多分析。对于指定位置插入和删除元素，分析如下：</p>
<p>首先是插入元素</p>
<blockquote>
<ul>
<li>首先肯定要判断插入位置pos,注意虽然数组下标是从0开始的，但是这里的pos却是从1开始的，一定要注意区分。</li>
<li>pos &lt; 1 || pos &gt; length+1 这些位置都是不合格的，显然插入位置小于1肯定不合格，为什么大于length+1才不合格呢，等于length+1难道合格吗，这时候顺序表里只有length个元素，我们当然可以插入最后一个元素的后面一个。</li>
<li>插入位置合格的情况下，还要判断表是否已经满了，因为顺序表有空间限制，如果表满，将不能再执行插入操作。</li>
<li>以上两个条件都满足，就可以进行插入了，要插入的位置是pos,即对于顺序表下标为pos-1的元素，那么对于顺序表中的元素，我们要把下标为pos-1到length-1位置的所有元素统统向右移动一位。</li>
<li>具体移动操作的时候，循环要从后面开始，目的是防止元素覆盖，丧失原始值的情况</li>
<li>全部移动工程结束的时候，直接把要插入的val赋值到pos-1的位置即可，注意一定要将表长加1，这是很容易遗忘的</li>
</ul>
</blockquote>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="comment">//judge if the pos is correct</span></span><br><span class="line">	<span class="keyword">if</span>(pos &lt; <span class="number">1</span> || pos &gt; length+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">//judge if the list is full</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>.isFull())</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=length-<span class="number">1</span>;i&gt;=pos-<span class="number">1</span>;i--)&#123;</span><br><span class="line">		data[i+<span class="number">1</span>] = data[i];</span><br><span class="line">	&#125;</span><br><span class="line">	data[pos-<span class="number">1</span>] = val;</span><br><span class="line">	<span class="keyword">this</span>.length++;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于顺序表删除元素，其分析也是一样的：</p>
<blockquote>
<ul>
<li>首先判断删除位置是否合法，删除位置的元素一定要存在才行，pos还是从1开始的</li>
<li>pos &lt; 1 || pos &gt; length 都是不合法的，注意这里pos不是大于length+1而是大于length因为，删除的元素一定要存在。</li>
<li>删除之前还要判断表是否为空，如果表空，则没有元素可删</li>
<li>要删除pos位置的元素，即对应表中下标为pos-1的元素，首先将该位置元素保存起来，为了返回。</li>
<li>还要做的一件事就是将下标从pos到length-1位置的所有元素统统向前移动一位。循环从pos开始同样是为了避免元素覆盖丧失原始值的情况发生。</li>
<li>删除元素之后，需要将表长减1.<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">int</span> <span class="keyword">delete</span>(<span class="keyword">int</span> <span class="keyword">pos</span>)&#123;</span><br><span class="line">	<span class="regexp">//judge</span> <span class="keyword">if</span> the <span class="keyword">pos</span> is correct</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">pos</span> &lt; <span class="number">1</span> || <span class="keyword">pos</span> &gt; <span class="keyword">length</span>)</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="regexp">//judge</span> <span class="keyword">if</span> the list is empty</span><br><span class="line">	<span class="keyword">if</span>(this.isEmpty())</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> val = data[<span class="keyword">pos</span>-<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="keyword">pos</span>;i&lt;<span class="keyword">length</span>;i++)&#123;</span><br><span class="line">		data[i-<span class="number">1</span>] = data[i];</span><br><span class="line">	&#125;</span><br><span class="line">	this.<span class="keyword">length</span>--;</span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h2 id="4-单链表解析">4.单链表解析</h2><h3 id="4-1单链表属性操作解析">4.1单链表属性操作解析</h3><p>单链表属于链式存储结构，由于每个逻辑相邻的数据元素之间物理位置不一定相邻，因此结点除了存放数据之外，还要额外存放一个指向其后继结点的指针或引用，这里的指针或引用都是后继元素的内存地址。这里的数据结点我们用一个内部类表示。为了便于操作，通常声明一个实际上不存在的结点指向开始结点，即头结点。单链表的属性包含：</p>
<ul>
<li>头结点</li>
<li>表中元素个数</li>
</ul>
<p>单链表操作包含：</p>
<ul>
<li>求表长；</li>
<li>判断单链表是否为空；</li>
<li>指定位置插入元素；</li>
<li>指定位置删除元素。</li>
</ul>
<p>可能有人会问为什么没有判断表是否为满的操作，因为链式存储结构属于动态内存分配，因此不存在表满的情况，如果出现，说明内存已经用完了。下面是单链表的实现结构。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> LinkList&#123;</span><br><span class="line">	<span class="keyword">private</span> LinkNode head = <span class="keyword">new</span> LinkNode();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">class</span> LinkNode&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">private</span> LinkNode <span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> LinkList()&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> length()&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.length;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> isEmpty()&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">this</span>.length == <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * [insert description]</span><br><span class="line">	 * @param  pos [the pos you want to insert value]</span><br><span class="line">	 * @param  val [insert value]</span><br><span class="line">	 * @return     [if insert successfully or not]</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> insert(<span class="keyword">int</span> pos, <span class="keyword">int</span> val)&#123;</span><br><span class="line">		<span class="keyword">if</span>(pos &lt; <span class="number">1</span> || pos &gt; <span class="keyword">this</span>.length+<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">		LinkNode s = <span class="keyword">new</span> LinkNode();</span><br><span class="line">		s.data = val;</span><br><span class="line">		s.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(head.<span class="keyword">next</span> == <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">			head.<span class="keyword">next</span> = s;</span><br><span class="line">			<span class="keyword">this</span>.length = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		LinkNode p = head;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;pos-<span class="number">1</span>;i++)</span><br><span class="line">			p = p.<span class="keyword">next</span>;</span><br><span class="line">		<span class="keyword">if</span>(i == pos-<span class="number">1</span>)&#123;</span><br><span class="line">			s.<span class="keyword">next</span> = p.<span class="keyword">next</span>;</span><br><span class="line">			p.<span class="keyword">next</span> = s;</span><br><span class="line">			<span class="keyword">this</span>.length++;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * [delete description]</span><br><span class="line">	 * @param  pos [delete pos]</span><br><span class="line">	 * @return     [delete value]</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">delete</span>(<span class="keyword">int</span> pos)&#123;</span><br><span class="line">		<span class="keyword">if</span>(pos &lt; <span class="number">1</span> || pos &gt; <span class="keyword">this</span>.length)</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty())</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		LinkNode p = head;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;pos-<span class="number">1</span>;i++)&#123;</span><br><span class="line">			p = p.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(i == pos-<span class="number">1</span>)&#123;</span><br><span class="line">			val = p.<span class="keyword">next</span>.data;</span><br><span class="line">			p.<span class="keyword">next</span> = p.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.length--;</span><br><span class="line">		<span class="keyword">return</span> val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2单链表主要函数解析">4.2单链表主要函数解析</h3><p>同样对插入和删除操作进行解析如下：</p>
<p>首先对于单链表插入元素：</p>
<blockquote>
<ul>
<li>判断插入位置与顺序表是一致的</li>
<li>生成新节点，需要动态分配内存</li>
<li>此时如果开始结点为空，即头结点的下一个结点，将新生成的节点作为开始结点，并返回true</li>
<li>开始结点不为空，顺序找到插入位置pos，循环之前工作结点赋值为头结点，借助循环从0开始步增到pos-2,开始结点对应下标0，那么随着循环的步进，p = p.next,循环进行到pos-2,工作结点p也到达了要插入位置的前一个结点。</li>
<li>循环结束，此时i=pos-1,p到达要插入位置的前一个结点，修改指针链接关系，新节点的next指向p的next,注意此时p的next即为pos-1位置的节点，这样相当于将pos-1位置的节点向后推移了一位，接着修改p的next指向新节点</li>
<li>表长加1，完成插入。</li>
</ul>
</blockquote>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> insert(<span class="keyword">int</span> pos, <span class="keyword">int</span> val)&#123;</span><br><span class="line">	<span class="keyword">if</span>(pos &lt; <span class="number">1</span> || pos &gt; <span class="keyword">this</span>.length+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	LinkNode s = <span class="keyword">new</span> LinkNode();</span><br><span class="line">	s.data = val;</span><br><span class="line">	s.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(head.<span class="keyword">next</span> == <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">		head.<span class="keyword">next</span> = s;</span><br><span class="line">		<span class="keyword">this</span>.length = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	LinkNode p = head;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;pos-<span class="number">1</span>;i++)</span><br><span class="line">		p = p.<span class="keyword">next</span>;</span><br><span class="line">	<span class="keyword">if</span>(i == pos-<span class="number">1</span>)&#123;</span><br><span class="line">		s.<span class="keyword">next</span> = p.<span class="keyword">next</span>;</span><br><span class="line">		p.<span class="keyword">next</span> = s;</span><br><span class="line">		<span class="keyword">this</span>.length++;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于单链表删除操作：</p>
<blockquote>
<ul>
<li>同样需要先判断删除位置是否合理，与顺序表一致</li>
<li>接着判断表是否为空，如果为空，直接返回</li>
<li>顺序找到要删除位置的前一个位置pos-2</li>
<li>先保存要删除位置的数据val = p.next.data;</li>
<li>直接将pos-1位置的结点摘链，具体实现通过p.next = p.next.next;注意此时p为pos-2位置的结点</li>
<li>表长减1，返回被删元素数据，完成删除。</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong> 从本篇开始，将为大家带来数据结构的系列博客，也许我所介绍的内容包含的不是很全，但相信一定是最容易理解的，有兴趣的读者可以对本人的博客进行跟踪学习。数据结构简而言之，<strong>数据结构是一门描述数据之间逻辑关系和解决数据在计算机中的存储问题，以及定义在这些存储结构上的操作的集合，这些操作集也可以称之为算法，狭义上的数据结构只是指的是数据之间的逻辑结构和物理存储结构，广义上的数据结构还包含算法的定义。</strong> 从逻辑关系上，数据结构又可以分为线性结构和非线性结构，而线性表则是线性结构中最基础的内容，下面本文将系统介绍数据结构的线性表的内容。]]>
    
    </summary>
    
      <category term="数据结构" scheme="http://blog.zbvae.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[八皇后问题]]></title>
    <link href="http://blog.zbvae.com/2015/07/18/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.zbvae.com/2015/07/18/八皇后问题/</id>
    <published>2015-07-18T12:00:22.000Z</published>
    <updated>2015-07-18T13:02:37.095Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong> 八皇后问题是一个古老而著名的问题，是回溯算法的经典问题。该问题由高斯提出：在8*8的国际象棋上摆放8个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行，同一列或同一斜线上，问总共有多少种摆法。现代数学中，把八皇后问题当成一个经典的递归算法例题。<a id="more"></a></p>
<h2 id="1-回溯法">1.回溯法</h2><p>下面我们尝试用回溯法解决八皇后问题。回溯法实际上是一个类似枚举的搜索尝试过程。用回溯法解决问题的一般步骤是：</p>
<ol>
<li>针对所给问题，确定问题的解空间</li>
<li>确定结点的扩展搜索空间</li>
<li>以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</li>
</ol>
<h2 id="2-八皇后问题求解">2.八皇后问题求解</h2><p>从以上三点，来阐述八皇后问题的求解。从问题的定义出发，可以分析出八皇后问题可以归结为：八个皇后之间满足以下关系：</p>
<ul>
<li>不在同一行</li>
<li>不在同一列</li>
<li>不在同一斜线上</li>
<li>不在同一反斜线上</li>
</ul>
<p>针对回溯法的一般步骤，我们需要先确定解空间。从列的方向进行回溯（选择列向还是行向按自己习惯，思路一样），对于某一列col，我们确定解空间即为，当前列，八皇后能摆放的位置，即能摆放在哪一行。对于当前列能摆放在哪一行的问题，需要参考前面的列所摆放的位置，具体分析如下：</p>
<p>如果当前列col=3，第2列摆放的皇后位置为第5行，那么我们可以确定第3列一定不能摆放的位置有：第5行，第6行和第4行，因为首先不能和第2列摆在同一行，所以一定不能摆在第5行，其次不能摆在与前一列第5行所在的斜线位置即第6行，再其次也不能摆在与前一列第5行所在的反斜线位置上，即不能摆在第4行。这只是根据第2列的摆放位置来确定的局部解，还要根据第1列的摆放情况，才能最终确定第3列的皇后能摆放的位置，即当前的解空间。那么确定当前解空间可以归纳为以下算法：</p>
<blockquote>
<p>我们用rows数组表示当前列所能放置的行的位置，rows是一个大小为8的boolean数组，rows[i]=false表示当前列第i行不能摆放，初始化下为所有行都能摆放即为true。另外我们用cols数组表示每一列棋子摆放的行数，如以上第2列摆放在第5行可以表示为cols[2]=5。在确定解空间的过程中，我们就是要根据当前列之前的所有列的cols来确定当前列的摆放位置。</p>
<ul>
<li>前1列摆放位置为第5行，那么当前不能摆放的行有：5,5+1,5-1</li>
<li>前i列摆放位置为第row行，那么当前不能摆放的行有：row,row+i(row+i<8),row-i(row-i>=0)</8),row-i(row-i></li>
</ul>
</blockquote>
<p>以下函数就是根据当前列号以及当前cols数组确定当前列可以摆放的行的位置：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * [getAccessRows description]</span><br><span class="line"> * <span class="doctag">@param</span>  cols [array of every row num of queen in each col]</span><br><span class="line"> * <span class="doctag">@param</span>  col  [current col]</span><br><span class="line"> * <span class="doctag">@return</span>      [current col can be placed in which rows]</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span>[] getAccessRows(<span class="keyword">int</span>[] cols, <span class="keyword">int</span> col)&#123;</span><br><span class="line">	<span class="keyword">boolean</span> rows[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[QUEEN_NUM];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;QUEEN_NUM;i++)&#123;</span><br><span class="line">		rows[i] = <span class="keyword">true</span>;<span class="comment">// all rows can be placed</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;col;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> row = cols[i];</span><br><span class="line">		<span class="keyword">int</span> d = col - i;<span class="comment">// forward d col</span></span><br><span class="line">		rows[row] = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span>((row+d) &lt; QUEEN_NUM)</span><br><span class="line">			rows[row+d] = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span>((row-d) &gt;= <span class="number">0</span>)</span><br><span class="line">			rows[row-d] = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> rows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了当前列可以摆放的行位置数组，即确定了当前解空间，依据回溯法，确定扩展搜索空间，选的当前列的某一行作为当前最优解，进行深度优先搜索，回溯下一列能摆放的位置，直到确定所有列的摆放位置，即得到一组解，下面给出从当前列出发进行回溯的代码作为参考：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * [solveEightQueen description]</span><br><span class="line"> * <span class="doctag">@param</span> cols[] [array of row num of each col]</span><br><span class="line"> * <span class="doctag">@param</span> col    [current col]</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">solveEightQueen</span><span class="params">(<span class="keyword">int</span> cols[], <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> rows[] = getAccessRows(cols, col);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>; row&lt;QUEEN_NUM; row++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(rows[row] == <span class="keyword">false</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		cols[col] = row;</span><br><span class="line">		<span class="keyword">if</span>(col == QUEEN_NUM - <span class="number">1</span>)</span><br><span class="line">			result_num++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			solveEightQueen(cols, col+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在主函数中从第0列开始进行回溯，可以得到共有92组解。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> result_num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> QUEEN_NUM = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)&#123;</span><br><span class="line">	<span class="built_in">int</span> cols[] = <span class="keyword">new</span> <span class="built_in">int</span>[QUEEN_NUM];</span><br><span class="line">	solveEightQueen(cols, <span class="number">0</span>);</span><br><span class="line">	System.out.<span class="built_in">println</span>(result_num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-总结">3.总结</h2><p>从以上代码，可以发现回溯法可以轻松解决复杂的八皇后问题，回溯法的解决关键在于深度优先递归搜索。我们可以将问题规模改为任意，即10皇后也可以适用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong> 八皇后问题是一个古老而著名的问题，是回溯算法的经典问题。该问题由高斯提出：在8*8的国际象棋上摆放8个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行，同一列或同一斜线上，问总共有多少种摆法。现代数学中，把八皇后问题当成一个经典的递归算法例题。]]>
    
    </summary>
    
      <category term="技术交流" scheme="http://blog.zbvae.com/tags/%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java NIO 学习]]></title>
    <link href="http://blog.zbvae.com/2015/07/12/Java-NIO-%E5%AD%A6%E4%B9%A0/"/>
    <id>http://blog.zbvae.com/2015/07/12/Java-NIO-学习/</id>
    <published>2015-07-12T11:28:58.000Z</published>
    <updated>2015-08-10T09:15:33.527Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：传统IO是通过流的形式建立内存与外设之间的传输。而NIO则以通道和缓存的方式实现新的数据传输方式以解决传统IO的一些不足，NIO产生自JDK1.4，使用NIO代替传统IO会大大提高数据传输效率，掌握Java NIO的基本知识和使用方法也是对传统IO的一种补充，是一种同步非阻塞IO模式。<a id="more"></a></p>
<h2 id="1-NIO概述">1.NIO概述</h2><p>Java NIO产生自JDK1.4，主要由以下几个部分组成：</p>
<ul>
<li>Channel    双向交流的通道</li>
<li>Buffer    缓冲区，包含数据且用于读写的线性表结构</li>
<li>Charset    字符集，提供Unicode字符串映射到字节序列以及逆映射的操作，解决字符编码与解码的问题</li>
<li>Selector    选择器，将多元异步IO操作集中到一个或多个线程中</li>
</ul>
<p>NIO中的通道有点类似于传统IO中的流，首先建立好连接外设的通道，数据可以从Channel读入到Buffer,也可以从Buffer写入Channel进而流向外设。Channel是接口，而Buffer是抽象类，Java NIO中Channel的主要实现包括：</p>
<ul>
<li>FileChannel    文件通道</li>
<li>DatagranChannel        UAP数据包通道</li>
<li>SocketChannel     TCP客户端通道</li>
<li>ServerSocketChannel    TCP服务器端通道</li>
</ul>
<p>Buffer的实现主要包括：</p>
<ul>
<li>ByteBuffer     </li>
<li>CharBuffer     </li>
<li>DoubleBuffer    </li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
<li>MappedByteBuffer</li>
</ul>
<p>Selector允许单线程处理多个Channel，如果你的应用打开了多个连接(通道)，但每个连接的流量都很低，使用Selector就很方便。</p>
<h2 id="2-Channel_和_Buffer_的使用">2.Channel 和 Buffer 的使用</h2><p>Channel 的实例化是从传统IO流当中获取的，也可以从RandomAccessFile类获取，因为该类集成了InputStream和OutputStream。Buffer的实例化，主要是针对其实现类ByteBuffer，IntBuffer等：</p>
<ul>
<li>FileChannel fc = new FileInputStream(new File(“./src.txt”)).getChannel();</li>
<li>FileChannel fc = new RandomAccessFile(“./src.txt”,”rw”).getChannel();</li>
<li>ByteBuffer buf = ByteBuffer.allocate(1024); 表示分配1024个字节的缓冲区</li>
<li>ByteBuffer buf = ByteBuffer.wrap(new String(“hello”).getBytes()); //指定缓冲区包裹字符串流，且内容初始化为字符串</li>
</ul>
<p>以下展示一个基本的文件拷贝的例子来展示Channel和Buffer的使用。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> copyFile(<span class="keyword">File</span> srcFile, <span class="keyword">File</span> desFile)&#123;</span><br><span class="line">	FileChannel inChannel = <span class="keyword">null</span>;</span><br><span class="line">	FileChannel outChannel = <span class="keyword">null</span>;</span><br><span class="line">	ByteBuffer buf = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		inChannel = <span class="keyword">new</span> FileInputStream(srcFile).getChannel();</span><br><span class="line">		outChannel = <span class="keyword">new</span> FileOutputStream(desFile).getChannel();</span><br><span class="line">		buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">		<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((len = inChannel.<span class="keyword">read</span>(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">			buf.flip();</span><br><span class="line">			outChannel.<span class="keyword">write</span>(buf);</span><br><span class="line">			outChannel.force(<span class="keyword">true</span>);</span><br><span class="line">			buf.clear();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			outChannel.close();</span><br><span class="line">			inChannel.close();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>buf.flip()用来反转buf,将buf从写模式切换到读模式，先从通道中读取数据到buf，然后反转，从buf中写入数据到通道，进而输出到外设，FileChannel 的force方法强制将缓冲区的内容全部写进文件，类似于传统IO中的flush方法。</p>
<h2 id="3-Buffer_详解">3.Buffer 详解</h2><h3 id="3-1Buffer的基本使用步骤">3.1Buffer的基本使用步骤</h3><p>Buffer的使用一般遵循以下步骤：</p>
<ol>
<li>从Channel中读取数据到Buffer;</li>
<li>调用flip()方法反转Buffer;</li>
<li>从Buffer中写入数据到Channel;</li>
<li>调用clear()方法清空缓冲区.</li>
</ol>
<h3 id="3-2Buffer的基本属性">3.2Buffer的基本属性</h3><p>Buffer的基本属性包括：<em>capacity</em>，<em>position</em>，<em>limit</em>。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>写模式</th>
<th style="text-align:left">读模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>capacity</td>
<td>Buffer的容量</td>
<td style="text-align:left">Buffer的容量</td>
</tr>
<tr>
<td>position</td>
<td>当前写入单位数据的数量</td>
<td style="text-align:left">当前读入的单位数据的数量</td>
</tr>
<tr>
<td>limit</td>
<td>最多能写入多少单位的数据量，默认和capacity一致</td>
<td style="text-align:left">代表最多能读入多少单位的数据量，和之前写入的数据量一致</td>
</tr>
</tbody>
</table>
<h3 id="3-3Buffer的分配和模式切换">3.3Buffer的分配和模式切换</h3><p>前面已经提及，Buffer的分配方式主要有两种，一种是allocate分配指定字节大小的内存区；另一种则是通过已有的字节数组来分配：wrap(字节数组).flip方法用于反转，表示将写模式切换到读模式，positon设为0，limit设置成之前写入到Buffer的数据量。</p>
<h2 id="4-文件锁定">4.文件锁定</h2><p>FileChannel提供两种方法获得FileLock：</p>
<ol>
<li>FileLock lock();</li>
<li>FileLock lock(long position, long size, boolean shared);</li>
</ol>
<p>要获取文件一部分上的锁，需要调用FileChannel的第二种lock方法，如果要获取一个排他锁，必须以写方式打开文件。在拥有锁之后，您可以执行需要的任何敏感操作，然后再释放锁。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile aFile = new RandomAccessFile(<span class="string">"./src.txt"</span>,<span class="string">"rw"</span>);</span><br><span class="line">FileChannel fc = aFile.getChannel();</span><br><span class="line">FileLock lock = fc.lock(position, size, false);</span><br><span class="line">//operations on <span class="keyword">locked</span> region</span><br><span class="line">lock.release();</span><br></pre></td></tr></table></figure>
<h2 id="5-Scatter/Gather">5.Scatter/Gather</h2><p>Scatter是指将Channel中的数据分散读入到多个Buffer中；Gather是指将多个Buffer数据聚合写入到Channel中。读取和写入的时候都是按顺序写入或读取到Buffer中。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//Scatter</span><br><span class="line"><span class="keyword">ByteBuffer </span>header = <span class="keyword">ByteBuffer.allocate(128);</span><br><span class="line"></span><span class="keyword">ByteBuffer </span><span class="keyword">body </span>= <span class="keyword">ByteBuffer.allocate(1024);</span><br><span class="line"></span><span class="keyword">ByteBuffer </span><span class="keyword">bufferArray[] </span>= &#123;header, <span class="keyword">body&#125;;</span><br><span class="line"></span><span class="label">channel.read</span>(<span class="keyword">bufferArray);</span><br><span class="line"></span></span><br><span class="line">//Gather</span><br><span class="line"><span class="keyword">ByteBuffer </span>header = <span class="keyword">ByteBuffer.allocate(128);</span><br><span class="line"></span><span class="keyword">ByteBuffer </span><span class="keyword">body </span>= <span class="keyword">ByteBuffer.allocate(1024);</span><br><span class="line"></span><span class="keyword">ByteBuffer </span><span class="keyword">bufferArray[] </span>= &#123;header, <span class="keyword">body&#125;;</span><br><span class="line"></span><span class="label">channel.write</span>(<span class="keyword">bufferArray);</span></span><br></pre></td></tr></table></figure>
<h2 id="5-Selector与Channel的搭配使用">5.Selector与Channel的搭配使用</h2><p>Selector允许单线程管理多个通道，通过Selector.open方法可以创建一个Selector对象。为了使Selector能够管理多个通道，需要将这些通道注册到Selector上。需要注意的是<strong>与Selector一起使用的时候，Channel必须处于非阻塞模式下</strong>，由于FileChannel不能切换到非阻塞模式，所以不能被Selector管理，套接字通道都可以。注册通道的register方法有两个参数，第一个是要注册的Selector对象，第二个参数实际上是一个interest集，涵盖要监听的事件类型。该方法返回SelectionKey对象，该对象包含了你感兴趣的属性：</p>
<ul>
<li>interest集合    感兴趣的事件集合</li>
<li>ready集合    已准备的就绪操作集合</li>
<li>Selector和Channel    从SelectionKey访问Selector和Channel变得非常简单，直接key.selector()和key.channel()。</li>
</ul>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open<span class="params">()</span>;</span><br><span class="line">InetSocketAddress socketAddress = new InetSocketAddress<span class="params">(“www.baidu.com”,<span class="number">80</span>)</span>;</span><br><span class="line">SocketChannel sc = SocketChannel.open<span class="params">(socketAddress)</span>;</span><br><span class="line">sc.configureBlocking<span class="params">(<span class="literal">false</span>)</span>;</span><br><span class="line">SelectionKey key = channel.register<span class="params">(selector, SelectionKey.OP_CONNECT)</span>;</span><br><span class="line">while<span class="params">(<span class="literal">true</span>)</span>&#123;</span><br><span class="line">	int readyChannels = selector.select<span class="params">()</span>;</span><br><span class="line">	<span class="keyword">if</span><span class="params">(readyChannels == <span class="number">0</span>)</span> continue;</span><br><span class="line">	Set selectedKeys = selector.selectedKeys<span class="params">()</span>;</span><br><span class="line">	Iterator iter = selectedKeys.iterator<span class="params">()</span>;</span><br><span class="line">	while<span class="params">(iter.hasNext<span class="params">()</span>)</span>&#123;</span><br><span class="line">		SelectionKey key = iter.next<span class="params">()</span>;</span><br><span class="line">		<span class="keyword">if</span><span class="params">(key.isAcceptable<span class="params">()</span>)</span>&#123;</span><br><span class="line">			<span class="comment">//a connection was accepted by a ServerSocketChannel</span></span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span><span class="params">(key.isConnectable<span class="params">()</span>)</span>&#123;</span><br><span class="line">			<span class="comment">//a connection was established with a remote server</span></span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span><span class="params">(key.isReadable<span class="params">()</span>)</span>&#123;</span><br><span class="line">			<span class="comment">//a channel is ready for reading</span></span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span><span class="params">(key.isWritable<span class="params">()</span>)</span>&#123;</span><br><span class="line">			<span class="comment">//a channel is ready for writing</span></span><br><span class="line">		&#125;</span><br><span class="line">		iter.remove<span class="params">()</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-综合案例">6.综合案例</h2><p>接下来的这个案例综合Java NIO，多线程，字符串，正则表达式以及Java类集的使用。该案例的问题背景如下：</p>
<blockquote>
<p>统计一个单词可重复的英文文件（假设4G）中每个单词出现的次数，输出出现最多单词的次数以及这些单词（可能有多个），并把所有单词出现次数结果按照英文排序放入一个文件中。并能够检索特定单词的出现次数。由于文件过大，不重复单词总数有限，需要考虑到执行速度和内存使用情况。</p>
</blockquote>
<p>分析：</p>
<ol>
<li>大文件IO，使用Java NIO代替传统IO</li>
<li>将该文件拆分成若干部分，对每个部分进行锁定，并开启若干线程进行处理</li>
<li>单词和次数配对出现，因此，我们需要使用一对值操作集合Map</li>
<li>最后要按英文排序，并能够检索特定单词出现的次数，显然单词是key,次数是value，且按key有序，所以使用TreeMap进行管理。</li>
<li>另外，从英文文件中提取每一个单词需要采用Java正则表达式，或StringTokenizer实现</li>
</ol>
<p>下面是程序示例代码：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset; </span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class TestNIO&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> TreeMap&lt;<span class="keyword">String</span>, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> TreeMap&lt;<span class="keyword">String</span>, Integer&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		File srcFile = <span class="keyword">new</span> File(<span class="string">"./src.txt"</span>);</span><br><span class="line">		File desFile = <span class="keyword">new</span> File(<span class="string">"./des.txt"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">long</span> fileLength = srcFile.length();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span><br><span class="line">		long size = 25;</span><br><span class="line">		int num = 0;</span><br><span class="line">		</span><br><span class="line">		if(fileLength &lt; size)&#123;</span><br><span class="line">			num = 1;</span><br><span class="line">			size = fileLength;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			num = (int)(fileLength / size);</span><br><span class="line">		&#125;*/</span></span><br><span class="line"></span><br><span class="line">		LineNumberReader lnr = <span class="keyword">new</span> LineNumberReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(srcFile)));</span><br><span class="line">		<span class="keyword">long</span> lineSize = lnr.readLine().length();</span><br><span class="line">		lnr.skip(fileLength);</span><br><span class="line">		<span class="keyword">long</span> lineNum = lnr.getLineNumber()+<span class="number">1</span>;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"The file has "</span>+lineNum+<span class="string">" lines"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">int</span> numBlock = <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">long</span> <span class="built_in">size</span> = numBlock*lineSize;</span><br><span class="line">		<span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(fileLength &lt; <span class="built_in">size</span>)&#123;</span><br><span class="line">			num = <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">size</span> = fileLength;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			num = lineNum / numBlock;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">		&#123;	</span><br><span class="line">			<span class="keyword">long</span> pos = i*<span class="built_in">size</span>;</span><br><span class="line">			<span class="keyword">if</span>(i == (num-<span class="number">1</span>))&#123;</span><br><span class="line">				<span class="built_in">size</span> = fileLength - pos;</span><br><span class="line">			&#125;</span><br><span class="line">			CountWords cw = <span class="keyword">new</span> CountWords(srcFile, pos, <span class="built_in">size</span>);</span><br><span class="line">			Thread t = <span class="keyword">new</span> Thread(cw);</span><br><span class="line">			t.start();</span><br><span class="line">			t.<span class="built_in">join</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		getMaxWords(<span class="built_in">map</span>);</span><br><span class="line">		map2File(<span class="built_in">map</span>,desFile);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> getMaxWords(Map&lt;<span class="keyword">String</span>, Integer&gt; <span class="built_in">map</span>)&#123;</span><br><span class="line">		TreeMap&lt;Integer, ArrayList&lt;<span class="keyword">String</span>&gt;&gt; result = <span class="keyword">new</span> TreeMap&lt;Integer, ArrayList&lt;<span class="keyword">String</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line">		Set&lt;Map.Entry&lt;<span class="keyword">String</span>, Integer&gt;&gt; entrys = <span class="built_in">map</span>.entrySet();</span><br><span class="line">		Iterator&lt;Map.Entry&lt;<span class="keyword">String</span>, Integer&gt;&gt; iter = entrys.iterator();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">			Map.Entry&lt;<span class="keyword">String</span>, Integer&gt; me = iter.next();</span><br><span class="line">			<span class="keyword">String</span> <span class="built_in">str</span> = me.getKey();</span><br><span class="line">			Integer num = me.getValue();</span><br><span class="line">			ArrayList&lt;<span class="keyword">String</span>&gt; al = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">null</span> != result.<span class="built_in">get</span>(num))&#123;</span><br><span class="line">				al = result.<span class="built_in">get</span>(num);</span><br><span class="line">				al.<span class="built_in">add</span>(<span class="built_in">str</span>);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				al.<span class="built_in">clear</span>();</span><br><span class="line">				al.<span class="built_in">add</span>(<span class="built_in">str</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			result.put(num,al);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Map.Entry&lt;Integer, ArrayList&lt;<span class="keyword">String</span>&gt;&gt; last = result.lastEntry();</span><br><span class="line"></span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"The max repeat num is: "</span>+last.getKey());</span><br><span class="line">		System.out.<span class="built_in">print</span>(<span class="string">"The corresponding str is: "</span>);</span><br><span class="line">		ArrayList&lt;<span class="keyword">String</span>&gt; al = last.getValue();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;al.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">			System.out.<span class="built_in">print</span>(al.<span class="built_in">get</span>(i));</span><br><span class="line">			<span class="keyword">if</span>(i&lt;al.<span class="built_in">size</span>()-<span class="number">1</span>)&#123;</span><br><span class="line">				System.out.<span class="built_in">print</span>(<span class="string">","</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.<span class="built_in">println</span>();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> map2File(Map&lt;<span class="keyword">String</span>, Integer&gt; <span class="built_in">map</span>, File des)&#123;</span><br><span class="line">		FileChannel fc = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			fc = <span class="keyword">new</span> FileOutputStream(des).getChannel();</span><br><span class="line">			Set&lt;Map.Entry&lt;<span class="keyword">String</span>, Integer&gt;&gt; entrys = <span class="built_in">map</span>.entrySet();</span><br><span class="line">			Iterator&lt;Map.Entry&lt;<span class="keyword">String</span>, Integer&gt;&gt; iter = entrys.iterator();</span><br><span class="line">			<span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">				Map.Entry&lt;<span class="keyword">String</span>, Integer&gt; me = iter.next();</span><br><span class="line">				<span class="keyword">String</span> <span class="variable">key</span> = me.getKey();</span><br><span class="line">				<span class="built_in">int</span> value = me.getValue();</span><br><span class="line"></span><br><span class="line">				ByteBuffer buf = ByteBuffer.wrap((<span class="variable">key</span>+<span class="string">": "</span>+value+<span class="string">"\r\n"</span>).getBytes());</span><br><span class="line">				fc.write(buf);</span><br><span class="line">				buf.<span class="built_in">clear</span>();</span><br><span class="line">			&#125;</span><br><span class="line"> 		&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				fc.close();</span><br><span class="line">				System.out.<span class="built_in">println</span>(<span class="string">"map to file done"</span>);</span><br><span class="line">			&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class CountWords implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> FileChannel fc = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> FileLock fl = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> MappedByteBuffer mbBuf = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, Integer&gt; hm = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> CountWords(File src, <span class="keyword">long</span> pos, <span class="keyword">long</span> <span class="built_in">size</span>)&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			fc = <span class="keyword">new</span> RandomAccessFile(src,<span class="string">"rw"</span>).getChannel();</span><br><span class="line">			fl = fc.lock(pos, <span class="built_in">size</span>, <span class="keyword">false</span>);</span><br><span class="line">			mbBuf = fc.<span class="built_in">map</span>(FileChannel.MapMode.READ_ONLY, pos, <span class="built_in">size</span>);</span><br><span class="line">			hm = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span> ,Integer&gt;();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> run()&#123;</span><br><span class="line">		<span class="keyword">String</span> <span class="built_in">str</span> = Charset.forName(<span class="string">"UTF-8"</span>).decode(mbBuf).toString();</span><br><span class="line">		<span class="keyword">String</span> word = <span class="keyword">null</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//use regex to obtain word</span></span><br><span class="line">		Pattern pattern = Pattern.compile(<span class="string">"\\b[\\w-']+\\b"</span>);  </span><br><span class="line">		Matcher matcher = pattern.matcher(<span class="built_in">str</span>);  </span><br><span class="line">		<span class="keyword">while</span> (matcher.find()) &#123;  </span><br><span class="line">			word = matcher.group();  </span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">null</span> != hm.<span class="built_in">get</span>(word))&#123;</span><br><span class="line">				hm.put(word, hm.<span class="built_in">get</span>(word)+<span class="number">1</span>);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				hm.put(word, <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="comment">/*use stringtokenizer to obtain word</span><br><span class="line">		StringTokenizer token = new StringTokenizer(str);</span><br><span class="line">		while(token.hasMoreTokens())&#123;</span><br><span class="line">			word = token.nextToken();</span><br><span class="line">			if(null != hm.get(word))&#123;</span><br><span class="line">				hm.put(word, hm.get(word)+1);</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				hm.put(word, 1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;*/</span></span><br><span class="line">		TestNIO.<span class="built_in">map</span>.putAll(hm);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			fl.release();</span><br><span class="line">			fc.close();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该案例问题总结如下：</p>
<ul>
<li>其中文件的每个部分的划分，开始是按文件大小进行分割，但是发现，这种分割方式会将文件中的单词截断，所以后面选择采用对文件中的行数进行分割</li>
<li>文件的每一部分分配给指定线程进行处理，先锁定该部分内容，处理完成之后，添加到全局map中，然后，再释放锁。</li>
<li>使用StringTokenizer提取单词，会包含标点符号，因此使用正则表达式的方式是最好的。</li>
<li>另外本示例若分配到多个线程处理，好像还存在问题，希望共同探讨。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：传统IO是通过流的形式建立内存与外设之间的传输。而NIO则以通道和缓存的方式实现新的数据传输方式以解决传统IO的一些不足，NIO产生自JDK1.4，使用NIO代替传统IO会大大提高数据传输效率，掌握Java NIO的基本知识和使用方法也是对传统IO的一种补充，是一种同步非阻塞IO模式。]]>
    
    </summary>
    
      <category term="Java学习" scheme="http://blog.zbvae.com/tags/Java%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 类集]]></title>
    <link href="http://blog.zbvae.com/2015/07/11/Java-%E7%B1%BB%E9%9B%86/"/>
    <id>http://blog.zbvae.com/2015/07/11/Java-类集/</id>
    <published>2015-07-11T07:11:39.000Z</published>
    <updated>2015-08-10T09:05:36.560Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：Java中的类集实际上是动态对象数组，没有长度限制，可以任意扩充和丰富。从JDK1.5后，类集中添加了泛型声明，保证了类集使用的安全，所有的类集都位于java.util包下，类集有其继承结构，掌握好类集的使用对我们的程序开发有极大地帮助。<a id="more"></a></p>
<h2 id="1-类集概述">1.类集概述</h2><p>　　Java中的类集，可分为单值操作集合，一对值的操作集合，输出集合。其中Collection是最大的单值集合操作接口，Map是最大的一对值集合操作接口，Iterator是最大的输出接口。 </p>
<h2 id="2-Collection接口">2.Collection接口</h2><p>　　观察以下Collection类型的定义：<code>public interface Collection &lt;E&gt; extends Iterable &lt;E&gt;</code>，说明其支持泛型操作。Colletion接口包含以下操作方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean add(E e)</td>
<td style="text-align:center">添加元素</td>
</tr>
<tr>
<td>boolean addAll(Collection&lt;? extends E&gt; c)</td>
<td style="text-align:center">添加一组元素，子集合</td>
</tr>
<tr>
<td>void clear()</td>
<td style="text-align:center">清空集合内容</td>
</tr>
<tr>
<td>boolean contains(Object o)</td>
<td style="text-align:center">判断集合中是否包含对象o</td>
</tr>
<tr>
<td>boolean containsAll(Collection&lt;?&gt; c)</td>
<td style="text-align:center">判断集合中是否包含子集合</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td style="text-align:center">判断集合是否为空</td>
</tr>
<tr>
<td>Iterator<e> iterator()</e></td>
<td style="text-align:center">为Iterator接口实例化对象，以访问该集合</td>
</tr>
<tr>
<td>boolean remove(Object o)</td>
<td style="text-align:center">删除指定对象</td>
</tr>
<tr>
<td>boolean removeAll(Collection&lt;?&gt; c)</td>
<td style="text-align:center">删除一组元素，子集合</td>
</tr>
<tr>
<td>int size()</td>
<td style="text-align:center">返回集合大小，集合当前元素个数</td>
</tr>
<tr>
<td>Object[] toArray()</td>
<td style="text-align:center">返回该集合的静态对象数组形式</td>
</tr>
</tbody>
</table>
<p>在使用集合工具的时候，一般不直接使用Colletion接口，而多使用其子接口List和Set，虽然Collection接口还有两个子接口Queue和SortedSet但不常用。其中List和Set最大区别就是List中允许重复元素，Set中不允许元素重复。</p>
<h3 id="2-1List接口">2.1List接口</h3><p>　　List接口对Collection接口有了一定的扩充，添加的方法如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>void add(int index,E element)</td>
<td style="text-align:center">在集合指定位置插入元素</td>
</tr>
<tr>
<td>boolean addAll(int index, Collection&lt;? extends E&gt; c)</td>
<td style="text-align:center">在集合指定位置插入子集合</td>
</tr>
<tr>
<td>E get(int index)</td>
<td style="text-align:center">取得索引位置集合内容</td>
</tr>
<tr>
<td>int indexOf(Object o)</td>
<td style="text-align:center">返回指定对象在集合中的索引，-1为不存在</td>
</tr>
<tr>
<td>int lastIndexOf(Object o)</td>
<td style="text-align:center">返回指定对象最后一次出现在集合中的位置</td>
</tr>
<tr>
<td>ListIterator<e> listIterator()</e></td>
<td style="text-align:center">判实例化ListIterator对象，便于List集合输出</td>
</tr>
<tr>
<td>E remove(int index)</td>
<td style="text-align:center">删除指定索引位置的元素</td>
</tr>
<tr>
<td>E set(int index,  E element)</td>
<td style="text-align:center">修改指定索引位置的元素</td>
</tr>
<tr>
<td>List<e> subList(int fromIndex, int toIndex)</e></td>
<td style="text-align:center">截取子集合，从指定起始位置到结束位置</td>
</tr>
</tbody>
</table>
<p>在使用List接口的时候，我们通常使用其子类ArrayList对其进行实例化，下面是ArrayList的使用示例：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> class TestCollection&#123;</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">  		List&lt;<span class="keyword">String</span>&gt; ls = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">  		ls.<span class="built_in">add</span>(<span class="string">"hello"</span>);</span><br><span class="line">  		ls.<span class="built_in">add</span>(<span class="string">"world"</span>);</span><br><span class="line">  		ls.<span class="built_in">add</span>(<span class="string">"hello"</span>);</span><br><span class="line">  		ls.<span class="built_in">add</span>(<span class="number">0</span>,<span class="string">"yes"</span>);</span><br><span class="line">  		ls.remove(<span class="string">"hello"</span>);</span><br><span class="line">  		System.out.<span class="built_in">println</span>(ls.contains(<span class="string">"world"</span>));</span><br><span class="line">  		System.out.<span class="built_in">println</span>(ls);</span><br><span class="line"> 	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出：</p>
<blockquote>
<p>true<br>[yes, world, hello]</p>
</blockquote>
<p>说明集合类已经覆写了toString方法。ArrayList类是JDK1.2引进的，List接口还有一个较老的子类Vector也可以对其进行实例化，主要操作方法addElement,另外可以返回枚举对其进行输出。ArrayList和Vector主要区别在于：</p>
<ul>
<li>时间上，ArrayList产生于JDK1.2，而Vector产生于JDK1.0；</li>
<li>ArrayList是异步操作，因此性能较高，Vector属于同步操作，性能较低；</li>
<li>ArrayList是非线程安全的操作类，Vector是线程安全的操作类；</li>
<li>ArrayList当集合内容加之初始容量时，容量会自动扩充0.5倍，而Vector容量会自动扩充1倍。<br>LinkedList是扩展自List接口的链表操作类，使用方法与ArrayList类似，存储上有所差异，这里就不过多介绍了。</li>
</ul>
<h3 id="2-2Set接口">2.2Set接口</h3><p>Set接口也属于Collection的子接口，但它和List接口的最大区别在于，Set集合中不能包含重复元素，Set接口有两大子类,TreeSet和HashSet，其中TreeSet支持有序存放，HashSet属于散列存放。Set接口并没有对Collection接口进行扩充。<br>首先使用HashSet对其进行实例化：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; <span class="keyword">st</span> = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"><span class="keyword">st</span>.<span class="built_in">add</span>(<span class="string">"A"</span>);</span><br><span class="line"><span class="keyword">st</span>.<span class="built_in">add</span>(<span class="string">"D"</span>);</span><br><span class="line"><span class="keyword">st</span>.<span class="built_in">add</span>(<span class="string">"C"</span>);//<span class="built_in">repeat</span> element</span><br><span class="line"><span class="keyword">st</span>.<span class="built_in">add</span>(<span class="string">"C"</span>);</span><br><span class="line"><span class="keyword">st</span>.<span class="built_in">add</span>(<span class="string">"B"</span>);</span><br><span class="line"><span class="keyword">st</span>.<span class="built_in">add</span>(<span class="string">"B"</span>);//<span class="built_in">repeat</span> element</span><br><span class="line"><span class="keyword">st</span>.<span class="built_in">add</span>(<span class="string">"E"</span>);</span><br><span class="line">System.out.println(<span class="keyword">st</span>);</span><br></pre></td></tr></table></figure></p>
<p>输出：<code>[D, E, A, B, C]</code>，从输出内容，可以发现Set不允许有重复元素，会自动屏蔽，HashSet对元素散列存放，没有任何顺序，将HashSet更改为TreeSet进行实例化得到输出结果如下：[A, B, C, D, E]，说明，使用TreeSet对存放的元素进行顺序排放。那么它是如何排序的呢，现在不存放String对象，改存放我们自定义的Person对象，其结果又如何呢？定义Person类如下：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class <span class="keyword">Person</span>&#123;</span><br><span class="line"> 	private String name = null;</span><br><span class="line"> 	private int age = 0;</span><br><span class="line"></span><br><span class="line"> 	public <span class="keyword">Person</span>()&#123;</span><br><span class="line"> </span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public <span class="keyword">Person</span>(String name, int age)&#123;</span><br><span class="line">  		this.name = name;</span><br><span class="line">  		this.age = age;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public String toString()&#123;</span><br><span class="line">  		return <span class="string">"name="</span> + this.name + <span class="string">" age="</span> + this.age;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在主函数定义Set集合，用于存放Person对象，</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;<span class="keyword">Person</span>&gt; pr = new TreeSet&lt;<span class="keyword">Person</span>&gt;();</span><br><span class="line">pr.add(new <span class="keyword">Person</span>(<span class="string">"zhangsan"</span>,20));</span><br><span class="line">pr.add(new <span class="keyword">Person</span>(<span class="string">"lisi"</span>,21));</span><br><span class="line">pr.add(new <span class="keyword">Person</span>(<span class="string">"wangwu"</span>,15));</span><br><span class="line">pr.add(new <span class="keyword">Person</span>(<span class="string">"zhaoliu"</span>,20)); </span><br><span class="line">System.out.println(pr);</span><br></pre></td></tr></table></figure>
<p>主函数输出集合：</p>
<blockquote>
<p>Exception in thread “main” java.lang.ClassCastException: Person cannot be cast to java.lang.Comparable<br> at java.util.TreeMap.compare(Unknown Source)<br> at java.util.TreeMap.put(Unknown Source)<br> at java.util.TreeSet.add(Unknown Source)<br> at TestCollection.main(TestCollection.java:27)</p>
</blockquote>
<p> 程序产生上述异常，可以发现，这时候Person类由于没有实现Comparable接口，因此不支持排序功能，而String默认是实现了Comparable接口的，现在修改Person类实现Comparable接口，覆盖compareTo方法，使其按年龄排序。</p>
 <figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class <span class="keyword">Person</span> implements Comparable&lt;<span class="keyword">Person</span>&gt; &#123;</span><br><span class="line">  	private String name = null;</span><br><span class="line"> 	private int age = 0;</span><br><span class="line"></span><br><span class="line"> 	public <span class="keyword">Person</span>()&#123;</span><br><span class="line"> </span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line">	public <span class="keyword">Person</span>(String name, int age)&#123;</span><br><span class="line">  		this.name = name;</span><br><span class="line">  		this.age = age;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public int compareTo(<span class="keyword">Person</span> per)&#123;</span><br><span class="line">  		if(this.age &lt; per.age)&#123;</span><br><span class="line">   			return -1;</span><br><span class="line">  		&#125;else if(this.age &gt; per.age)&#123;</span><br><span class="line">   			return 1;</span><br><span class="line">  		&#125;else&#123;</span><br><span class="line">   			return 0;</span><br><span class="line">  		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public String toString()&#123;</span><br><span class="line">  		return <span class="string">"name="</span> + this.name + <span class="string">" age="</span> + this.age;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 修改之后，正常输出并按年龄排序如下：</p>
<blockquote>
<p>[name=wangwu age=15, name=zhangsan age=20, name=lisi age=21]</p>
</blockquote>
<p> 但是发现zhaoliu不见了，那是因为对年龄排序，由于zhangsan和zhaoliu的年龄一样，被当做重复元素处理掉了，现在修改compareTo方法</p>
 <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">compareTo</span>(Person per)&#123;</span><br><span class="line">  	<span class="keyword">if</span>(<span class="keyword">this</span>.age &lt; per.age)&#123;</span><br><span class="line">  	 	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.age &gt; per.age)&#123;</span><br><span class="line">   		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   		<span class="keyword">return</span> <span class="keyword">this</span>.name.<span class="keyword">compareTo</span>(per.name);</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 输出如下：</p>
<blockquote>
<p>[name=wangwu age=15, name=zhangsan age=20, name=zhaoliu age=20, name=lisi age=21]</p>
</blockquote>
<p> 发现一切正常了，即使加上一个20岁的zhangsan，重复元素也会被剔除掉。</p>
<p> 但这时将主函数中的TreeSet类改成HashSet类，输出：</p>
<blockquote>
<p>[name=zhaoliu age=20, name=zhangsan age=20, name=zhangsan age=20, name=lisi age=21, name=wangwu age=15]</p>
</blockquote>
<p>发现加上的重复元素zhangsan没有被剔除，是因为我们刚刚是对Person类借助于compareTo方法实现了比较剔除，而并没有从类本身考虑重复的情况，一旦比较不需要了，重复元素便不能判断出来。<br>那么Set集合又是如何排除重复元素的呢？答案是通过Obejct的equals和hashCode方法，来判断重复元素的，现在修改Person类如下：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class <span class="keyword">Person</span> implements Comparable&lt;<span class="keyword">Person</span>&gt; &#123;</span><br><span class="line">  	private String name = null;</span><br><span class="line"> 	private int age = 0;</span><br><span class="line"></span><br><span class="line"> 	public <span class="keyword">Person</span>()&#123;</span><br><span class="line"> </span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public <span class="keyword">Person</span>(String name, int age)&#123;</span><br><span class="line">  		this.name = name;</span><br><span class="line">  		this.age = age;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public int compareTo(<span class="keyword">Person</span> per)&#123;</span><br><span class="line">  		if(this.age &lt; per.age)&#123;</span><br><span class="line">   			return -1;</span><br><span class="line">  		&#125;else if(this.age &gt; per.age)&#123;</span><br><span class="line">   			return 1;</span><br><span class="line">  		&#125;else&#123;</span><br><span class="line">   			return this.name.compareTo(per.name);</span><br><span class="line">  		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public int hashCode()&#123;</span><br><span class="line">  		return this.name.hashCode()*this.age;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public boolean equals(Object o)&#123;</span><br><span class="line">  		if(this == o)</span><br><span class="line">   			return true;</span><br><span class="line">  		if(!(o instanceof <span class="keyword">Person</span>))</span><br><span class="line">   			return false;</span><br><span class="line">  		<span class="keyword">Person</span> per = (<span class="keyword">Person</span>)o;</span><br><span class="line">  		if(this.name.equals(per.name) &amp;&amp; this.age == per.age) </span><br><span class="line">   			return true;</span><br><span class="line">  		else</span><br><span class="line">   			return false;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public String toString()&#123;</span><br><span class="line">  		return <span class="string">"name="</span> + this.name + <span class="string">" age="</span> + this.age;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主函数再次进行调用：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;<span class="keyword">Person</span>&gt; pr = new TreeSet&lt;<span class="keyword">Person</span>&gt;();</span><br><span class="line">pr.add(new <span class="keyword">Person</span>(<span class="string">"zhangsan"</span>,20));</span><br><span class="line">pr.add(new <span class="keyword">Person</span>(<span class="string">"lisi"</span>,21));</span><br><span class="line">pr.add(new <span class="keyword">Person</span>(<span class="string">"wangwu"</span>,15));</span><br><span class="line">pr.add(new <span class="keyword">Person</span>(<span class="string">"zhaoliu"</span>,20));</span><br><span class="line">pr.add(new <span class="keyword">Person</span>(<span class="string">"zhangsan"</span>,20));</span><br><span class="line">System.out.println(pr);</span><br></pre></td></tr></table></figure>
<p>此时输出内容不会再出现重复元素了：</p>
<blockquote>
<p>[name=wangwu age=15, name=zhangsan age=20, name=zhaoliu age=20, name=lisi age=21]</p>
</blockquote>
<h2 id="3-集合输出">3.集合输出</h2><p>集合的输出有四种方式：Iterator；ListIterator;foreach;Enumeration。其中Iterator是推荐使用方式：只要碰到集合输出问题，就一定首先考虑使用Iterator接口进行输出。ListIterator只要List接口的子类对象才可以使用，可以进行双向输出。也可以使用一般的for循环输出List集合内容。foreach是JDK1.5版本新增的for循环增强的内容，不仅可以输出数组，也可以输出集合内容。Enumeration接口是一种古老的操作接口，只有Vector类elements方法可以返回Enumeration接口实例，并进一步进行输出操作。下面介绍这几种输出方法：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">System.out.println<span class="params">(<span class="string">"1.use iterator to print collection"</span>)</span>;</span><br><span class="line">Iterator&lt;Person&gt; iter = pr.iterator<span class="params">()</span>;</span><br><span class="line">while<span class="params">(iter.hasNext<span class="params">()</span>)</span>&#123;</span><br><span class="line">	Person per = iter.next<span class="params">()</span>;</span><br><span class="line">	System.out.println<span class="params">(per)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println<span class="params">(<span class="string">"2.use listiterator to print List"</span>)</span>;</span><br><span class="line">ListIterator&lt;String&gt; listIter = ls.listIterator<span class="params">()</span>;</span><br><span class="line">System.out.println<span class="params">(<span class="string">"2.1.forward print"</span>)</span>;</span><br><span class="line">while<span class="params">(listIter.hasNext<span class="params">()</span>)</span>&#123;</span><br><span class="line">	String <span class="built_in">str</span> = listIter.next<span class="params">()</span>;</span><br><span class="line">	System.out.println<span class="params">(str)</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println<span class="params">(<span class="string">"2.2.backward print"</span>)</span>;</span><br><span class="line">while<span class="params">(listIter.hasPrevious<span class="params">()</span>)</span>&#123;</span><br><span class="line">	String <span class="built_in">str</span> = listIter.previous<span class="params">()</span>;</span><br><span class="line">	System.out.println<span class="params">(str)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println<span class="params">(<span class="string">"3.use general for to print List"</span>)</span>;</span><br><span class="line"><span class="keyword">for</span><span class="params">(int i=<span class="number">0</span>;i&lt;ls.size<span class="params">()</span>;i++)</span>&#123;</span><br><span class="line">	String <span class="built_in">str</span> = ls.get<span class="params">(i)</span>;</span><br><span class="line">	System.out.println<span class="params">(str)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println<span class="params">(<span class="string">"4.use foreach to print collection"</span>)</span>;</span><br><span class="line"><span class="keyword">for</span><span class="params">(Person per : pr)</span>&#123;</span><br><span class="line">	System.out.println<span class="params">(per)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println<span class="params">(<span class="string">"5.use enumeration to print Vector"</span>)</span>;</span><br><span class="line">Enumeration&lt;String&gt; e = vec.elements<span class="params">()</span>;</span><br><span class="line">while<span class="params">(e.hasMoreElements<span class="params">()</span>)</span>&#123;</span><br><span class="line">	String <span class="built_in">str</span> = e.nextElement<span class="params">()</span>;</span><br><span class="line">	System.out.println<span class="params">(str)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，ListIterator对List集合进行双向输出时，必须先进行next输出之后，才能进行previous输出。至此已经介绍完了单一值接口和输出接口，还剩下一对值接口即Map接口。</p>
<h2 id="4-Map_接口">4.Map 接口</h2><p>　　Map作为一对值的最大接口，其值的存储是以键值对的形式存放的，同样我们也不直接操作Map接口，而是使用其子类进行实例化，Map接口三个常用的子类是：HashMap,Hashtable以及TreeMap.先来看一下Map接口定义的常用方法。Map接口定义：<code>public interface Map&lt;K,V&gt;</code></p>
<p>　　常用方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>V put(K key, V value)</td>
<td style="text-align:left">添加键值对</td>
</tr>
<tr>
<td>V get(Object key)</td>
<td style="text-align:left">根据指定键取值</td>
</tr>
<tr>
<td>boolean containsKey(Object key)</td>
<td style="text-align:left">判断是否包含指定键</td>
</tr>
<tr>
<td>boolean containsValue(Object value)</td>
<td style="text-align:left">判断是否包含指定值</td>
</tr>
<tr>
<td>Set<k> keySet()</k></td>
<td style="text-align:left">将所有的key转为Set集合</td>
</tr>
<tr>
<td>Collection<v> values()</v></td>
<td style="text-align:left">将所有的value转化为Collection集合</td>
</tr>
<tr>
<td>Set<map.entry<k,v>&gt; entrySet()</map.entry<k,v></td>
<td style="text-align:left">将Map转化为Set集合，此为Map输出方式</td>
</tr>
<tr>
<td>void clear()</td>
<td style="text-align:left">清空Map集合</td>
</tr>
<tr>
<td>void size()</td>
<td style="text-align:left">返回集合大小</td>
</tr>
</tbody>
</table>
<p>以下代码使用HashMap为Map接口进行实例化，并调用相关方法</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer,<span class="keyword">String</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;Integer,<span class="keyword">String</span>&gt;();</span><br><span class="line"><span class="built_in">map</span>.put(<span class="number">1</span>,<span class="string">"hello"</span>);</span><br><span class="line"><span class="built_in">map</span>.put(<span class="number">2</span>,<span class="string">"world"</span>);</span><br><span class="line"><span class="built_in">map</span>.put(<span class="number">3</span>,<span class="string">"yes"</span>);</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;Integer&gt; keys = <span class="built_in">map</span>.keySet();</span><br><span class="line">Iterator&lt;Integer&gt; keyIter = keys.iterator();</span><br><span class="line"><span class="keyword">while</span>(keyIter.hasNext())&#123;</span><br><span class="line">	Integer <span class="variable">key</span> = keyIter.next();</span><br><span class="line">	<span class="keyword">String</span> value = <span class="built_in">map</span>.<span class="built_in">get</span>(<span class="variable">key</span>);</span><br><span class="line">	System.out.<span class="built_in">println</span>(<span class="variable">key</span>+<span class="string">"----&gt;"</span>+value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Collection&lt;<span class="keyword">String</span>&gt; vals = <span class="built_in">map</span>.values();</span><br><span class="line">Iterator&lt;<span class="keyword">String</span>&gt; valIter = vals.iterator();</span><br><span class="line"><span class="keyword">while</span>(valIter.hasNext())&#123;</span><br><span class="line">	<span class="keyword">String</span> val = valIter.next();</span><br><span class="line">	System.out.<span class="built_in">println</span>(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>{1=hello, 2=world, 3=yes}<br>1——&gt;hello<br>2——&gt;world<br>3——&gt;yes<br>hello<br>world<br>yes</p>
</blockquote>
<p>HashMap本身也属于一种无序的操作。而Hashtable实际上与Vector产生的时代一样，属于最早集合操作类，之后只是扩展了其应用，实现了Map接口而已,，把上面HashMap声明部分，换成Hashtable，结果一模一样。那么HashMap与Hashtale的区别与ArrayList和Vector区别一样：HashMap集合比较晚，异步处理，性能较高；Hashtable较早，同步处理，性能较差。从实际开发来看，最常用的子类是HashMap.注意Map接口由于以键值对的形式出现，无法直接使用Ierator接口进行输出。下面介绍一种Map接口常用输出方法。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span><span class="subst">&lt;</span><span class="built_in">Map</span><span class="built_in">.</span>Entry<span class="subst">&lt;</span><span class="built_in">Integer</span>,<span class="built_in">String</span><span class="subst">&gt;&gt;</span> entrys <span class="subst">=</span> <span class="built_in">map</span><span class="built_in">.</span>entrySet();</span><br><span class="line">Iterator<span class="subst">&lt;</span><span class="built_in">Map</span><span class="built_in">.</span>Entry<span class="subst">&lt;</span><span class="built_in">Integer</span>,<span class="built_in">String</span><span class="subst">&gt;&gt;</span> entryIter <span class="subst">=</span> entrys<span class="built_in">.</span>iterator();</span><br><span class="line"><span class="keyword">while</span>(entryIter<span class="built_in">.</span>hasNext())&#123;</span><br><span class="line">	<span class="built_in">Map</span><span class="built_in">.</span>Entry<span class="subst">&lt;</span><span class="built_in">Integer</span>,<span class="built_in">String</span><span class="subst">&gt;</span> me <span class="subst">=</span> entryIter<span class="built_in">.</span>next();</span><br><span class="line">	System<span class="built_in">.</span>out<span class="built_in">.</span>println(me<span class="built_in">.</span>getKey()<span class="subst">+</span><span class="string">"----&gt;"</span><span class="subst">+</span>me<span class="built_in">.</span>getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：Java中的类集实际上是动态对象数组，没有长度限制，可以任意扩充和丰富。从JDK1.5后，类集中添加了泛型声明，保证了类集使用的安全，所有的类集都位于java.util包下，类集有其继承结构，掌握好类集的使用对我们的程序开发有极大地帮助。]]>
    
    </summary>
    
      <category term="Java学习" scheme="http://blog.zbvae.com/tags/Java%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 比较器]]></title>
    <link href="http://blog.zbvae.com/2015/07/11/Java-%E6%AF%94%E8%BE%83%E5%99%A8/"/>
    <id>http://blog.zbvae.com/2015/07/11/Java-比较器/</id>
    <published>2015-07-11T06:57:40.000Z</published>
    <updated>2015-07-11T08:06:03.562Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：Java中Arrays以及支持可排序功能的集合类等都提供了对象比较功能，那么它是如何实现的呢，能直接使用Arrays来比较两个自定义的对象数组吗，答案是否定的。下面本文从Arrays类出发，介绍对象数组的比较功能，以及两种比较器的实现方式。<a id="more"></a></p>
<h2 id="1-Arrays类提供的比较功能">1.Arrays类提供的比较功能</h2><p>　　java.util包中Arrays类作为一个工具类，提供了大量用于数组操作的静态方法，其中包括数组二分查找，对象数组的比较以及对象数组的排序等功能，供用户方便使用。例如使用下面的例子对两个int数组进行比较如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestCompare</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span> b[] = &#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">		Arrays.sort(b);</span><br><span class="line">		System.<span class="keyword">out</span>.println(Arrays.equals(a,b));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案返回true，如果将int更改其包装类Integer，再试一下结果还是一样的，可以排序和比较成功。如果换成我们自己定义的类呢。下面是自定义的Student类，包含名字，年龄，成绩属性，现在希望使用Arrays对Student对象数组进行排序，又会怎样呢？</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span><br><span class="line"> 	<span class="keyword">private</span> String name = <span class="keyword">null</span>;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">double</span> score = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params">String name,<span class="keyword">int</span> age,<span class="keyword">double</span> score</span>)</span>&#123;</span><br><span class="line">  		<span class="keyword">this</span>.name = name;</span><br><span class="line">  		<span class="keyword">this</span>.age = age;</span><br><span class="line">  		<span class="keyword">this</span>.score = score;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  		<span class="keyword">return</span> <span class="string">"name="</span> + <span class="keyword">this</span>.name + <span class="string">" age="</span> + <span class="keyword">this</span>.age + <span class="string">" score="</span> + <span class="keyword">this</span>.score;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在主函数中定义一个Student对象数组，并对其进行比较，输出。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Student stu[] = &#123;<span class="keyword">new</span> Student(<span class="string">"zhangsan"</span>,<span class="number">10</span>,<span class="number">88.5</span>),<span class="keyword">new</span> Student(<span class="string">"lisi"</span>,<span class="number">12</span>,<span class="number">92.3</span>),</span><br><span class="line"><span class="keyword">new</span> Student(<span class="string">"wangwu"</span>,<span class="number">11</span>,<span class="number">85.6</span>),<span class="keyword">new</span> Student(<span class="string">"zhaoliu"</span>,<span class="number">12</span>,<span class="number">94.5</span>)&#125;;</span><br><span class="line"></span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"before sort:"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;stu.length;i++)&#123;</span><br><span class="line">	System.out.<span class="keyword">println</span>(stu[i]);</span><br><span class="line">&#125;</span><br><span class="line">Arrays.<span class="keyword">sort</span>(stu);</span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="string">"after sort:"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;stu.length;i++)&#123;</span><br><span class="line">	System.out.<span class="keyword">println</span>(stu[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较之前，可以正常输出对象数组信息，比较没有成功返回结果，而是打印出如下信息：</p>
<blockquote>
<p>before sort:<br>name=zhangsan age=10 score=88.5<br>name=lisi age=12 score=92.3<br>name=wangwu age=11 score=85.6<br>name=zhaoliu age=12 score=94.5<br>Exception in thread “main” java.lang.ClassCastException: Student cannot be cast to java.lang.Comparable<br> at java.util.ComparableTimSort.countRunAndMakeAscending(Unknown Source)<br> at java.util.ComparableTimSort.sort(Unknown Source)<br> at java.util.ComparableTimSort.sort(Unknown Source)<br> at java.util.Arrays.sort(Unknown Source)<br> at TestCompare.main(TestCompare.java:18)</p>
</blockquote>
<p>为什么会出现以上类型转换异常呢，再回过头来看看Arrays的sort方法是如何支持对象数组的比较的。</p>
<blockquote>
<p>public static void sort([] a)</p>
<blockquote>
<p>Sorts the specified array of objects into ascending order, according to the natural ordering of its elements. All elements in the array must implement the Comparable interface. Furthermore, all elements in the array must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the array).</p>
</blockquote>
</blockquote>
<h2 id="2-类本身实现Comparable接口实现比较">2.类本身实现Comparable接口实现比较</h2><p>　　从以上描述可以看出，Arrays的sort方法默认对数组中对象以升序排序，以一个自然顺序，那么这个自然顺序的定义必须使用Comparable接口来完成，即如果要实现对象数组的排序，则此类必须实现Comparable接口，并覆写compareTo方法。下面通过改造Student类，使其实现Comparable接口，并覆写compareTo方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> score = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> age,<span class="keyword">double</span> score)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">		<span class="keyword">this</span>.score = score;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student stu)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.score &gt; stu.score)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.score &lt; stu.score)&#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"name="</span> + <span class="keyword">this</span>.name + <span class="string">" age="</span> + <span class="keyword">this</span>.age + <span class="string">" score="</span> + <span class="keyword">this</span>.score;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次在主函数中使用Arrays的sort对Student数组进行排序，看有什么改变，输出如下：</p>
<blockquote>
<p> before sort:<br>name=zhangsan age=10 score=88.5<br>name=lisi age=12 score=92.3<br>name=wangwu age=11 score=85.6<br>name=zhaoliu age=12 score=94.5<br>after sort:<br>name=wangwu age=11 score=85.6<br>name=zhangsan age=10 score=88.5<br>name=lisi age=12 score=92.3<br>name=zhaoliu age=12 score=94.5</p>
</blockquote>
<p>程序成功实现了成绩的升序排序，要实现降序，可以在compareTo方法中对调1和-1即可，可以发现Comparable接口支持泛型，可以帮助我们进行类型检查。实际上这种Comparable接口的 compareTo方法有点类似于二叉排序树，下面就Comparable接口定义一个二叉排序树，如下：（实际上这部分内容属于数据结构，但是从此例子可以清晰发现Comparable与二叉排序树的一致性）</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">BinarrySortTree</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">class</span> <span class="title">Node</span>&#123;</span><br><span class="line">		<span class="keyword">private</span> Comparable data;</span><br><span class="line">		<span class="keyword">private</span> Node left;</span><br><span class="line">		<span class="keyword">private</span> Node right;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span>(<span class="params">Comparable data</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.data = data;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span>(<span class="params">Node newNode</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(newNode.data.compareTo(<span class="keyword">this</span>.data) &lt; <span class="number">0</span>)&#123;<span class="comment">//left tree</span></span><br><span class="line">				<span class="keyword">if</span>(<span class="keyword">this</span>.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">					<span class="keyword">this</span>.left = newNode;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="keyword">this</span>.left.addNode(newNode);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span>(<span class="params">newNode.data.compareTo(<span class="keyword">this</span>.data</span>) &gt; 0)</span>&#123;<span class="comment">//right tree</span></span><br><span class="line">				<span class="keyword">if</span>(<span class="keyword">this</span>.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">					<span class="keyword">this</span>.right = newNode;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="keyword">this</span>.right.addNode(newNode);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNode</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">				<span class="keyword">this</span>.left.printNode();</span><br><span class="line">			&#125;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="keyword">this</span>.data);</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">				<span class="keyword">this</span>.right.printNode();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Node root = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span>(<span class="params">Comparable data</span>)</span>&#123;</span><br><span class="line">		Node newNode = <span class="keyword">new</span> Node(data);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">			root = newNode;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			root.addNode(newNode);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.root.printNode();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主函数中添加节点，并进行中序遍历输出：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BinarrySortTree </span>tree = new <span class="keyword">BinarrySortTree();</span><br><span class="line"></span><span class="label">for</span>(int i<span class="number">=0</span><span class="comment">;i&lt;5;i++)&#123;</span></span><br><span class="line">	tree.<span class="keyword">add(5-i);</span><br><span class="line"></span>&#125;</span><br><span class="line"><span class="label">tree.print</span>()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-类外部定义比较器">3.类外部定义比较器</h2><p>　　还有一种支持对象比较的方式，属于一种补救方式，比如在大型项目中，我所设计的类已经定义打包好了，不希望再对它进行任何修改，现在为了要使此类具有可比较特性，还有一种补救方法就是在类外部定义一个特定的比较器，降低类的耦合度。但此种方法不推荐使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> salary = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">this</span>.salary;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">this</span>.salary = salary;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">double</span> salary)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">		<span class="keyword">this</span>.salary = salary;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(o == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Worker))</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		Worker worker = (Worker)o;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.name.equals(worker.name) &amp;&amp; <span class="keyword">this</span>.age == worker.age </span><br><span class="line">		&amp;&amp; <span class="keyword">this</span>.salary == worker.salary)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"name="</span> + <span class="keyword">this</span>.name + <span class="string">" age="</span> + <span class="keyword">this</span>.age + <span class="string">" salary="</span> + <span class="keyword">this</span>.salary;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义外在的WorkerComparator比较器 ，需要实现该接口的equals和compare方法，equals一般在要支持比较的那个类内部定义完善。使用上述Comparator比较器。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Worker</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">return</span> <span class="keyword">this</span>.<span class="title">equals</span><span class="params">(obj)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(Worker o1, Worker o2)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(o1.getSalary() &lt; o2.getSalary())&#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(o1.getSalary() &gt; o2.getSalary())&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出如下：</p>
<blockquote>
<p>before sort:<br>name=peter age=30 salary=12000.0<br>name=tony age=25 salary=15000.0<br>name=paul age=31 salary=13000.0<br>name=danel age=35 salary=25000.0<br>after sort:<br>name=peter age=30 salary=12000.0<br>name=paul age=31 salary=13000.0<br>name=tony age=25 salary=15000.0<br>name=danel age=35 salary=25000.0</p>
</blockquote>
<p>说明这种方式也支持对象数组的比较，但还是推荐大家使用定义类的同时，如果觉得此类有必要支持比较，就实现Comparable接口，毕竟Comparator是作为一种补救出现。</p>
<h2 id="4-两种比较方式的区别">4.两种比较方式的区别</h2><p>从网上看到的一些关于这两个接口的比较：</p>
<ul>
<li>Comparable接口位于java.lang包中，Comparator接口位于java.util包中</li>
<li>Comparable属于自然顺序比较排序，对于TreeSet或者TreeMap中的Key可以实现有序映射，而不需要制定比较器</li>
<li>Comparator属于一种策略模式，即不修改原对象，使用策略对象来达到修改原对象行为的目的</li>
<li>Comparable接口是集合内部定义，自己完成比较；Comparator是外部程序实现比较。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：Java中Arrays以及支持可排序功能的集合类等都提供了对象比较功能，那么它是如何实现的呢，能直接使用Arrays来比较两个自定义的对象数组吗，答案是否定的。下面本文从Arrays类出发，介绍对象数组的比较功能，以及两种比较器的实现方式。]]>
    
    </summary>
    
      <category term="Java学习" scheme="http://blog.zbvae.com/tags/Java%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <link href="http://blog.zbvae.com/2015/07/11/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://blog.zbvae.com/2015/07/11/正则表达式/</id>
    <published>2015-07-11T06:13:55.000Z</published>
    <updated>2015-07-16T05:26:38.219Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：正则表达式主要用途是文本规则的匹配和验证，在处理字符串的程序或网页时，经常需要对用户输入进行正则验证，从而简化复杂的程序编写逻辑，因此，正则表达式实际上就是一种文本规则的验证工具。<a id="more"></a></p>
<h2 id="1-引例">1.引例</h2><p>　　在正则表达式诞生之前，通常我们对某一字符串文本进行验证的时候，需要编配大量的匹配规则，尤其出现在需要用户输入的地方，比如对用户输入的用户名，密码和邮箱进行输入验证，如果存在非法字符，则可能认为是恶意输入。下面通过Java语言介绍一个没有使用正则表达式的邮箱输入验证案例。</p>
<p>　　给定一个邮箱：<code>aB-c_d.ef@g1_2-3h.i4_J-k</code>, 对于该邮箱（任意邮箱），我们将其划分为3个部分，首先，邮箱一定至少包含一个”.”号且只包含一个”@”符号，以这两个符号将邮箱分成3部分，第一部分为@之前的内容，可以是任意字母，数字，中划线，下划线，点号；第二部分为@与最后一个点号之间的内容，可以是任意字母，数字，中划线，下划线，但不可以是点号；第三部分为最后一个点号一直到结尾处的内容，实际上应该是域名，为了简化，我们认为此处内容也可以是任意字母，数字，下划线，中划线，但不可以是点号。<br>明白以上规则之后，见代码:</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class TestRegexp &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">    	<span class="keyword">String</span> emailStr = <span class="string">"csuzhangvae@163.com"</span>;<span class="comment">//[\w-\.]+@[\w-]+\.[\w-]+</span></span><br><span class="line">    	<span class="keyword">if</span>(regexVerify(emailStr))&#123;</span><br><span class="line">            <span class="keyword">if</span>(verifyDNS(emailStr))&#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">"email is right"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">"email is wrong"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">boolean</span> isDigit(<span class="built_in">char</span> c)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">boolean</span> isLetter(<span class="built_in">char</span> c)&#123;</span><br><span class="line">    	<span class="keyword">if</span>((c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) || (c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span>))&#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">boolean</span> commVerify(<span class="keyword">String</span> emailStr)&#123;</span><br><span class="line">    	<span class="built_in">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    	<span class="keyword">if</span>(emailStr.indexOf(<span class="string">"."</span>) == -<span class="number">1</span> || emailStr.indexOf(<span class="string">"@"</span>) == -<span class="number">1</span>)&#123;</span><br><span class="line">    		flag = <span class="keyword">false</span>;</span><br><span class="line">    	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    		<span class="built_in">int</span> highIndex = emailStr.lastIndexOf(<span class="string">"."</span>);</span><br><span class="line">    		<span class="keyword">String</span> highStr = emailStr.substring(highIndex+<span class="number">1</span>);</span><br><span class="line">    		System.out.<span class="built_in">println</span>(highStr);</span><br><span class="line"></span><br><span class="line">    		<span class="built_in">char</span> highChars[] = highStr.toCharArray();</span><br><span class="line">    		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;highChars.length;i++)&#123;</span><br><span class="line">    			<span class="keyword">if</span>(!isDigit(highChars[i]) &amp;&amp; !isLetter(highChars[i]) &amp;&amp; highChars[i] != <span class="string">'-'</span> &amp;&amp; highChars[i] != <span class="string">'_'</span>)&#123;</span><br><span class="line">    				flag = <span class="keyword">false</span>;</span><br><span class="line">    				<span class="keyword">break</span>;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line"></span><br><span class="line">    		<span class="built_in">int</span> middleIndex = emailStr.indexOf(<span class="string">"@"</span>);</span><br><span class="line">    		<span class="keyword">String</span> middleStr = emailStr.substring(middleIndex+<span class="number">1</span>,highIndex);</span><br><span class="line">    		System.out.<span class="built_in">println</span>(middleStr);</span><br><span class="line"></span><br><span class="line">    		<span class="built_in">char</span> middleChars[] = middleStr.toCharArray();</span><br><span class="line">    		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;middleChars.length;i++)&#123;</span><br><span class="line">    			<span class="keyword">if</span>(!isDigit(middleChars[i]) &amp;&amp; !isLetter(middleChars[i]) &amp;&amp; middleChars[i] != <span class="string">'-'</span> &amp;&amp; middleChars[i] != <span class="string">'_'</span>)&#123;</span><br><span class="line">    				flag = <span class="keyword">false</span>;</span><br><span class="line">    				<span class="keyword">break</span>;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="built_in">int</span> lowIndex = <span class="number">0</span>;</span><br><span class="line">    		<span class="keyword">String</span> lowStr = emailStr.substring(<span class="number">0</span>,middleIndex);</span><br><span class="line">    		System.out.<span class="built_in">println</span>(lowStr);</span><br><span class="line"></span><br><span class="line">    		<span class="built_in">char</span> lowChars[] = lowStr.toCharArray();</span><br><span class="line">    		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;lowChars.length;i++)&#123;</span><br><span class="line">    			<span class="keyword">if</span>(!isDigit(lowChars[i]) &amp;&amp; !isLetter(lowChars[i]) &amp;&amp; lowChars[i] != <span class="string">'-'</span> &amp;&amp; lowChars[i] != <span class="string">'_'</span> &amp;&amp; lowChars[i] != <span class="string">'.'</span>)&#123;</span><br><span class="line">    				System.out.<span class="built_in">println</span>(lowChars[i]);</span><br><span class="line">    				flag = <span class="keyword">false</span>;</span><br><span class="line">    				<span class="keyword">break</span>;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码虽然可以实现邮箱规则的匹配，但是各种条件语句和循环语句的嵌套导致结构不清晰，代码量多。如何改用正则表达式呢。这便是本文要介绍的问题。</p>
<h2 id="2-正则表达式">2.正则表达式</h2><p>　　正则表达式是一种文本规则描述的匹配工具，其规则和语法非常多，也不需要全部记住，但对最基本的一定要牢记，最基本最简单的正则表达式就是文本字符串本身， 用于匹配与该字符串相等的字符串。</p>
<h3 id="2-1[]表示选择">2.1[]表示选择</h3><table>
<thead>
<tr>
<th>表达式</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>[abc]</td>
<td style="text-align:center">表示取值可以是a,可以是b,也可以是c</td>
</tr>
<tr>
<td>[^abc]</td>
<td style="text-align:center">表示取值不是abc中的任意字符，即除abc以外的内容</td>
</tr>
<tr>
<td>[a-zA-Z]</td>
<td style="text-align:center">表示所有字母，大写和小写，[a-z]表示小写字母，[A-Z]表示大写字母</td>
</tr>
</tbody>
</table>
<h3 id="2-2常用元字符">2.2常用元字符</h3><table>
<thead>
<tr>
<th>表达式</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td style="text-align:center">除换行符以外的任意字符</td>
</tr>
<tr>
<td>\d</td>
<td style="text-align:center">所有数字</td>
</tr>
<tr>
<td>\w</td>
<td style="text-align:center">所有字母，数字，下划线</td>
</tr>
<tr>
<td>\s</td>
<td style="text-align:center">所有空白字符</td>
</tr>
<tr>
<td>\b</td>
<td style="text-align:center">单词边界位置</td>
</tr>
<tr>
<td>^</td>
<td style="text-align:center">字符串开始</td>
</tr>
<tr>
<td>$</td>
<td style="text-align:center">字符串结尾</td>
</tr>
</tbody>
</table>
<h3 id="2-3常用的反义字符">2.3常用的反义字符</h3><table>
<thead>
<tr>
<th>表达式</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\D</td>
<td style="text-align:center">非数字</td>
</tr>
<tr>
<td>\W</td>
<td style="text-align:center">非字母、数字、下划线</td>
</tr>
<tr>
<td>\S</td>
<td style="text-align:center">非空白字符</td>
</tr>
<tr>
<td>\B</td>
<td style="text-align:center">非单词开始或结束边界位置</td>
</tr>
</tbody>
</table>
<h3 id="2-4表示出现的次数">2.4表示出现的次数</h3><table>
<thead>
<tr>
<th>表达式</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>X?</td>
<td style="text-align:center">表示出现0次或1次</td>
</tr>
<tr>
<td>X*</td>
<td style="text-align:center">表示出现0次或多次</td>
</tr>
<tr>
<td>X+</td>
<td style="text-align:center">表示出现1次或多次</td>
</tr>
<tr>
<td>X{n}</td>
<td style="text-align:center">表示出现n次</td>
</tr>
<tr>
<td>X{n,}</td>
<td style="text-align:center">表示出现的长度大于n次</td>
</tr>
<tr>
<td>X{n,m}</td>
<td style="text-align:center">表示出现n到m次</td>
</tr>
</tbody>
</table>
<h3 id="2-5关系运算">2.5关系运算</h3><table>
<thead>
<tr>
<th>表达式</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>X或Y</td>
<td style="text-align:center">表示要么是X的正则，要么是Y的正则</td>
</tr>
<tr>
<td>(X)</td>
<td style="text-align:center">表示一组规范，一个分组</td>
</tr>
</tbody>
</table>
<h3 id="2-6匹配策略">2.6匹配策略</h3><p>　　介绍了以上的正则表达式及其表示含义之后，大家都或多或少了解了一些相关知识，现在顺便介绍一下正则表达式的贪婪匹配和惰性匹配策略。一般匹配都是遵循贪婪匹配策略，即尽可能多地匹配，而以下规则支持惰性匹配，即尽可能少地匹配</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>*？</td>
<td style="text-align:center">重复任意次，但尽可能少地重复</td>
</tr>
<tr>
<td>*？</td>
<td style="text-align:center">重复任意次，但尽可能少地重复</td>
</tr>
<tr>
<td>+？</td>
<td style="text-align:center">重复1次或多次，但尽可能少地重复</td>
</tr>
<tr>
<td>？？</td>
<td style="text-align:center">重复0次或1次，但尽可能少地重复</td>
</tr>
<tr>
<td>{n,m}？</td>
<td style="text-align:center">重复n到m次，尽可能少地重复</td>
</tr>
<tr>
<td>{n，}？</td>
<td style="text-align:center">重复至少n次,但尽可能少地重复</td>
</tr>
</tbody>
</table>
<h2 id="3-正则验证">3.正则验证</h2><p>　　下面就上面介绍地邮箱验证的例子，我们给出使用正则表达式进行规则匹配的案例，对比之下，可以发现，使用正则表达式，不但能使程序结构清晰，也大大简化了代码量和我们的逻辑判断工作。<br>　　JAVA对正则表达式有着良好地支持，自JDK1.4，它提供了java.util.regex包，主要负责正则匹配的两个类为Pattern类和Matcher类，Pattern根据指定正则表达式字符串构建匹配模式，并利用matcher方法返回Matcher类对象实例，用于完成匹配，实际的匹配是交给Matcher完成的，Pattern类对象的构造是通过静态方法compile构造。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">boolean</span> <span class="title">regexVerify</span><span class="params">(String emailStr)</span></span>&#123;</span><br><span class="line">     Pattern p = Pattern.compile(<span class="string">"[\\w-\\.]+@[\\w-]+\\.[\\w-]+"</span>);</span><br><span class="line">     Matcher m = p.matcher(emailStr);</span><br><span class="line">     <span class="keyword">if</span>(m.matches())</span><br><span class="line">    	<span class="comment">//if(emailStr.matches("[\\w-\\.]+@[\\w-]+\\.[\\w-]+"))//String object has a good support to regexp</span></span><br><span class="line">      	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">      	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上代码可以看出，使用Java的正则表达式可以快速完成与大量逻辑判断相同的工作，且结构清晰，只要定义的正则表达式正确，<strong>其实在Java中一般不直接使用Pattern类和Matcher类完成正则模式匹配，而使用String自带的正则支持</strong>。因为正则匹配的对象都是文本字符串，目的就是为了验证文本规则，而String在Java中又是一个及其特殊的类，因此自从JDK1.4，引进正则表达式，String类就作了相应的修改，提供了split,matches,replaceAll,replaceFirst等方法。如上述代码注释的内容即为直接使用String对象的matches方法，其效果是完全一样的。</p>
<p>　　另外我想延伸的一点是，上述程序代码即正则表达式规则，虽然能够判别邮箱，但是邮箱通过的域名都是有限的（如163.com,qq.com），因此，本文提供精确的邮箱认证方式，即登录到邮箱服务器，验证邮箱是否存在，并返回验证结果。该功能需要Appache 的common-net.jar和dnsjava.jar包的支持。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> boolean verifyDNS(<span class="type">String</span> emailStr) &#123;</span><br><span class="line">    <span class="type">String</span> host = <span class="string">""</span>;</span><br><span class="line">    <span class="type">String</span> hostName = emailStr.split(<span class="string">"@"</span>)[<span class="number">1</span>];</span><br><span class="line">    <span class="type">Record</span>[] <span class="literal">result</span> = null;</span><br><span class="line">    <span class="type">SMTPClient</span> client = new <span class="type">SMTPClient</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        // 查找<span class="type">MX</span>记录</span><br><span class="line">        <span class="type">Lookup</span> lookup = new <span class="type">Lookup</span>(hostName, <span class="type">Type</span>.<span class="type">MX</span>);</span><br><span class="line">        lookup.run();</span><br><span class="line">        <span class="keyword">if</span> (lookup.getResult() != <span class="type">Lookup</span>.<span class="type">SUCCESSFUL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">result</span> = lookup.getAnswers();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 连接到邮箱服务器</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="literal">result</span>.length; i++) &#123;</span><br><span class="line">            host = <span class="literal">result</span>[i].getAdditionalName().toString();</span><br><span class="line">            client.connect(host);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="type">SMTPReply</span>.isPositiveCompletion(client.getReplyCode())) &#123;</span><br><span class="line">                client.disconnect();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        client.login(<span class="string">"xxxxxxxxxxxxxxxz.com"</span>);</span><br><span class="line">        client.setSender(<span class="string">"xxxxxxxxxxxx@xxxxxxxxxxxxxxx.com"</span>);</span><br><span class="line">    </span><br><span class="line">        client.addRecipient(emailStr);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">250</span> == client.getReplyCode()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (<span class="type">Exception</span> e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client.disconnect();</span><br><span class="line">        &#125; catch (<span class="type">Exception</span> e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码拷贝至<a href="http://www.eziep.net/details/80.html" target="_blank" rel="external">http://www.eziep.net/details/80.html</a>。以下是常见的正则匹配规则，参考自网上相关博客：</p>
<ul>
<li>匹配中文字符：[u4e00-u9fa5]</li>
<li>匹配空白行: ns*r </li>
<li>匹配html标签: ：&lt;(S<em>?)[^&gt;]</em>&gt;.<em>?|&lt;.</em>? /&gt; 或 &lt;/?[^&gt;]+&gt;</li>
<li>标准的匹配Email：w+([-+.]w+)<em>@w+([-.]w+)</em>.w+([-.]w+)* </li>
<li>匹配Url：：[a-zA-z]+://S* </li>
<li>匹配帐号是否合法: ^[a-zA-Z][a-zA-Z0-9_]{4,15}$ </li>
<li>匹配国内电话号码: d{3}-d{8}|d{4}-d{7} </li>
<li>匹配腾讯QQ号: [1-9][0-9]{4,} </li>
<li>匹配中国邮政编码: [1-9]d{5}(?!d) </li>
<li>匹配身份证：d{15}|d{18} </li>
<li>匹配ip地址：d+.d+.d+.d+</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：正则表达式主要用途是文本规则的匹配和验证，在处理字符串的程序或网页时，经常需要对用户输入进行正则验证，从而简化复杂的程序编写逻辑，因此，正则表达式实际上就是一种文本规则的验证工具。]]>
    
    </summary>
    
      <category term="技术交流" scheme="http://blog.zbvae.com/tags/%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[XML 学习]]></title>
    <link href="http://blog.zbvae.com/2015/07/11/XML-%E5%AD%A6%E4%B9%A0/"/>
    <id>http://blog.zbvae.com/2015/07/11/XML-学习/</id>
    <published>2015-07-11T05:44:06.000Z</published>
    <updated>2015-07-11T06:56:38.226Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：xml 作为一种可扩展的标记语言出现，其相对于html，主要是用于数据的保存，和数据结构信息的描述，标记格式并不固定，可以自行定制，但是必须要嵌套出现。下面介绍XML的基本格式和语法以及4种解析方式。<a id="more"></a></p>
<h2 id="1-XML文件">1.XML文件</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;users&gt;</span><br><span class="line"> 	&lt;user id=<span class="string">"1"</span>&gt;</span><br><span class="line">  		&lt;name&gt;Andrea&lt;/name&gt;</span><br><span class="line">  		&lt;age&gt;10&lt;/age&gt;</span><br><span class="line">  		&lt;<span class="keyword">gender</span>&gt;Male&lt;/<span class="keyword">gender</span>&gt;</span><br><span class="line"> 	&lt;/user&gt;</span><br><span class="line"> 	&lt;user id=<span class="string">"2"</span>&gt;</span><br><span class="line">  		&lt;name&gt;Bell&lt;/name&gt;</span><br><span class="line">  		&lt;age&gt;20&lt;/age&gt;</span><br><span class="line">  		&lt;<span class="keyword">gender</span>&gt;Male&lt;/<span class="keyword">gender</span>&gt;</span><br><span class="line"> 	&lt;/user&gt;</span><br><span class="line"> 	&lt;user id=<span class="string">"3"</span>&gt;</span><br><span class="line">  		&lt;name&gt;Calinda&lt;/name&gt;</span><br><span class="line">  		&lt;age&gt;30&lt;/age&gt;</span><br><span class="line">  		&lt;<span class="keyword">gender</span>&gt;Female&lt;/<span class="keyword">gender</span>&gt;</span><br><span class="line"> 	&lt;/user&gt;</span><br><span class="line">&lt;/users&gt;</span><br></pre></td></tr></table></figure>
<p>上面即使基本的XML文件，一个XML文件分为<strong>头信息</strong>和<strong>数据区</strong>，头信息即上述XML文件的第一行，<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</code>该头信息指定XML文件的版本和字符编码。除去第一行之后的内容都属于本XML文件的数据区，即数据保存部分。其中根元素为users，又包含3个user元素，user元素有id属性和3个标签元素，分别是name,age和gender。</p>
<h2 id="2-XML解析">2.XML解析</h2><p>　　下面介绍XML文件的四种解析方式，DOM方式，SAX解析，JDOM方式以及DOM4J方式，以简单工厂设计模式，先定义一个基本的XML解析接口作为产品接口,包含解析xml，和生成xml文件两个抽象方法，再定义4个具体的产品类即4种XML解析方式，以枚举方式描述。定义解析工厂如下。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="type">ParserMethod</span> <span class="keyword">enum</span></span><br><span class="line"> */</span><br><span class="line"><span class="keyword">enum</span> <span class="type">ParserMethod</span>&#123;</span><br><span class="line">	<span class="type">DOM</span>,<span class="type">SAX</span>,<span class="type">JDOM</span>,<span class="type">DOM4J</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * <span class="type">HelperFactory</span> to manufacture <span class="type">XmlHelper</span></span><br><span class="line"> * a <span class="keyword">static</span> <span class="keyword">method</span> <span class="keyword">is</span> needed</span><br><span class="line"> */</span><br><span class="line">class <span class="type">XmlHelperFactory</span>&#123;</span><br><span class="line">	public <span class="keyword">static</span> <span class="type">XmlHelper</span> newInstance(<span class="type">ParserMethod</span> <span class="keyword">method</span>)&#123;</span><br><span class="line">		<span class="type">XmlHelper</span> helper = null;</span><br><span class="line">		switch (<span class="keyword">method</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="type">DOM</span>:</span><br><span class="line">			helper = new <span class="type">DomHelper</span>();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="type">SAX</span>:</span><br><span class="line">			helper = new <span class="type">SaxHelper</span>();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="type">JDOM</span>:</span><br><span class="line">			helper = new <span class="type">JDomHelper</span>();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="type">DOM4J</span>:</span><br><span class="line">			helper = new <span class="type">Dom4JHelper</span>();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		default:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> helper;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * <span class="type">Base</span> <span class="type">XmlHelper</span> <span class="keyword">interface</span></span><br><span class="line"> */</span><br><span class="line"><span class="keyword">interface</span> <span class="type">XmlHelper</span>&#123;</span><br><span class="line">	<span class="type">void</span> parseXml(<span class="type">String</span> fileName)throws <span class="type">Exception</span> ;</span><br><span class="line">	<span class="type">void</span> writeXml(<span class="type">String</span> fileName) throws <span class="type">Exception</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1DOM解析">2.1DOM解析</h3><p>　　第一种即为W3C推荐的标准，DOM解析方式，以DOM树的形式将整个XML文件结构装载到内存中，要知道对于一个大而复杂的XML文件，在内存中建立它的DOM树形式是非常耗费空间的，因此DOM解析方式适合解析那些XML文件较小，内容需要经常修改，结构较为简单的。对于小XML文件，使用DOM解析方式，非常简单，且易于理解，由于DOM树存于内存中，支持随意读取，对于上述XML文件，只要将其想象成一颗树，根元素为users。解析代码如下：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * DomHelper, a concrete XmlHelper product</span><br><span class="line"> */</span></span><br><span class="line">class DomHelper implements XmlHelper &#123;</span><br><span class="line">	private DocumentBuilder builder = null;</span><br><span class="line"></span><br><span class="line">	public DomHelper<span class="params">()</span>&#123;</span><br><span class="line">		try&#123;</span><br><span class="line">			DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance<span class="params">()</span>;</span><br><span class="line">			builder = factory.newDocumentBuilder<span class="params">()</span>;</span><br><span class="line">		&#125;catch<span class="params">(Exception e)</span>&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	public void parseXml<span class="params">(String fileName)</span> throws Exception &#123;</span><br><span class="line">		</span><br><span class="line">		Document document = builder.parse<span class="params">(fileName)</span>;</span><br><span class="line"></span><br><span class="line">		NodeList nodes = document.getChildNodes<span class="params">()</span>;<span class="comment">//document.getElementsByTagName("users");</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span><span class="params">(int i=<span class="number">0</span>;i&lt;nodes.getLength<span class="params">()</span>;i++)</span>&#123;</span><br><span class="line">			Node users = nodes.item<span class="params">(i)</span>;</span><br><span class="line">			NodeList user = users.getChildNodes<span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span><span class="params">(int j=<span class="number">0</span>;j&lt;user.getLength<span class="params">()</span>;j++)</span>&#123;</span><br><span class="line">				Node userInfo = user.item<span class="params">(j)</span>;</span><br><span class="line">				NamedNodeMap userAttr = userInfo.getAttributes<span class="params">()</span>;</span><br><span class="line">				<span class="keyword">if</span><span class="params">(userAttr != null &amp;&amp; userAttr.getLength<span class="params">()</span> &gt; <span class="number">0</span>)</span>&#123;</span><br><span class="line">					<span class="keyword">for</span><span class="params">(int at=<span class="number">0</span>;at&lt;userAttr.getLength<span class="params">()</span>;at++)</span>&#123;</span><br><span class="line">						System.out.print<span class="params">(userAttr.item<span class="params">(at)</span>.getNodeName<span class="params">()</span> + </span><br><span class="line">						<span class="string">"="</span> + userAttr.item<span class="params">(at)</span>.getTextContent<span class="params">()</span>)</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				NodeList infoMeta = userInfo.getChildNodes<span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">for</span><span class="params">(int k=<span class="number">0</span>;k&lt;infoMeta.getLength<span class="params">()</span>;k++)</span>&#123;</span><br><span class="line">					<span class="keyword">if</span><span class="params">(infoMeta.item<span class="params">(k)</span>.getNodeName<span class="params">()</span> != <span class="string">"#text"</span>)</span>&#123;</span><br><span class="line">						System.out.print<span class="params">(infoMeta.item<span class="params">(k)</span>.getNodeName<span class="params">()</span> + </span><br><span class="line">						<span class="string">":"</span> + infoMeta.item<span class="params">(k)</span>.getTextContent<span class="params">()</span>)</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.print<span class="params">(<span class="string">"\t"</span>)</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println<span class="params">()</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void writeXml<span class="params">(String fileName)</span> throws Exception&#123;</span><br><span class="line">		Document document = builder.newDocument<span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">		Node users = document.createElement<span class="params">(<span class="string">"users"</span>)</span>;</span><br><span class="line">		Node user = document.createElement<span class="params">(<span class="string">"user"</span>)</span>;</span><br><span class="line">		Node name = document.createElement<span class="params">(<span class="string">"name"</span>)</span>;</span><br><span class="line">		Node age = document.createElement<span class="params">(<span class="string">"age"</span>)</span>;</span><br><span class="line">		Node gender = document.createElement<span class="params">(<span class="string">"gender"</span>)</span>;</span><br><span class="line"></span><br><span class="line">		name.appendChild<span class="params">(document.createTextNode<span class="params">(<span class="string">"zhangsan"</span>)</span>)</span>;</span><br><span class="line">		age.appendChild<span class="params">(document.createTextNode<span class="params">(<span class="string">"20"</span>)</span>)</span>;</span><br><span class="line">		gender.appendChild<span class="params">(document.createTextNode<span class="params">(<span class="string">"Male"</span>)</span>)</span>;</span><br><span class="line"></span><br><span class="line">		user.appendChild<span class="params">(name)</span>;</span><br><span class="line">		user.appendChild<span class="params">(age)</span>;</span><br><span class="line">		user.appendChild<span class="params">(gender)</span>;</span><br><span class="line"></span><br><span class="line">		users.appendChild<span class="params">(user)</span>;</span><br><span class="line">		document.appendChild<span class="params">(users)</span>;</span><br><span class="line"></span><br><span class="line">		TransformerFactory factory = TransformerFactory.newInstance<span class="params">()</span>;</span><br><span class="line">		Transformer transformer = factory.newTransformer<span class="params">()</span>;</span><br><span class="line">		transformer.setOutputProperty<span class="params">(OutputKeys.ENCODING,<span class="string">"utf-8"</span>)</span>;</span><br><span class="line"></span><br><span class="line">		DOMSource source = new DOMSource<span class="params">(document)</span>;</span><br><span class="line">		StreamResult result = new StreamResult<span class="params">(new File<span class="params">(fileName)</span>)</span>;</span><br><span class="line">		transformer.transform<span class="params">(source,result)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主函数中使用该种解析方式，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestXml</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//Simple factory mode</span></span><br><span class="line">		XmlHelper helper = XmlHelperFactory.newInstance(ParserMethod.JDOM);</span><br><span class="line">		helper.parseXml(<span class="string">"./example.xml"</span>);</span><br><span class="line">		helper.writeXml(<span class="string">"./output.xml"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<blockquote>
<p>id=1 name:Andrea  age:10  gender:Male<br>id=2 name:Bell  age:20  gender:Male<br>id=3 name:Calinda  age:30  gender:Female </p>
</blockquote>
<h3 id="2-2SAX解析">2.2SAX解析</h3><p>　　第二种方式为SAX解析方式，也是W3C提供的xml解析标准，与DOM解析方式不同的是，SAX解析以事件驱动方式进行，顺序部分解析，还必须定义自己的事件处理器类，该类继承自DefaultHandler类。主要方法有startDocument方法，文档开始自动调用，endDocument文档结束自动调用，startElement，元素开始自动调用（根元素和节点元素都是如此）,endElement，元素结束自动调用。characters方法遇到具体的元素结点内部值会自动调用，并解析。SAX解析方式不在乎文档大小，即时加载元素结点，存在于内存的东西相当少，因此SAX解析方式更加灵活，可以针对那些XML文档较大的解析，SAX易于读取，但<strong>不支持文件修改</strong>,因此writeXml方法无内容。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * SaxHelper, another XmlHelper product</span><br><span class="line"> */</span></span><br><span class="line">class SaxHelper implements XmlHelper &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> parseXml(<span class="keyword">String</span> fileName) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		SAXParserFactory factory = SAXParserFactory.newInstance();</span><br><span class="line">		SAXParser parser = factory.newSAXParser();</span><br><span class="line"></span><br><span class="line">		parser.parse(fileName,<span class="keyword">new</span> MySaxHandler());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> writeXml(<span class="keyword">String</span> fileName) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MySaxHandler extends DefaultHandler&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> startDocument() <span class="keyword">throws</span> SAXException &#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"&lt;?xml version=\"1.0\" encoding=\"utf-8\"&gt;"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> endDocument() <span class="keyword">throws</span> SAXException&#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"document ended!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> startElement(<span class="keyword">String</span> uri, <span class="keyword">String</span> localName, <span class="keyword">String</span> qName, Attributes attributes) <span class="keyword">throws</span> SAXException &#123;</span><br><span class="line">		System.out.<span class="built_in">print</span>(<span class="string">"&lt;"</span>);</span><br><span class="line">		System.out.<span class="built_in">print</span>(qName);</span><br><span class="line">		<span class="keyword">if</span>(attributes.getLength() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;attributes.getLength();i++)&#123;</span><br><span class="line">				System.out.<span class="built_in">print</span>(<span class="string">" "</span>+attributes.getQName(i)+<span class="string">"=\""</span> + attributes.getValue(i)+<span class="string">"\""</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.<span class="built_in">print</span>(<span class="string">"&gt;"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> endElement(<span class="keyword">String</span> uri,<span class="keyword">String</span> localName,<span class="keyword">String</span> qName) <span class="keyword">throws</span> SAXException &#123;</span><br><span class="line">		System.out.<span class="built_in">print</span>(<span class="string">"&lt;/"</span>);</span><br><span class="line">		System.out.<span class="built_in">print</span>(qName);</span><br><span class="line">		System.out.<span class="built_in">print</span>(<span class="string">"&gt;"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> characters(<span class="built_in">char</span>[] ch, <span class="built_in">int</span> start, <span class="built_in">int</span> length)&#123;</span><br><span class="line">		System.out.<span class="built_in">print</span>(<span class="keyword">new</span> <span class="keyword">String</span>(ch,start,length));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用主函数中的parseXml进行解析，输出如下：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">&lt;users&gt;</span><br><span class="line"> &lt;user id=<span class="string">"1"</span>&gt;</span><br><span class="line">  &lt;name&gt;Andrea&lt;/name&gt;</span><br><span class="line">  &lt;age&gt;10&lt;/age&gt;</span><br><span class="line">  &lt;<span class="keyword">gender</span>&gt;Male&lt;/<span class="keyword">gender</span>&gt;</span><br><span class="line"> &lt;/user&gt;</span><br><span class="line"> &lt;user id=<span class="string">"2"</span>&gt;</span><br><span class="line">  &lt;name&gt;Bell&lt;/name&gt;</span><br><span class="line">  &lt;age&gt;20&lt;/age&gt;</span><br><span class="line">  &lt;<span class="keyword">gender</span>&gt;Male&lt;/<span class="keyword">gender</span>&gt;</span><br><span class="line"> &lt;/user&gt;</span><br><span class="line"> &lt;user id=<span class="string">"3"</span>&gt;</span><br><span class="line">  &lt;name&gt;Calinda&lt;/name&gt;</span><br><span class="line">  &lt;age&gt;30&lt;/age&gt;</span><br><span class="line">  &lt;<span class="keyword">gender</span>&gt;Female&lt;/<span class="keyword">gender</span>&gt;</span><br><span class="line"> &lt;/user&gt;</span><br><span class="line">&lt;/users&gt;document ended!</span><br></pre></td></tr></table></figure></p>
<h3 id="2-3JDOM解析">2.3JDOM解析</h3><p>　　第三种方式JDOM方式，JDOM解析方式=DOM可以修改+SAX大文件读取，相对DOM解析方式，更加简单灵活，统一以Element组织。需要注意的是以下的JDOM和DOM4J解析都需要额外的jar包支持，下载之后放到某个目录，设置CLASSPATH环境变量即可使用。这两个jar包都非常容易下载到，所以这里就不再提供了，具体版本可根据你需要选择，一般不会有太大差别。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span><br><span class="line"> * JDomHelper, another XmlHelper product</span><br><span class="line"> */</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JDomHelper</span> <span class="keyword">implements</span> <span class="title">XmlHelper</span> </span>&#123;</span><br><span class="line">	public <span class="keyword">void</span> parseXml(<span class="built_in">String</span> fileName) throws Exception &#123;</span><br><span class="line">		SAXBuilder builder = <span class="keyword">new</span> SAXBuilder();</span><br><span class="line">		org.jdom2.Document <span class="built_in">document</span> = builder.build(<span class="keyword">new</span> File(fileName));</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">Element</span> users = <span class="built_in">document</span>.getRootElement();</span><br><span class="line">		<span class="built_in">List</span>&lt;<span class="built_in">Element</span>&gt; userList = users.getChildren();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;userList.size();i++)&#123;</span><br><span class="line">			<span class="built_in">Element</span> user = (<span class="built_in">Element</span>)userList.<span class="literal">get</span>(i);</span><br><span class="line">			<span class="built_in">List</span>&lt;Attribute&gt; userAttr = user.getAttributes();</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>;j&lt;userAttr.size();j++)&#123;</span><br><span class="line">				Attribute attr = userAttr.<span class="literal">get</span>(j);</span><br><span class="line">				System.out.<span class="built_in">print</span>(attr.getName()+<span class="string">":"</span>+attr.getValue());</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">			</span><br><span class="line">			<span class="built_in">List</span>&lt;<span class="built_in">Element</span>&gt; userInfo = user.getChildren();</span><br><span class="line">			<span class="keyword">for</span>(<span class="built_in">int</span> k=<span class="number">0</span>;k&lt;userInfo.size();k++)&#123;</span><br><span class="line">				<span class="built_in">Element</span> userMeta = userInfo.<span class="literal">get</span>(k);</span><br><span class="line">				System.out.println(userMeta.getName()+<span class="string">":"</span>+userMeta.getValue());</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public <span class="keyword">void</span> writeXml(<span class="built_in">String</span> fileName) throws Exception &#123;</span><br><span class="line">		<span class="built_in">Element</span> users = <span class="keyword">new</span> <span class="built_in">Element</span>(<span class="string">"users"</span>);</span><br><span class="line">		<span class="built_in">Element</span> user = <span class="keyword">new</span> <span class="built_in">Element</span>(<span class="string">"user"</span>);</span><br><span class="line">		<span class="built_in">Element</span> name = <span class="keyword">new</span> <span class="built_in">Element</span>(<span class="string">"name"</span>);</span><br><span class="line">		<span class="built_in">Element</span> age = <span class="keyword">new</span> <span class="built_in">Element</span>(<span class="string">"age"</span>);</span><br><span class="line">		<span class="built_in">Element</span> gender = <span class="keyword">new</span> <span class="built_in">Element</span>(<span class="string">"gender"</span>);</span><br><span class="line"></span><br><span class="line">		Attribute id = <span class="keyword">new</span> Attribute(<span class="string">"id"</span>,<span class="string">"1"</span>);</span><br><span class="line">		</span><br><span class="line">		name.setText(<span class="string">"zhangsan"</span>);</span><br><span class="line">		age.setText(<span class="string">"10"</span>);</span><br><span class="line">		gender.setText(<span class="string">"Male"</span>);</span><br><span class="line"></span><br><span class="line">		user.setAttribute(id);</span><br><span class="line">		user.addContent(name);</span><br><span class="line">		user.addContent(age);</span><br><span class="line">		user.addContent(gender);</span><br><span class="line"></span><br><span class="line">		users.addContent(user);</span><br><span class="line"></span><br><span class="line">		org.jdom2.Document <span class="built_in">document</span> = <span class="keyword">new</span> org.jdom2.Document(users);</span><br><span class="line">		XMLOutputter out = <span class="keyword">new</span> XMLOutputter();</span><br><span class="line">		out.setFormat(out.getFormat().setEncoding(<span class="string">"utf-8"</span>));</span><br><span class="line">		out.output(<span class="built_in">document</span>,<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(fileName)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-4DOM4J解析">2.4DOM4J解析</h3><p>　　第四种方式为DOM4J方式，Hibernate和Spring等框架都采用DOM4J方式支持XML文件的解析。生成xml文件时，Document对象是依靠DocumentHelper的createDocument完成</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Dom4JHelper, another XmlHelper product</span><br><span class="line"> */</span></span><br><span class="line">class Dom4JHelper implements XmlHelper &#123;</span><br><span class="line">	public void parseXml<span class="params">(String fileName)</span> throws Exception&#123;</span><br><span class="line">		SAXReader reader = new SAXReader<span class="params">()</span>;</span><br><span class="line">		org.dom4j.Document document = reader.read<span class="params">(new File<span class="params">(fileName)</span>)</span>;</span><br><span class="line">		</span><br><span class="line">		org.dom4j.Element users = document.getRootElement<span class="params">()</span>;</span><br><span class="line">		Iterator&lt;org.dom4j.Element&gt; userIter = users.elementIterator<span class="params">()</span>;</span><br><span class="line">		</span><br><span class="line">		while <span class="params">(userIter.hasNext<span class="params">()</span>)</span> &#123;</span><br><span class="line">			org.dom4j.Element user = userIter.next<span class="params">()</span>;</span><br><span class="line">			List&lt;org.dom4j.Attribute&gt; userAttr = user.attributes<span class="params">()</span>;</span><br><span class="line">			<span class="keyword">for</span><span class="params">(int i=<span class="number">0</span>;i&lt;userAttr.size<span class="params">()</span>;i++)</span>&#123;</span><br><span class="line">				org.dom4j.Attribute attr = userAttr.get<span class="params">(i)</span>;</span><br><span class="line">				System.out.println<span class="params">(attr.getName<span class="params">()</span>+<span class="string">":"</span>+attr.getValue<span class="params">()</span>)</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			Iterator&lt;org.dom4j.Element&gt; infoIter = user.elementIterator<span class="params">()</span>;</span><br><span class="line">			while<span class="params">(infoIter.hasNext<span class="params">()</span>)</span>&#123;</span><br><span class="line">				org.dom4j.Element info = infoIter.next<span class="params">()</span>;</span><br><span class="line">				System.out.println<span class="params">(info.getName<span class="params">()</span>+<span class="string">":"</span>+info.getText<span class="params">()</span>)</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println<span class="params">()</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void writeXml<span class="params">(String fileName)</span> throws Exception &#123;</span><br><span class="line">		org.dom4j.Document document = DocumentHelper.createDocument<span class="params">()</span>;</span><br><span class="line">		org.dom4j.Element users = document.addElement<span class="params">(<span class="string">"users"</span>)</span>;</span><br><span class="line">		org.dom4j.Element user = users.addElement<span class="params">(<span class="string">"user"</span>)</span>;</span><br><span class="line">		org.dom4j.Element name = user.addElement<span class="params">(<span class="string">"name"</span>)</span>;</span><br><span class="line">		org.dom4j.Element age = user.addElement<span class="params">(<span class="string">"age"</span>)</span>;</span><br><span class="line">		org.dom4j.Element gender = user.addElement<span class="params">(<span class="string">"gender"</span>)</span>;</span><br><span class="line">		</span><br><span class="line">		user.addAttribute<span class="params">(<span class="string">"id"</span>, <span class="string">"1"</span>)</span>;</span><br><span class="line">		</span><br><span class="line">		name.setText<span class="params">(<span class="string">"zhangsan"</span>)</span>;</span><br><span class="line">		age.setText<span class="params">(<span class="string">"20"</span>)</span>;</span><br><span class="line">		gender.setText<span class="params">(<span class="string">"Male"</span>)</span>;</span><br><span class="line">		</span><br><span class="line">		OutputFormat format = OutputFormat.createPrettyPrint<span class="params">()</span>;	</span><br><span class="line">		format.setEncoding<span class="params">(<span class="string">"utf-8"</span>)</span>;</span><br><span class="line">		XMLWriter writer = new XMLWriter<span class="params">(new FileOutputStream<span class="params">(new File<span class="params">(fileName)</span>)</span>)</span>;</span><br><span class="line">		writer.write<span class="params">(document)</span>;</span><br><span class="line">		writer.close<span class="params">()</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：xml 作为一种可扩展的标记语言出现，其相对于html，主要是用于数据的保存，和数据结构信息的描述，标记格式并不固定，可以自行定制，但是必须要嵌套出现。下面介绍XML的基本格式和语法以及4种解析方式。]]>
    
    </summary>
    
      <category term="技术交流" scheme="http://blog.zbvae.com/tags/%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java JDBC 学习]]></title>
    <link href="http://blog.zbvae.com/2015/07/11/Java-JDBC-%E5%AD%A6%E4%B9%A0/"/>
    <id>http://blog.zbvae.com/2015/07/11/Java-JDBC-学习/</id>
    <published>2015-07-11T04:57:59.000Z</published>
    <updated>2015-08-10T08:35:34.333Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：一些大型程序免不了要连接数据库，很多网络程序更是如此，因此掌握数据库的连接手段非常必要，本文以Oracle和mysql数据库为例，介绍Java程序通过jdbc连接并操作数据库的示例。<a id="more"></a></p>
<h2 id="1-JDBC连接数据库">1.JDBC连接数据库</h2><p>　　Java通过JDBC连接和操作数据库，每个数据库厂商都定制了一套可以通过Java连接的JDBC接口，以jar包的形式发布。要实现Java程序连接数据库，受限需要下载相应的数据库可支持的JDBC jar包，Oracle安装目录下提供了与jdbc操作相关的很多jar文件，可直接使用，而mysql需要自己在网上下载，但是本人发现，通过classpath设置数据库驱动（即jar包），本地Java程序还是操作不了，因此，本文在eclipse环境下进行。</p>
<h2 id="2-Eclipse_程序">2.Eclipse 程序</h2><h3 id="2-1准备">2.1准备</h3><p>　　首先，新建连接数据库的程序项目，设置项目属性，java build path，选择add external jar，上传项目需要的两个jar文件（oracle和mysql分别需要使用的驱动）.</p>
<center><img src="/images/jdbcjar.png" alt="add jdbc jar to eclipse"></center>

<h3 id="2-2代码编写">2.2代码编写</h3><p>　　 下面正式开始代码的编写。我们新建DbConnection和DbHelper类，DbConnection负责通过制定连接数据库类型和配置文件路径打开和关闭与指定数据库的连接，将该连接作为参数设置到DbHelper实例，并由此类完成与指定数据库相关的增删改查操作。<br>DbConnection类：建立数据库连接有以下一般步骤:</p>
<ol>
<li>加载驱动程序，已知驱动程序类名，不知其结构，利用Java反射加载驱动，Class.forName(“驱动程序包名.类名”)</li>
<li>准备连接url，针对不同的数据库有不同的url，但无一例外，都需要提供指定的数据库实例名</li>
<li>准备连接数据库实例的用户名和密码</li>
<li>利用java.sql包下DriverManager类打开指定数据库连接（以连接url,用户名,密码作为参数）</li>
</ol>
<p>本程序，以properties文件组织数据库连接各参数,Properties类提供了Java属性文件操作的支持，实际上是一个HashTale,不过它的键值都必须是String类型。调用Properties实例对象的load方法可以将属性文件加载到程序中，并利用getProperty读取指定key的值。properties文件的内容如下所示：</p>
<blockquote>
<p>#Oracle<br>oracleDriver=oracle.jdbc.driver.OracleDriver<br>oracleUrl=jdbc:oracle:thin:@127.0.0.1:1521:test<br>oracleUsername=scott<br>oraclePassword=123456<br>#mysql<br>mysqlDriver=com.mysql.jdbc.Driver<br>mysqlUrl=jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=gbk<br>mysqlUsername=root<br>mysqlPassword=123456</p>
</blockquote>
<p>DbConnection类通过制定数据库类型和配置文件路径作为构造函数参数，负责建立和制定数据库的连接：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> DbConnection&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">String</span> sqlType = <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">String</span> proPath = <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">private</span> Connection conn = <span class="literal">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> DbConnection(<span class="built_in">String</span> sqlType,<span class="built_in">String</span> proPath)&#123;</span><br><span class="line">		<span class="keyword">this</span>.sqlType = sqlType;</span><br><span class="line">		<span class="keyword">this</span>.proPath = proPath;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Connection openConnection()&#123;</span><br><span class="line">		Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">		InputStream <span class="keyword">in</span> = <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">in</span> = <span class="keyword">new</span> FileInputStream(proPath);</span><br><span class="line">			pro.load(<span class="keyword">in</span>);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">String</span> driverName = pro.getProperty(sqlType+<span class="string">"Driver"</span>);</span><br><span class="line">		<span class="built_in">String</span> connUrl = pro.getProperty(sqlType+<span class="string">"Url"</span>);</span><br><span class="line">		<span class="built_in">String</span> userName = pro.getProperty(sqlType+<span class="string">"Username"</span>);</span><br><span class="line">		<span class="built_in">String</span> passWord = pro.getProperty(sqlType+<span class="string">"Password"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			Class.forName(driverName);</span><br><span class="line">			conn = DriverManager.getConnection(connUrl,userName,passWord);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">			System.out.println(<span class="string">"Database connect error"</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> conn;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">void</span> closeConnection()&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.conn.close();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　得到连接之后，便可以利用此连接来进行数据库的增删改查操作了，DbHelper类则提供了相关执行函数，doQuery查询函数和doUpdate更新函数，以指定sql语句作为函数参数，在函数中，创建PreparedStatement（预编译的,对于批量处理可以大大提高效率）来封装sql语句，并调用相应的executeQuery和executeUpdate函数执行数据库操作。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">DbHelper</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Connection conn = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DbHelper</span>(<span class="params">Connection conn</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.conn = conn;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doQuery</span>(<span class="params">String queryStr,String... wheres</span>)</span>&#123;</span><br><span class="line">		ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">		PreparedStatement pst = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			pst = <span class="keyword">this</span>.conn.prepareStatement(queryStr);</span><br><span class="line">			<span class="keyword">if</span>(wheres != <span class="keyword">null</span> &amp;&amp; wheres.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;wheres.length;i++)&#123;</span><br><span class="line">					pst.setString(i+<span class="number">1</span>, wheres[i]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			rs = pst.executeQuery();</span><br><span class="line">			<span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">				System.<span class="keyword">out</span>.println(rs.getString(<span class="number">2</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				rs.close();</span><br><span class="line">				pst.close();</span><br><span class="line">			&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doUpdate</span>(<span class="params">String updateStr,String... wheres</span>)</span>&#123;</span><br><span class="line">		PreparedStatement pst = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			pst = <span class="keyword">this</span>.conn.prepareStatement(updateStr);</span><br><span class="line">			<span class="keyword">if</span>(wheres != <span class="keyword">null</span> &amp;&amp; wheres.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;wheres.length;i++)&#123;</span><br><span class="line">					pst.setString(i+<span class="number">1</span>, wheres[i]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			count = pst.executeUpdate();</span><br><span class="line">			System.<span class="keyword">out</span>.println(count+<span class="string">" lines have been updated"</span>);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				pst.close();</span><br><span class="line">			&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上代码中也可以发现，PreparedStatement还可以设置sql语句中的参数。executeQuery返回的是ResultSet类型的结果集，该结果集以游标形式访问，并通过指定字段号（从1开始）或字段名，获取数据库表中查询得到的内容。executeUpdate返回更新影响的条目数，大于0表示有更新。主程序如下：</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> TestJDBC&#123;</span><br><span class="line">	<span class="keyword">public</span> static void main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">		<span class="built_in">String</span> sqlType = <span class="string">"mysql"</span>;</span><br><span class="line">		<span class="built_in">String</span> proPath = <span class="string">"./connection.properties"</span>;</span><br><span class="line"></span><br><span class="line">		DbConnection dbConnection = <span class="keyword">new</span> DbConnection(sqlType,proPath);</span><br><span class="line"></span><br><span class="line">		Connection conn = dbConnection.openConnection();</span><br><span class="line">		DbHelper dbHelper = <span class="keyword">new</span> DbHelper(conn);</span><br><span class="line">		</span><br><span class="line">		/*</span><br><span class="line">		<span class="built_in">String</span> queryStr = <span class="string">"select * from event where type=? and happen&gt;?"</span>;</span><br><span class="line">		dbHelper.doQuery(queryStr,<span class="string">"litter"</span>,<span class="string">"1995"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">String</span> updateStr = <span class="string">"insert into event values(?,?,?,?)"</span>;</span><br><span class="line">		dbHelper.doUpdate(updateStr,<span class="string">"Sufa"</span>,<span class="string">"1997-07-01"</span>,<span class="string">"vet"</span>,<span class="string">"headache"</span>);</span><br><span class="line">		*/</span><br><span class="line">		<span class="built_in">String</span> queryStr = <span class="string">"select * from emp"</span>;</span><br><span class="line">		dbHelper.doQuery(queryStr);</span><br><span class="line">		</span><br><span class="line">		dbConnection.closeConnection();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序成功查询到内容，也成功更新，输出如下：</p>
<blockquote>
<p>Fluffy<br>1 lines have been updated</p>
</blockquote>
<p>可以根据上述代码自行调整sql语句以及连接的数据库类型，需要注意的是，查询或更新结束，需要及时<strong>关闭</strong>与数据库相关的各个资源，如ResultSet对象，PreparedStatement对象，Connection对象。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：一些大型程序免不了要连接数据库，很多网络程序更是如此，因此掌握数据库的连接手段非常必要，本文以Oracle和mysql数据库为例，介绍Java程序通过jdbc连接并操作数据库的示例。]]>
    
    </summary>
    
      <category term="Java学习" scheme="http://blog.zbvae.com/tags/Java%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 多线程]]></title>
    <link href="http://blog.zbvae.com/2015/07/11/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://blog.zbvae.com/2015/07/11/Java-多线程/</id>
    <published>2015-07-11T03:27:02.000Z</published>
    <updated>2015-07-11T06:55:55.566Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：Java是一门支持多线程的语言，其对多线程操作提供了很大的方便，而多线程在现在很多的程序甚至企业级项目中都会使用到，因此，学好Java多线程知识对提高自己的编程和应用水平都有很大的帮助。 <a id="more"></a></p>
<h2 id="1-进程与线程的区别">1.进程与线程的区别</h2><p>　　在介绍Java多线程编程之前，首先我们需要掌握线程的概念，即线程是什么。要了解线程是什么，还需要掌握进程的概念。</p>
<p>　　进程指的就是一个执行程序单位。在计算机发展初期，操作系统是单进程的，如DOS系统，这样一旦有病毒侵入，电脑立即死机，因为单进程环境下，只会有一个进程参与运行，这也显示单进程操作系统的不足。后期，出现Windows操作系统，它是支持多进程的，一个时间段可以有多个进程同时运行，因此即使有病毒侵入，也不会影响其它程序的运行。但是这里需要注意的是，多进程可以在同一时间段同时运行，同一时间点只能运行一个进程。而多进程同时运行，正是由于CPU的轮询机制非常快，我们感觉不到，所以就认为是同时运行，比如，现在我们可以在编辑word的同时，听听音乐，那么这里的word程序和音乐播放器程序是同时运行的两个进程，正是由于CPU轮询的非常快。这样可以看出，多进程提高了CPU的使用效率，明显优于单进程。</p>
<p>　　线程之于进程，就相当于原子之于分子，一个化学分子由多个原子组成，同样线程也是对执行程序单位的进一步划分，一个进程可以由多个线程参与运行，它们的主要区别在于，进程有自己的内存空间，而进程的多个线程共享该进程的内存空间。我们也可以发现很多多线程运行的例子，例如我们打开Eclipse编辑器，在编写Java代码时，如果出现明显的错误，则编辑器会自动出现红色提示，这种红色提示说明在Eclipse程序中包含有多个线程同时运行，其中有一个线程就是对我们代码错误进行检查。多线程提高了执行程序的运行效率，因为一旦CPU轮询到该执行程序，我们使用多线程参与运行明显没有浪费这次CPU。</p>
<h2 id="2-线程状态">2.线程状态</h2><p>　　相信现在大家对多线程的概念有一定的了解了。那么线程的五种状态有必要介绍一下：新建，就绪，运行，阻塞，死亡状态，下面的线程状态图很好地展示了各个状态及其产生原因，该图借鉴于<a href="http://wangqiang6028.iteye.com/blog/1887342" target="_blank" rel="external">http://wangqiang6028.iteye.com/blog/1887342</a>。</p>
<p><center><img src="/images/thread.jpg" alt="线程状态图"></center><br>现在看不懂没关系，等到下面先创建出一个进程，之后大家就知道它是怎么回事了，以及怎样使线程处于就绪，运行阻塞和死亡状态。</p>
<h2 id="3-线程的创建">3.线程的创建</h2><p>　　Java给我们提供了两种线程创建方式：</p>
<ul>
<li>继承Thread类；</li>
<li>实现Runnable接口</li>
</ul>
<p>　　先来介绍一下这两种方式：</p>
<blockquote>
<p>继承Thread类非常简单，方便，该类实例化对象可以直接通过调用start()方法使其运行；<br>实现Runnable接口的实例化对象必须由Thread包裹起来才可以运行，即将实现Runnable接口的示例对象作为参数传递给Thread构造函数，然后再调用start()方法；</p>
</blockquote>
<p>　由于Java的单继承特性，继承了Thread类之后，就不可以再继承其它类，因此一般采用实现Runnable接口的方式，保留一个继承类的权利。从JDK中Thread类的源代码可以看出，Thread类也实现了Runnable接口，实际上是一种<strong>代理设计模式</strong>，真实场景还是Runnable接口，而Thread类是一种代理场景，它提供了更多的功能，其start方法为执行线程分配资源，并间接调用Runnable类的run方法。</p>
<h3 id="3-1继承Thread类">3.1继承Thread类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMultiThread</span></span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  		Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">  		worker.start();</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"> 			System.out.println(<span class="string">"hello"</span>);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以获取当前线程名称。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TestMultiThread</span>&#123;</span></span><br><span class="line"> 	public static void main(<span class="type">String</span>[] args) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">  		<span class="type">Worker</span> worker1 = <span class="keyword">new</span> <span class="type">Worker</span>();</span><br><span class="line">  		<span class="type">Worker</span> worker2 = <span class="keyword">new</span> <span class="type">Worker</span>();</span><br><span class="line">  		worker1.start();</span><br><span class="line">  		worker2.start();</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Thread</span> &#123;</span></span><br><span class="line"> 	public void run()&#123;</span><br><span class="line">  		<span class="type">System</span>.out.println(<span class="type">Thread</span>.currentThread().getName() + <span class="string">"----&gt;hello"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出如下：</p>
<blockquote>
<p>Thread-1——&gt;hello<br>Thread-0——&gt;hello</p>
</blockquote>
<h3 id="3-2实现Runnable接口">3.2实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMultiThread</span></span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  		Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">  		Thread t1 = <span class="keyword">new</span> Thread(worker,<span class="string">"worker1"</span>);</span><br><span class="line">  		Thread t2 = <span class="keyword">new</span> Thread(worker,<span class="string">"worker2"</span>);</span><br><span class="line">  		t1.start();</span><br><span class="line">  		t2.start();</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">  		System.out.println(Thread.currentThread().getName() + <span class="string">"----&gt;hello"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<blockquote>
<p>worker1——&gt;hello<br>worker2——&gt;hello</p>
</blockquote>
<p>我们发现现在线程有了新的名字，那是因为我们在使用woker实例对象来实例化Thread对象时，提供了名称。</p>
<h2 id="4-多线程实际案例">4.多线程实际案例</h2><p>　　多线程并发运行能够很好地提高执行程序的运行效率，也可以方便快速地解决很多实际问题。</p>
<h3 id="4-1争用">4.1争用</h3><p>　　但是多线程并发运行的环境下，一旦多个线程共享争用同一资源，这时便可能会发生一些更新错误。例如线程A在使用该共享资源时，还没有放弃使用权，线程B也获得CPU使用权，也来使用该共享资源并对其进行修改，可是线程A还不知道情况，只是知道自己刚使用该共享资源的初始状态，这就会造成读取的写入错误。下面以经典的<strong>卖票程序</strong>来模拟多线程环境下的并发争用共享资源问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMultiThread</span></span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  		SoldWindow sw = <span class="keyword">new</span> SoldWindow();</span><br><span class="line">  		Thread t1 = <span class="keyword">new</span> Thread(sw,<span class="string">"window1"</span>);</span><br><span class="line">  		Thread t2 = <span class="keyword">new</span> Thread(sw,<span class="string">"window2"</span>);</span><br><span class="line">  		t1.start();</span><br><span class="line">  		t2.start();</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoldWindow</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">5</span>;<span class="comment">//shared resource</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">  		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">     		<span class="keyword">if</span>(<span class="keyword">this</span>.tickets &gt; <span class="number">0</span>)&#123;</span><br><span class="line">     			<span class="keyword">try</span>&#123;</span><br><span class="line">      				Thread.sleep(<span class="number">200</span>);</span><br><span class="line">     			&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">     			&#125;</span><br><span class="line">     			System.out.println(Thread.currentThread().getName() + <span class="string">" sold No."</span> + <span class="keyword">this</span>.tickets + <span class="string">" tickets!"</span>);</span><br><span class="line">     			<span class="keyword">this</span>.tickets--;</span><br><span class="line">    		&#125;</span><br><span class="line">   		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出如下：</p>
<blockquote>
<p>window1 sold No.5 tickets!<br>window2 sold No.5 tickets!<br>window1 sold No.3 tickets!<br>window2 sold No.3 tickets!<br>window1 sold No.1 tickets!<br>window2 sold No.1 tickets!</p>
</blockquote>
<p>首先以上代码也可以说明，使用Runnable接口方式实现多线程可以达到资源共享的目的，当然你也可以通过static实现共享。以上输出肯定是不合理的，导致这种不合理的关键在于由于售票窗口网络的延迟，本来一共有5张票，窗口1本来想取第5张票卖出去，可是网络延迟了，它只好等待200毫秒，这个时候窗口2抢到了资源，并卖出了第5张票，把票数更改为4，可是窗口1延迟结束，它的初始票数就是5，所以它也卖出了第5张票，并把票数更改为3。解决这种方法的关键在于，不要让多个线程同时有机会接触共享资源，对于共享资源，一定要保证一次只能由一个线程使用，必须等到该线程使用完，其他线程才能获得使用权，即保证操作的原子性。给容易发生资源抢占的地方（代码段）加锁，在Java中称为同步对象锁，可以成功保证此段代码某个时间段只能被一个线程执行，执行结束，自动释放锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoldWindow</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">5</span>;<span class="comment">//shared resource</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">  		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">   			<span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">	    		<span class="keyword">if</span>(<span class="keyword">this</span>.tickets &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		     		<span class="keyword">try</span>&#123;</span><br><span class="line">		      			Thread.sleep(<span class="number">200</span>);</span><br><span class="line">		     		&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">		     		&#125;</span><br><span class="line">		     		System.out.println(Thread.currentThread().getName() + <span class="string">" sold No."</span> + <span class="keyword">this</span>.tickets + <span class="string">" tickets!"</span>);</span><br><span class="line">		     		<span class="keyword">this</span>.tickets--;</span><br><span class="line">		    	&#125;</span><br><span class="line">   			&#125;</span><br><span class="line">  		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改售票窗口类的代码如上，主要是为与tickets变量有关联的代码段加上同步锁，这样便可以正常输出了：</p>
<blockquote>
<p>window2 sold No.5 tickets!<br>window1 sold No.4 tickets!<br>window2 sold No.3 tickets!<br>window2 sold No.2 tickets!<br>window2 sold No.1 tickets!</p>
</blockquote>
<p>也可以以同步方法的方式，解决如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoldWindow</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">5</span>;<span class="comment">//shared resource</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">   			sale();</span><br><span class="line">  		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line">  		<span class="keyword">if</span>(<span class="keyword">this</span>.tickets &gt; <span class="number">0</span>)&#123;</span><br><span class="line">	   		<span class="keyword">try</span>&#123;</span><br><span class="line">	    		Thread.sleep(<span class="number">200</span>);</span><br><span class="line">	   		&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">	   		&#125;</span><br><span class="line">	   		System.out.println(Thread.currentThread().getName() + <span class="string">" sold No."</span> + <span class="keyword">this</span>.tickets + <span class="string">" tickets!"</span>);</span><br><span class="line">	   		<span class="keyword">this</span>.tickets--;</span><br><span class="line">  		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用同步方法，输出与上面一样，同样能达到同步解决的目的。</p>
<h3 id="4-2死锁">4.2死锁</h3><p>　　同步要恰当使用，过多使用同步则会造成死锁，死锁的发生在于，线程1在等待线程2释放锁，而线程2也在等待线程1释放锁，因此二者僵持不下，造成程序无法运行。下面以一个例子介绍死锁，售货员等着顾客给钱给他，然后再给他食物；顾客等着售货员给食物给他，然后再给他钱。双方都在等着对方。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Saler&#123;</span><br><span class="line"> 	public synchronized void <span class="keyword">say</span>(<span class="keyword">Person</span> per)&#123;</span><br><span class="line">  		System.out.println(<span class="string">"Give me money, I will give you food"</span>);</span><br><span class="line">  		try&#123;</span><br><span class="line">    		Thread.sleep(500);  </span><br><span class="line">  		&#125;catch(Exception e)&#123;</span><br><span class="line">  		&#125; </span><br><span class="line">  		per.give();</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public synchronized void give()&#123;</span><br><span class="line">  		System.out.println(<span class="string">"give you food, I get lots of money"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class <span class="keyword">Person</span>&#123;</span><br><span class="line"> 	public synchronized void <span class="keyword">say</span>(Saler sal)&#123;</span><br><span class="line">  		System.out.println(<span class="string">"Give me food, I will give you money"</span>);</span><br><span class="line">  		try&#123;</span><br><span class="line">    		Thread.sleep(500);  </span><br><span class="line">  		&#125;catch(Exception e)&#123;</span><br><span class="line">  		&#125;  </span><br><span class="line">  		sal.give();</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public synchronized void give()&#123;</span><br><span class="line">  		System.out.println(<span class="string">"give you money, I eat lost of food"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DeadLock implements Runnable &#123;</span><br><span class="line"> 	private Saler sal = new Saler();</span><br><span class="line"> 	private <span class="keyword">Person</span> per = new <span class="keyword">Person</span>();</span><br><span class="line"></span><br><span class="line"> 	public DeadLock()&#123;</span><br><span class="line">  		new Thread(this).start();</span><br><span class="line">  		sal.<span class="keyword">say</span>(per);</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public void run()&#123;</span><br><span class="line">  		per.<span class="keyword">say</span>(sal);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有在主程序main函数加入一条语句创建死锁线程，new DeadLock(),程序输出如下：</p>
<blockquote>
<p>Give me money, I will give you food<br>Give me food, I will give you money</p>
</blockquote>
<p>程序卡死在这里，无法继续运行下去。将线程类构造函数里的两个语句颠倒顺序将得到正常输出如下：</p>
<blockquote>
<p>Give me money, I will give you food<br>give you money, I eat lost of food<br>Give me food, I will give you money<br>give you food, I get lots of money</p>
</blockquote>
<h3 id="4-3互斥">4.3互斥</h3><p>　　下面以多线程中一个经典例子，生产者与消费者来作为本文的结束。伴随此例子，会介绍Obejct自带的wait和notify方法来改变线程执行状态，从而实现线程互斥运行，协同工作。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 货物栈</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">class</span> GoodStack&#123;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">char</span> goods[] = <span class="keyword">null</span>;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">size</span> = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">public</span> GoodStack()&#123;</span><br><span class="line">  		<span class="keyword">this</span>(<span class="number">5</span>);<span class="comment">//default size is 5</span></span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">public</span> GoodStack(<span class="keyword">int</span> <span class="keyword">size</span>)&#123;</span><br><span class="line">  		<span class="keyword">this</span>.<span class="keyword">size</span> = <span class="keyword">size</span>;</span><br><span class="line">  		<span class="keyword">this</span>.goods = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">size</span>];</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">boolean</span> isFull()&#123;</span><br><span class="line">  		<span class="keyword">if</span>(<span class="keyword">this</span>.<span class="keyword">count</span> &gt;= <span class="keyword">this</span>.<span class="keyword">size</span>)</span><br><span class="line">   			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  		<span class="keyword">else</span></span><br><span class="line">   			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">boolean</span> isEmpty()&#123;</span><br><span class="line">  		<span class="keyword">if</span>(<span class="keyword">this</span>.<span class="keyword">count</span> == <span class="number">0</span>)</span><br><span class="line">   			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  		<span class="keyword">else</span></span><br><span class="line">   			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="keyword">push</span>(<span class="keyword">char</span> c)&#123;</span><br><span class="line">  		<span class="keyword">if</span>(<span class="keyword">this</span>.isFull())&#123;</span><br><span class="line">   			System.out.<span class="keyword">println</span>(<span class="string">"GoodStack is full"</span>);</span><br><span class="line">	   		<span class="keyword">try</span>&#123;</span><br><span class="line">	    		<span class="keyword">super</span>.wait();</span><br><span class="line">	   		&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">	   		&#125;		</span><br><span class="line">	  	&#125;</span><br><span class="line">   </span><br><span class="line">	  	<span class="keyword">this</span>.goods[<span class="keyword">count</span>++] = c;</span><br><span class="line">	  	System.out.<span class="keyword">println</span>(<span class="string">"produce: "</span> + c);</span><br><span class="line">	  	<span class="keyword">super</span>.notify();</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">char</span> <span class="keyword">pop</span>()&#123;</span><br><span class="line">  		<span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty())&#123;</span><br><span class="line">  			System.out.<span class="keyword">println</span>(<span class="string">"GoodStack is empty"</span>);</span><br><span class="line">   			<span class="keyword">try</span> &#123;</span><br><span class="line">    			<span class="keyword">super</span>.wait();</span><br><span class="line">   			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   			&#125;</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="keyword">char</span> c = <span class="keyword">this</span>.goods[--<span class="keyword">count</span>];</span><br><span class="line">  		System.out.<span class="keyword">println</span>(<span class="string">"consume: "</span> + c);</span><br><span class="line">  		<span class="keyword">super</span>.notify();</span><br><span class="line">  		<span class="keyword">return</span> c;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Producer <span class="keyword">implements</span> Runnable &#123;</span><br><span class="line"> 	<span class="keyword">private</span> GoodStack stack = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">public</span> Producer(GoodStack stack)&#123;</span><br><span class="line">  		<span class="keyword">this</span>.stack = stack;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> produce()&#123;</span><br><span class="line">  		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">   			<span class="keyword">char</span> c = (<span class="keyword">char</span>)(<span class="string">'a'</span> + i);</span><br><span class="line">   			<span class="keyword">this</span>.stack.<span class="keyword">push</span>(c);</span><br><span class="line">  		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> run()&#123;</span><br><span class="line">  		<span class="keyword">this</span>.produce();</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Consumer <span class="keyword">implements</span> Runnable &#123;</span><br><span class="line"> 	<span class="keyword">private</span> GoodStack stack = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">public</span> Consumer(GoodStack stack)&#123;</span><br><span class="line">  		<span class="keyword">this</span>.stack = stack;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> consume()&#123;</span><br><span class="line">  		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">   			<span class="keyword">this</span>.stack.<span class="keyword">pop</span>();</span><br><span class="line">  		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> run()&#123;</span><br><span class="line">  		<span class="keyword">try</span> &#123;</span><br><span class="line">   			Thread.sleep(<span class="number">100</span>);</span><br><span class="line">  		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="keyword">this</span>.consume();</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> TestMultiThread&#123;</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  		<span class="comment">//mutual exclusion in producer and consumer</span></span><br><span class="line">  		GoodStack stack = <span class="keyword">new</span> GoodStack();</span><br><span class="line">  		Producer producer = <span class="keyword">new</span> Producer(stack);</span><br><span class="line">  		Consumer consumer = <span class="keyword">new</span> Consumer(stack);</span><br><span class="line">  		<span class="keyword">new</span> Thread(producer).start();</span><br><span class="line">  		<span class="keyword">new</span> Thread(consumer).start();</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出如下：</p>
<blockquote>
<p>produce: a<br>produce: b<br>produce: c<br>produce: d<br>produce: e<br>GoodStack is full<br>consume: e<br>produce: f<br>GoodStack is full<br>consume: f<br>consume: d<br>consume: c<br>consume: b<br>consume: a<br>GoodStack is empty<br>produce: g<br>produce: h<br>produce: i<br>produce: j<br>consume: j<br>consume: i<br>consume: h<br>consume: g</p>
</blockquote>
<p>Obejct类提供了三个方法支持多线程，分别是wait()，notify()，notifyAll()。实际上是切换线程的互斥运行状态，这些方法必须在同步方法中才可以调用。wait方法会抛出异常，线程互斥的关键逻辑在于：</p>
<ul>
<li>一旦栈满了，生产者线程wait，交出CPU使用权，并随时唤醒消费者线程进行消费；</li>
<li>一旦栈空了，消费者线程wait，交出CPU使用权，并随时唤醒生产者线程再次生产</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：Java是一门支持多线程的语言，其对多线程操作提供了很大的方便，而多线程在现在很多的程序甚至企业级项目中都会使用到，因此，学好Java多线程知识对提高自己的编程和应用水平都有很大的帮助。]]>
    
    </summary>
    
      <category term="Java学习" scheme="http://blog.zbvae.com/tags/Java%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 反射]]></title>
    <link href="http://blog.zbvae.com/2015/07/11/Java-%E5%8F%8D%E5%B0%84/"/>
    <id>http://blog.zbvae.com/2015/07/11/Java-反射/</id>
    <published>2015-07-11T02:58:50.000Z</published>
    <updated>2015-07-11T06:53:07.918Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：Java反射知识是Java基础学习中非常重要的知识点之一，初期还体会不到反射机制的强大和神奇，到了后期Java Web和各种框架，包括Java对象反序列化等，这些都是以Java反射作为支撑，因此掌握Java反射是非常有必要的。<a id="more"></a></p>
<h2 id="1-引例">1.引例</h2><p>　　在学习Java反射知识之前，先看一个基本例子，这个例子展示了，Java对象最普通的构造和使用方式，也是Java基础学习最初期需要掌握的部分。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class TestReflection&#123;</span><br><span class="line"> 	public static void main(String<span class="comment">[]</span> args) &#123;</span><br><span class="line">  		<span class="keyword">Person</span> per = new <span class="keyword">Person</span>(<span class="string">"zhangsan"</span>, 20);</span><br><span class="line">  		System.out.println(per);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class <span class="keyword">Person</span>&#123;</span><br><span class="line"> 	private String name;</span><br><span class="line"> 	private int age;</span><br><span class="line"> 	public <span class="keyword">Person</span>()&#123;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public <span class="keyword">Person</span>(String name, int age)&#123;</span><br><span class="line">  		this.name = name;</span><br><span class="line">  		this.age = age;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public String getName() &#123;</span><br><span class="line">     	return this.name;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public int getAge() &#123;</span><br><span class="line">     	return this.age;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public void setName(String name) &#123;</span><br><span class="line">     	this.name = name;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public void setAge(int age) &#123;</span><br><span class="line">     	this.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"> 	public String toString()&#123;</span><br><span class="line">  		return <span class="string">"Per(name = "</span> + this.getName() + <span class="string">", age = "</span> + this.getAge() + <span class="string">")"</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出如下内容：</p>
<blockquote>
<p>Per(name = zhangsan, age = 20)</p>
</blockquote>
<h2 id="2-Java_反射">2.Java 反射</h2><p>以上这种方式相信任何一个学习过Java的都很容易看懂，也容易理解的正常方式，即先有类，然后实例化出对象；如果由一个对象得到关于该类的所有信息，这就是反射所在。修改main函数如下：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class TestReflection&#123;</span><br><span class="line">  	public static void main(String<span class="comment">[]</span> args) &#123;</span><br><span class="line">   		<span class="keyword">Person</span> per = new <span class="keyword">Person</span>();</span><br><span class="line">   		System.out.println(per.getClass().getName());</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序将打印出<code>Person</code>，说明成功地由对象信息反射得到类信息。实际上per.getClass()得到的是<em>Class</em>实例，可以这么说，<strong>Java中的所有对象都是Class类的实例</strong>，得到某个对象的Class类实例对象，便可以反射出该对象所属类的所有信息，例如所有的构造方法，方法，属性，修饰符，接口，异常等信息，这些都有反射专属类的支持，Constructor类，Method类，Field类，Modifer类,，Interface类，这些类都为与java.lang.reflect包里，因此使用的时候，别忘了导入包。而通常获取一个对象Class实例的方式有三种：per.getClass()是第一种，Person.class是第二种；Class.forName(“Person”)//实际中需要指定包名，这三种方式以第三种使用最多。重新修改main方法：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> TestReflection&#123;</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   		<span class="keyword">Class</span> c;</span><br><span class="line">  	 	c = <span class="keyword">Class</span>.forName(<span class="string">"Person"</span>);</span><br><span class="line">   		System.out.<span class="keyword">println</span>(c.getName());</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序同样能打印出Person信息，现在尝试用c实例化Person对象：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class TestReflection&#123;</span><br><span class="line">  	public static void main(String<span class="comment">[]</span> args) throws Exception &#123;</span><br><span class="line">   		Class c = null;</span><br><span class="line">   		c = Class.forName(<span class="string">"Person"</span>);</span><br><span class="line">   		<span class="keyword">Person</span> per = (<span class="keyword">Person</span>)c.newInstance();</span><br><span class="line">   		System.out.println(per);</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序成功输出：</p>
<blockquote>
<p>Per(name = null, age = 0)</p>
</blockquote>
<p>如果将Person类的无参构造函数去掉的话，这时就会出现异常：</p>
<blockquote>
<p>Exception in thread “main” java.lang.InstantiationException: Person<br> at java.lang.Class.newInstance(Unknown Source)<br> at TestReflection.main(TestReflection.java:5)</p>
</blockquote>
<p>显然程序是通过反射调用无参构造函数来实现Person类对象的实例化，所以一般我们都需要手动为一个类加上无参构造函数。现在利用Class实例对象输出Person类的所有构造函数：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.*;</span><br><span class="line">public class TestReflection&#123;</span><br><span class="line"> 	public static void main(String<span class="comment">[]</span> args) throws Exception &#123;</span><br><span class="line">  		Class c = null;</span><br><span class="line">  		c = Class.forName(<span class="string">"Person"</span>);</span><br><span class="line">  		//<span class="keyword">Person</span> per = (<span class="keyword">Person</span>)c.newInstance();</span><br><span class="line">  		Constructor cons<span class="comment">[]</span> = c.getConstructors();</span><br><span class="line">  		for(int i=0;i&lt;cons.length;i++)&#123;</span><br><span class="line">   			System.out.println(cons<span class="comment">[i]</span>);</span><br><span class="line">  		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<blockquote>
<p>public Person()<br>public Person(java.lang.String,int)</p>
</blockquote>
<p>发现以上输出方法参数中没有修饰符，使用Modifier类调整输出如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestReflection</span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws Exception </span>&#123;</span><br><span class="line">  		Class c = <span class="keyword">null</span>;</span><br><span class="line">  		c = Class.forName(<span class="string">"Person"</span>);</span><br><span class="line">  		<span class="comment">//Person per = (Person)c.newInstance();</span></span><br><span class="line">  		Constructor cons[] = c.getConstructors();</span><br><span class="line">  		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cons.length;i++)&#123;</span><br><span class="line">   			Class <span class="keyword">params</span>[] = cons[i].getParameterTypes();</span><br><span class="line">   			<span class="keyword">int</span> mod = cons[i].getModifiers();</span><br><span class="line">   			System.<span class="keyword">out</span>.print(Modifier.toString(mod) + <span class="string">" "</span> + cons[i].getName() + <span class="string">"("</span>);</span><br><span class="line"> </span><br><span class="line">   			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="keyword">params</span>.length;j++)&#123;</span><br><span class="line">    			System.<span class="keyword">out</span>.print(<span class="keyword">params</span>[j].getName() + <span class="string">" "</span> + <span class="string">"arg-"</span> + j);</span><br><span class="line">    			<span class="keyword">if</span>(j &lt; <span class="keyword">params</span>.length-<span class="number">1</span>)&#123;</span><br><span class="line">     				System.<span class="keyword">out</span>.print(<span class="string">", "</span>);</span><br><span class="line">    			&#125;</span><br><span class="line">   			&#125;</span><br><span class="line">   			System.<span class="keyword">out</span>.print(<span class="string">")"</span>);</span><br><span class="line">   			System.<span class="keyword">out</span>.println();</span><br><span class="line">  		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过调整之后，输出如下的合理信息：</p>
<blockquote>
<p>public Person()<br>public Person(java.lang.String arg-0, int arg-1)</p>
</blockquote>
<p>现在换一种实例化Person对象的方式，采用Class实例对象得到的构造函数来实例化Person对象，如下：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Person</span> per1 = (<span class="keyword">Person</span>)cons<span class="comment">[0]</span>.newInstance();</span><br><span class="line"><span class="keyword">Person</span> per2 = (<span class="keyword">Person</span>)cons<span class="comment">[1]</span>.newInstance(<span class="string">"zhangsan"</span>, 20);</span><br><span class="line">System.out.println(per1);</span><br><span class="line">System.out.println(per2);</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<blockquote>
<p>Per(name = null, age = 0)<br>Per(name = zhangsan, age = 20)</p>
</blockquote>
<p>说明此种方式可以有效地针对构造函数的不同实例化对象，下面再介绍由Class实例对象反射得到Person类的其他方法以及调用的方式。获得Method实例，使用invoke方法实现调用。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method <span class="keyword">m</span> = c.getDeclaredMethod(<span class="string">"say"</span>,String.<span class="keyword">class</span>);</span><br><span class="line"><span class="keyword">m</span>.invoke(per2,<span class="string">"hello !!!"</span>);</span><br></pre></td></tr></table></figure>
<p>成功输出如下：</p>
<blockquote>
<p>Per(name = zhangsan, age = 20) say hello !!!</p>
</blockquote>
<p>好了，其他的诸如接口，属性，这里就不再赘述了，总之，反射，就是利用Class类实例，获取其他类的结构信息。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：Java反射知识是Java基础学习中非常重要的知识点之一，初期还体会不到反射机制的强大和神奇，到了后期Java Web和各种框架，包括Java对象反序列化等，这些都是以Java反射作为支撑，因此掌握Java反射是非常有必要的。]]>
    
    </summary>
    
      <category term="Java学习" scheme="http://blog.zbvae.com/tags/Java%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Echarts制作散点图(Excel 导入数据方式)]]></title>
    <link href="http://blog.zbvae.com/2015/07/11/%E4%BD%BF%E7%94%A8Echarts%E5%88%B6%E4%BD%9C%E6%95%A3%E7%82%B9%E5%9B%BE-Excel-%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE%E6%96%B9%E5%BC%8F/"/>
    <id>http://blog.zbvae.com/2015/07/11/使用Echarts制作散点图-Excel-导入数据方式/</id>
    <published>2015-07-11T02:34:53.000Z</published>
    <updated>2015-07-11T06:56:54.075Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：Echarts是一款有效的js制图工具很多时候，其主要优势在于网页浏览时，具有非常炫酷的效果，但是将其保存为静态图像也很美观。我们在写工作报告或写论文的时候，都需要制作基本的统计图表以直观展示结果数据，虽然Excel提供的图表制作工具能满足要求，但美观度欠佳，也许可以调整，但还是需要很大的工作量，今天给大家介绍一款非常实用的且有效的制图工具，相信，您亲自使用之后就知道它有多妙了！<a id="more"></a></p>
<h2 id="1-Echarts简介">1.Echarts简介</h2><p>　　Echarts相当于一款JS插件，可以制作出绚丽多彩的图表，其支持制作的图表类型和可以使用的样式都非常丰富。本文以Echarts制作散点图为例，向大家展示该工具的实用性。</p>
<h2 id="2-Echarts使用">2.Echarts使用</h2><p>　　Echarts的使用门槛非常简单，但使用条件必须符合规则，在<a href="http://echarts.baidu.com/" target="_blank" rel="external">官网</a>上下载开发包之后，自己准备一个项目主文件夹，在该文件夹新建一个js文件夹（名称自选），将开发包下的build文件夹下的dist文件夹拷贝到js文件夹下，便可以开始使用了。</p>
<p>　　Echarts的使用方式可以分为<strong>AMD模块化导入</strong>和<strong>单文件导入</strong>方式，本文介绍一种简单的单文件导入方式，首先准备好一个html文件，导入echarts.js文件即可。当然你还需要准备一个div控件用于安放图表位置，也可以认为是要为Echarts实例化的Dom对象，这里JavaScript代码也放在body标签下。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"GBK"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Echarts of scatter<span class="tag">&lt;/<span class="title">title</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--为Echarts准备一个大小为600*400的div--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"main"</span> <span class="attribute">style</span>=<span class="value">"width:600px;height:400px"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--Echarts单文件导入--&gt;</span>     </span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"./js/dist/echarts.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>至此，Echarts文件已完成导入，在使用之前，还需要进行路径配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"GBK"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Echarts of scatter<span class="tag">&lt;/<span class="title">title</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--为Echarts准备一个大小为600*400的div--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"main"</span> <span class="attribute">style</span>=<span class="value">"width:600px;height:400px"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--Echarts单文件导入--&gt;</span>     </span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"./js/dist/echarts.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="less"></span><br><span class="line">        <span class="comment">//配置路径</span></span><br><span class="line">        <span class="tag">require</span><span class="class">.config</span>(&#123;</span><br><span class="line">            <span class="tag">paths</span>:&#123;         </span><br><span class="line">                 <span class="attribute">echarts</span>:<span class="string">'./js/dist'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;) </span><br><span class="line">    </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>路径配置好后，可以进行使用，首先需要指定要制作的图表，进行模块导入，可以根据需要导入多个图表模块：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="less">    </span><br><span class="line">    <span class="comment">//配置路径 </span></span><br><span class="line">    <span class="tag">require</span><span class="class">.config</span>(&#123;</span><br><span class="line">      	<span class="tag">paths</span>:&#123;</span><br><span class="line">        	<span class="attribute">echarts</span>:<span class="string">'./js/dist'</span></span><br><span class="line">      	&#125; </span><br><span class="line">    &#125;) </span><br><span class="line">    <span class="comment">//使用     </span></span><br><span class="line">    <span class="tag">require</span>(</span><br><span class="line">        [     </span><br><span class="line">            <span class="string">'echarts'</span>,</span><br><span class="line">            <span class="string">'echarts/chart/scatter'</span> </span><br><span class="line">        ] </span><br><span class="line">    )</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>基于原先的div创建echarts，并使用，主要是图表option的配置:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="scala"></span><br><span class="line">  <span class="comment">//配置路径</span></span><br><span class="line">  require.config(&#123;</span><br><span class="line">   	paths:&#123;</span><br><span class="line">    	echarts:'./js/dist'</span><br><span class="line">   	&#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用</span></span><br><span class="line">  require(</span><br><span class="line">   	[</span><br><span class="line">    	<span class="symbol">'echart</span>s',</span><br><span class="line">    	<span class="symbol">'echarts</span>/chart/scatter'</span><br><span class="line">   	],</span><br><span class="line">  </span><br><span class="line">   function(ec)&#123;</span><br><span class="line">    <span class="comment">//基于准备好的DOM，初始化echarts图表</span></span><br><span class="line">    <span class="keyword">var</span> myChart = ec.init(document.getElementById(<span class="symbol">'mai</span>n'),<span class="symbol">'shin</span>e'); <span class="comment">//这里的shine可以改成其他样式，可以参照官网实例的样式表</span></span><br><span class="line">    <span class="keyword">var</span> option = &#123;</span><br><span class="line">     	title:&#123;</span><br><span class="line">      		<span class="comment">//可以指定图表标题</span></span><br><span class="line">     	&#125;,</span><br><span class="line">     	renderAsImage : <span class="literal">true</span>,</span><br><span class="line">    	<span class="comment">//symbolList : ["emptyCircle"],</span></span><br><span class="line">     	tooltip:&#123;<span class="comment">//提示框的显示，主要具有web效果</span></span><br><span class="line">      		show:<span class="literal">true</span>,</span><br><span class="line">      		trigger: <span class="symbol">'axi</span>s',</span><br><span class="line">      		showDelay : <span class="number">0</span>,</span><br><span class="line">      		axisPointer:&#123;</span><br><span class="line">       			show: <span class="literal">true</span>,</span><br><span class="line">      	 		<span class="class"><span class="keyword">type</span> :</span> <span class="symbol">'cros</span>s',</span><br><span class="line">       			lineStyle: &#123;</span><br><span class="line">        			<span class="class"><span class="keyword">type</span> :</span> <span class="symbol">'dashe</span>d',</span><br><span class="line">        			width : <span class="number">1</span></span><br><span class="line">       			&#125;</span><br><span class="line">      		&#125;</span><br><span class="line">     	&#125;,</span><br><span class="line"> </span><br><span class="line">     	xAxis:[</span><br><span class="line">      		&#123;</span><br><span class="line">       			name : <span class="symbol">'Wr</span>G',</span><br><span class="line">       			<span class="class"><span class="keyword">type</span> :</span> <span class="symbol">'valu</span>e',</span><br><span class="line">       			scale:<span class="literal">true</span>,</span><br><span class="line">      		&#125;</span><br><span class="line">     	],</span><br><span class="line"></span><br><span class="line">     	yAxis:[</span><br><span class="line">      		&#123;</span><br><span class="line">       			name: <span class="symbol">'C</span>u',</span><br><span class="line">       			<span class="class"><span class="keyword">type</span> :</span> <span class="symbol">'valu</span>e',</span><br><span class="line">       			scale:<span class="literal">true</span>,</span><br><span class="line">      		&#125;</span><br><span class="line">     	],</span><br><span class="line"></span><br><span class="line">     	series:[</span><br><span class="line">      		&#123;</span><br><span class="line">       			<span class="string">"name"</span>:<span class="string">"CuOre"</span>,</span><br><span class="line">       			<span class="string">"type"</span>:<span class="string">"scatter"</span>,</span><br><span class="line">       			<span class="string">"data"</span>:xyData,<span class="comment">//注意这里的xyData就是关键的散点图显示数据，是一个二维数组，即数组内部每一个元素都是xy值对</span></span><br><span class="line">       			<span class="string">"markPoint"</span> : &#123;</span><br><span class="line">        			<span class="comment">//标记点 </span></span><br><span class="line">        			data : [</span><br><span class="line">        				&#123;<span class="class"><span class="keyword">type</span>:</span><span class="symbol">'ma</span>x'&#125;,</span><br><span class="line">        				&#123;<span class="class"><span class="keyword">type</span>:</span><span class="symbol">'mi</span>n'&#125; </span><br><span class="line">        			]</span><br><span class="line">       			&#125;,</span><br><span class="line">       			<span class="string">"markLine"</span> : &#123;</span><br><span class="line">            		<span class="comment">//标记线自己定制 </span></span><br><span class="line">        		&#125;</span><br><span class="line">      		&#125;</span><br><span class="line">     	]</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//为ECharts对象加载数据</span></span><br><span class="line">    myChart.setOption(option);</span><br><span class="line">   	&#125;</span><br><span class="line">  );</span><br><span class="line"> </span><br><span class="line"> </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在图表的各项已经配置完毕，关键就是xyData数据的充填，当然用户可以自行指定为：[[1,2],[2,2],[3,4],[4,5]],数据少的时候我们可以直接充填，但是数据条目一旦很多，人工输入就很难完成了，因此这里介绍一种从Excel导入数据,再利用js重新组装来进行xyData的充填。代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 以下是设置从Excel中加载数据--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">importXLS</span>(<span class="params">field</span>)</span>&#123;   </span><br><span class="line">       	<span class="keyword">var</span> fullpath = <span class="built_in">window</span>.document.location.pathname;</span><br><span class="line">       	<span class="keyword">var</span> pos1 = fullpath.indexOf(<span class="string">"/"</span>);</span><br><span class="line">       	<span class="keyword">var</span> fileName1 = fullpath.substring(pos1+<span class="number">1</span>);</span><br><span class="line">       	<span class="keyword">var</span> pos2 = fileName1.lastIndexOf(<span class="string">"/"</span>);</span><br><span class="line"> </span><br><span class="line">       	<span class="keyword">var</span> fileName = fileName1.substring(<span class="number">0</span>,pos2) + <span class="string">"/scatter_data.xls"</span>;<span class="comment">// xls文件的路径  </span></span><br><span class="line">       	objCon = <span class="keyword">new</span> ActiveXObject(<span class="string">"ADODB.Connection"</span>); </span><br><span class="line">       	objCon.Provider = <span class="string">"Microsoft.Jet.OLEDB.4.0"</span>;  </span><br><span class="line">       	objCon.ConnectionString = <span class="string">"Data Source="</span> + fileName + <span class="string">";Extended Properties=Excel 8.0;"</span>;  </span><br><span class="line">       	objCon.CursorLocation = <span class="number">1</span>;  </span><br><span class="line">       	objCon.Open;  </span><br><span class="line">       	<span class="keyword">var</span> strQuery;  </span><br><span class="line">     </span><br><span class="line">    	<span class="comment">//Get the SheetName  </span></span><br><span class="line">       	<span class="keyword">var</span> strSheetName = <span class="string">"Sheet1$"</span>; <span class="comment">//要导入的sheet的名字  </span></span><br><span class="line">  </span><br><span class="line">   		<span class="keyword">var</span> rsTemp =   <span class="keyword">new</span> ActiveXObject(<span class="string">"ADODB.Recordset"</span>);  </span><br><span class="line">   		rsTemp = objCon.OpenSchema(<span class="number">20</span>);  </span><br><span class="line">   		<span class="keyword">if</span>(!rsTemp.EOF)strSheetName = rsTemp.Fields(<span class="string">"Table_Name"</span>).Value;  </span><br><span class="line">   		rsTemp = <span class="literal">null</span>;  </span><br><span class="line"> </span><br><span class="line">   		rsExcel =   <span class="keyword">new</span> ActiveXObject(<span class="string">"ADODB.Recordset"</span>);  </span><br><span class="line">   		strQuery = <span class="string">"SELECT * FROM ["</span> + strSheetName + <span class="string">"]"</span>;  </span><br><span class="line">   		rsExcel.ActiveConnection = objCon;  </span><br><span class="line">   		rsExcel.Open(strQuery);  </span><br><span class="line">  </span><br><span class="line">   		<span class="keyword">var</span> res = [];  </span><br><span class="line">   		<span class="keyword">var</span> temp;  </span><br><span class="line">   		<span class="keyword">while</span>(!rsExcel.EOF)&#123;  </span><br><span class="line">    		temp = rsExcel.Fields(field).value; </span><br><span class="line">    		res.push(temp);       </span><br><span class="line">    		rsExcel.MoveNext;     </span><br><span class="line">   		&#125;   </span><br><span class="line"> </span><br><span class="line">   		<span class="comment">// Close the connection and dispose the file  </span></span><br><span class="line">   		objCon.Close;  </span><br><span class="line">   		objCon =<span class="literal">null</span>;  </span><br><span class="line">   		rsExcel = <span class="literal">null</span>;  </span><br><span class="line">   		<span class="keyword">return</span> res;   </span><br><span class="line"> 	&#125;  </span><br><span class="line"> </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>导入的Excel数据是读取某个字段的一维数组数据，我们需要导入x,y两个字段的数据，并组装成xyData二维数组格式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">	<span class="function"><span class="keyword">function</span>(<span class="params">ec</span>)</span>&#123;</span><br><span class="line">	    <span class="keyword">var</span> xData = importXLS(<span class="number">1</span>);</span><br><span class="line">	    <span class="keyword">var</span> yData = importXLS(<span class="number">2</span>);</span><br><span class="line">	    <span class="keyword">var</span> xyData = [];</span><br><span class="line">	  </span><br><span class="line">	    <span class="keyword">var</span> i;</span><br><span class="line">	    <span class="comment">//转化为散点图需要的二维数组系列</span></span><br><span class="line">	    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;xData.length;i++)&#123;</span><br><span class="line">	     xyData.push(<span class="keyword">new</span> <span class="built_in">Array</span>(xData[i],yData[i]));</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">//基于准备好的DOM，初始化echarts图表</span></span><br><span class="line">	    <span class="keyword">var</span> myChart = ec.init(<span class="built_in">document</span>.getElementById(<span class="string">'main'</span>),<span class="string">'shine'</span>);</span><br><span class="line">	    ... <span class="comment">//接着上面的使用Echarts的代码</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样便实现了从Excel中导入数据，重新组装，充填为散点图所需要的二维数组格式。给一个本程序生成的静态图片如下：</p>
<center><img src="/images/scatter1.png" alt="散点图，样式为infographic"><img src="/images/scatter2.png" alt="散点图，样式为shine"></center>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：Echarts是一款有效的js制图工具很多时候，其主要优势在于网页浏览时，具有非常炫酷的效果，但是将其保存为静态图像也很美观。我们在写工作报告或写论文的时候，都需要制作基本的统计图表以直观展示结果数据，虽然Excel提供的图表制作工具能满足要求，但美观度欠佳，也许可以调整，但还是需要很大的工作量，今天给大家介绍一款非常实用的且有效的制图工具，相信，您亲自使用之后就知道它有多妙了！]]>
    
    </summary>
    
      <category term="技术交流" scheme="http://blog.zbvae.com/tags/%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 对象克隆]]></title>
    <link href="http://blog.zbvae.com/2015/07/11/Java-%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86/"/>
    <id>http://blog.zbvae.com/2015/07/11/Java-对象克隆/</id>
    <published>2015-07-11T02:17:54.000Z</published>
    <updated>2015-07-11T06:55:06.458Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：Java最大的简洁性在于去除了指针，以引用来代替，在函数传参过程中，一般分为<strong>值传递</strong>和<strong>引用传递</strong>，值传递是直接拷贝一份值单元传递过去，原有值不会随被传递值改变而改变；引用传递则传递的是该引用数据类型变量的内存地址，因此原有对象属性值会随着传递引用变量对其的改变而达到间接改变的目的。Java中对所有复杂数据类型包括数组的传递都是引用传递方式，即传其地址，那么如何使Java具有像C和C++那样传递复杂数据类型，而不改变原有值的属性，这就需要利用到Java对象克隆知识了。 <a id="more"></a></p>
<h2 id="1-String_传递">1.String 传递</h2><p>　　首先声明一点，虽然String也属于引用数据类型，但是它属于Java语言当中设计的特殊类型，具有值不可更改的特点，因此在进行参数传递时，不具备引用传递的特点，而是当成值传递方式来代替。</p>
<h2 id="2-浅克隆">2.浅克隆</h2><p>　　所有的对象都具有拷贝（克隆）的功能，因为Object类中就定义了clone方法。一个类需要被克隆，则该类必须明确继承Cloneable接口，该接口只是其标识作用，另外还必须在该类中重写Object类提供的clone方法，使之支持对象克隆。<br>　　Java对象一般性的克隆，属于<strong>浅克隆</strong>。浅克隆是指只克隆当前对象的副本，而不管该对象内部成员对象是否需要拷贝副本，因此成员对象还是使用原来的引用指向，所以一旦改变克隆对象的成员对象的值，原有值的成员对象属性变量的值也会发生变化。</p>
<h2 id="3-深克隆">3.深克隆</h2><p>　　如果需要彻底解决这种弊端，则需要一次性克隆到底，使用<strong>深克隆</strong>的方式。不但对该对象拷贝副本，对该对象成员对象也进行拷贝，甚至逐级拷贝下去，需要注意的是，这种方式下，成员对象所在类必须支持克隆属性，重写clone方法。</p>
<h2 id="4-示例程序">4.示例程序</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">public class TestObjClone&#123;</span><br><span class="line">  	public static void main(String<span class="comment">[]</span> args) &#123;</span><br><span class="line">  		<span class="keyword">Person</span> per = new <span class="keyword">Person</span>(<span class="string">"zhangsan"</span>, 20);</span><br><span class="line">  		<span class="keyword">Animal</span> a = new <span class="keyword">Animal</span>(<span class="string">"xiaohei"</span>, 8, per);</span><br><span class="line">  		<span class="keyword">Animal</span> b = null;</span><br><span class="line"></span><br><span class="line">  		System.out.println(<span class="string">"before clone: "</span>);</span><br><span class="line">  		System.out.println(<span class="string">"\tAnimal b is null and Animal a is: \n"</span> + a);</span><br><span class="line"></span><br><span class="line">  		b = (<span class="keyword">Animal</span>)a.clone();</span><br><span class="line">  		b.getMaster().setName(<span class="string">"wangwu"</span>);</span><br><span class="line">  		b.getMaster().setAge(50);</span><br><span class="line"></span><br><span class="line">  		System.out.println(<span class="string">"after clone: "</span>);</span><br><span class="line">  		System.out.println(<span class="string">"\tAnimal b master has been changed and Animal a is: \n"</span> + a);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class <span class="keyword">Animal</span> implements Cloneable&#123;</span><br><span class="line"> 	private String name;</span><br><span class="line"> 	private int age;</span><br><span class="line"> 	private <span class="keyword">Person</span> master;</span><br><span class="line"></span><br><span class="line"> 	public <span class="keyword">Animal</span>()&#123;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public <span class="keyword">Animal</span>(String name, int age, <span class="keyword">Person</span> master)&#123;</span><br><span class="line">  		this.name = name;</span><br><span class="line">  		this.age = age;</span><br><span class="line">  		this.master = master;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public String getName() &#123;</span><br><span class="line">     	return this.name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> 	public int getAge() &#123;</span><br><span class="line">     	return this.age;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public <span class="keyword">Person</span> getMaster()&#123;</span><br><span class="line">  		return this.master;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public void setName(String name) &#123;</span><br><span class="line">     	this.name = name;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public void setAge(int age) &#123;</span><br><span class="line">     	this.age = age;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public void setMaster(<span class="keyword">Person</span> master)&#123;</span><br><span class="line">  		this.master = master;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public String toString()&#123;</span><br><span class="line">  		return <span class="string">"Animal(name = "</span> + this.getName() + <span class="string">", age = "</span> + this.getAge() </span><br><span class="line">  		+ <span class="string">", master = \n"</span>+ this.getMaster() +<span class="string">")"</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public Object clone()&#123;</span><br><span class="line">  		<span class="keyword">Animal</span> obj = null;</span><br><span class="line">  		try&#123;</span><br><span class="line">  	 		obj = (<span class="keyword">Animal</span>)super.clone();</span><br><span class="line">   			obj.master = (<span class="keyword">Person</span>)master.clone();</span><br><span class="line">  		&#125;catch(CloneNotSupportedException e)&#123;</span><br><span class="line">  		&#125;</span><br><span class="line">  		return obj;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class <span class="keyword">Person</span> implements Cloneable&#123;</span><br><span class="line"> 	private String name;</span><br><span class="line"> 	private int age;</span><br><span class="line"></span><br><span class="line"> 	public <span class="keyword">Person</span>()&#123;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public <span class="keyword">Person</span>(String name, int age)&#123;</span><br><span class="line">  		this.name = name;</span><br><span class="line">  		this.age = age;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public String getName() &#123;</span><br><span class="line">     	return this.name;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public int getAge() &#123;</span><br><span class="line">     	return this.age;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public void setName(String name) &#123;</span><br><span class="line">     	this.name = name;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public void setAge(int age) &#123;</span><br><span class="line">     	this.age = age;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public String toString()&#123;</span><br><span class="line">  		return <span class="string">"Per(name = "</span> + this.getName() + <span class="string">", age = "</span> + this.getAge() + <span class="string">")"</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	public Object clone()&#123;</span><br><span class="line">  		<span class="keyword">Person</span> obj = null;</span><br><span class="line">  		try&#123;</span><br><span class="line">   			obj = (<span class="keyword">Person</span>)super.clone();</span><br><span class="line">  		&#125;catch(CloneNotSupportedException e)&#123;</span><br><span class="line">  	&#125;</span><br><span class="line"> 	return obj;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出如下内容：</p>
<blockquote>
<p>before clone:<br>    Animal b is null and Animal a is:<br>Animal(name = xiaohei, age = 8, master =<br>Per(name = zhangsan, age = 20))<br>after clone:<br>    Animal b master has been changed and Animal a is:<br>Animal(name = xiaohei, age = 8, master =<br>Per(name = zhangsan, age = 20))</p>
</blockquote>
<p>　　以上输出说明进行深克隆后，原有对象中成员对象属性值不会再发生改变。要想测试浅克隆只需将Person类的克隆属性去掉，即取消Cloneable接口和clone方法，另外还需注释掉Animal类clone方法里的master成员对象的克隆，即为浅克隆方式，此种方式下，原有对象的成员对象属性值也会发生改变。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：Java最大的简洁性在于去除了指针，以引用来代替，在函数传参过程中，一般分为<strong>值传递</strong>和<strong>引用传递</strong>，值传递是直接拷贝一份值单元传递过去，原有值不会随被传递值改变而改变；引用传递则传递的是该引用数据类型变量的内存地址，因此原有对象属性值会随着传递引用变量对其的改变而达到间接改变的目的。Java中对所有复杂数据类型包括数组的传递都是引用传递方式，即传其地址，那么如何使Java具有像C和C++那样传递复杂数据类型，而不改变原有值的属性，这就需要利用到Java对象克隆知识了。]]>
    
    </summary>
    
      <category term="Java学习" scheme="http://blog.zbvae.com/tags/Java%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>